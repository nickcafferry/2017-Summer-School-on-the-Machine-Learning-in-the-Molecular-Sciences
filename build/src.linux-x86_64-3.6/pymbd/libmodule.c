/* File: libmodule.c
 * This file is auto-generated with f2py (version:2).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * See http://cens.ioc.ee/projects/f2py2e/
 * Generation date: Wed Jul 26 22:32:42 2017
 * $Revision:$
 * $Date:$
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include <stdarg.h>
#include "Python.h"
#include "fortranobject.h"
#include <string.h>
#include <math.h>

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *lib_error;
static PyObject *lib_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
typedef signed char signed_char;
typedef char * string;
typedef struct {double r,i;} complex_double;

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
/*need_typedefs_generated*/

/********************** See f2py2e/cfuncs.py: cppmacros **********************/
#define PRINTPYOBJERR(obj)\
  fprintf(stderr,"lib.error is related to ");\
  PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
  fprintf(stderr,"\n");

#define pyobj_from_int1(v) (PyInt_FromLong(v))
\
#define FAILNULL(p) do {                                            \
    if ((p) == NULL) {                                              \
        PyErr_SetString(PyExc_MemoryError, "NULL pointer found");   \
        goto capi_fail;                                             \
    }                                                               \
} while (0)

#define STRINGMALLOC(str,len)\
  if ((str = (string)malloc(sizeof(char)*(len+1))) == NULL) {\
    PyErr_SetString(PyExc_MemoryError, "out of memory");\
    goto capi_fail;\
  } else {\
    (str)[len] = '\0';\
  }

#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
  PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
  fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif

#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif

#define rank(var) var ## _Rank
#define shape(var,dim) var ## _Dims[dim]
#define old_rank(var) (PyArray_NDIM((PyArrayObject *)(capi_ ## var ## _tmp)))
#define old_shape(var,dim) PyArray_DIM(((PyArrayObject *)(capi_ ## var ## _tmp)),dim)
#define fshape(var,dim) shape(var,rank(var)-dim-1)
#define len(var) shape(var,0)
#define flen(var) fshape(var,0)
#define old_size(var) PyArray_SIZE((PyArrayObject *)(capi_ ## var ## _tmp))
/* #define index(i) capi_i ## i */
#define slen(var) capi_ ## var ## _len
#define size(var, ...) f2py_size((PyArrayObject *)(capi_ ## var ## _tmp), ## __VA_ARGS__, -1)

#define STRINGFREE(str) do {if (!(str == NULL)) free(str);} while (0)

#define CHECKSCALAR(check,tcheck,name,show,var)\
  if (!(check)) {\
    char errstring[256];\
    sprintf(errstring, "%s: "show, "("tcheck") failed for "name, var);\
    PyErr_SetString(lib_error,errstring);\
    /*goto capi_fail;*/\
  } else 
#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif

/* New SciPy */
#define TRYPYARRAYTEMPLATECHAR case NPY_STRING: *(char *)(PyArray_DATA(arr))=*v; break;
#define TRYPYARRAYTEMPLATELONG case NPY_LONG: *(long *)(PyArray_DATA(arr))=*v; break;
#define TRYPYARRAYTEMPLATEOBJECT case NPY_OBJECT: (PyArray_DESCR(arr)->f->setitem)(pyobj_from_ ## ctype ## 1(*v),PyArray_DATA(arr)); break;

#define TRYPYARRAYTEMPLATE(ctype,typecode) \
        PyArrayObject *arr = NULL;\
        if (!obj) return -2;\
        if (!PyArray_Check(obj)) return -1;\
        if (!(arr=(PyArrayObject *)obj)) {fprintf(stderr,"TRYPYARRAYTEMPLATE:");PRINTPYOBJERR(obj);return 0;}\
        if (PyArray_DESCR(arr)->type==typecode)  {*(ctype *)(PyArray_DATA(arr))=*v; return 1;}\
        switch (PyArray_TYPE(arr)) {\
                case NPY_DOUBLE: *(double *)(PyArray_DATA(arr))=*v; break;\
                case NPY_INT: *(int *)(PyArray_DATA(arr))=*v; break;\
                case NPY_LONG: *(long *)(PyArray_DATA(arr))=*v; break;\
                case NPY_FLOAT: *(float *)(PyArray_DATA(arr))=*v; break;\
                case NPY_CDOUBLE: *(double *)(PyArray_DATA(arr))=*v; break;\
                case NPY_CFLOAT: *(float *)(PyArray_DATA(arr))=*v; break;\
                case NPY_BOOL: *(npy_bool *)(PyArray_DATA(arr))=(*v!=0); break;\
                case NPY_UBYTE: *(unsigned char *)(PyArray_DATA(arr))=*v; break;\
                case NPY_BYTE: *(signed char *)(PyArray_DATA(arr))=*v; break;\
                case NPY_SHORT: *(short *)(PyArray_DATA(arr))=*v; break;\
                case NPY_USHORT: *(npy_ushort *)(PyArray_DATA(arr))=*v; break;\
                case NPY_UINT: *(npy_uint *)(PyArray_DATA(arr))=*v; break;\
                case NPY_ULONG: *(npy_ulong *)(PyArray_DATA(arr))=*v; break;\
                case NPY_LONGLONG: *(npy_longlong *)(PyArray_DATA(arr))=*v; break;\
                case NPY_ULONGLONG: *(npy_ulonglong *)(PyArray_DATA(arr))=*v; break;\
                case NPY_LONGDOUBLE: *(npy_longdouble *)(PyArray_DATA(arr))=*v; break;\
                case NPY_CLONGDOUBLE: *(npy_longdouble *)(PyArray_DATA(arr))=*v; break;\
                case NPY_OBJECT: (PyArray_DESCR(arr)->f->setitem)(pyobj_from_ ## ctype ## 1(*v),PyArray_DATA(arr), arr); break;\
        default: return -2;\
        };\
        return 1

#define STRINGCOPYN(to,from,buf_size)                           \
    do {                                                        \
        int _m = (buf_size);                                    \
        char *_to = (to);                                       \
        char *_from = (from);                                   \
        FAILNULL(_to); FAILNULL(_from);                         \
        (void)strncpy(_to, _from, sizeof(char)*_m);             \
        _to[_m-1] = '\0';                                      \
        /* Padding with spaces instead of nulls */              \
        for (_m -= 2; _m >= 0 && _to[_m] == '\0'; _m--) {      \
            _to[_m] = ' ';                                      \
        }                                                       \
    } while (0)


/************************ See f2py2e/cfuncs.py: cfuncs ************************/
static int f2py_size(PyArrayObject* var, ...)
{
  npy_int sz = 0;
  npy_int dim;
  npy_int rank;
  va_list argp;
  va_start(argp, var);
  dim = va_arg(argp, npy_int);
  if (dim==-1)
    {
      sz = PyArray_SIZE(var);
    }
  else
    {
      rank = PyArray_NDIM(var);
      if (dim>=1 && dim<=rank)
        sz = PyArray_DIM(var, dim-1);
      else
        fprintf(stderr, "f2py_size: 2nd argument value=%d fails to satisfy 1<=value<=%d. Result will be 0.\n", dim, rank);
    }
  va_end(argp);
  return sz;
}

static int int_from_pyobj(int* v,PyObject *obj,const char *errmess) {
  PyObject* tmp = NULL;
  if (PyInt_Check(obj)) {
    *v = (int)PyInt_AS_LONG(obj);
    return 1;
  }
  tmp = PyNumber_Int(obj);
  if (tmp) {
    *v = PyInt_AS_LONG(tmp);
    Py_DECREF(tmp);
    return 1;
  }
  if (PyComplex_Check(obj))
    tmp = PyObject_GetAttrString(obj,"real");
  else if (PyString_Check(obj) || PyUnicode_Check(obj))
    /*pass*/;
  else if (PySequence_Check(obj))
    tmp = PySequence_GetItem(obj,0);
  if (tmp) {
    PyErr_Clear();
    if (int_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
    Py_DECREF(tmp);
  }
  {
    PyObject* err = PyErr_Occurred();
    if (err==NULL) err = lib_error;
    PyErr_SetString(err,errmess);
  }
  return 0;
}

static int string_from_pyobj(string *str,int *len,const string inistr,PyObject *obj,const char *errmess) {
  PyArrayObject *arr = NULL;
  PyObject *tmp = NULL;
#ifdef DEBUGCFUNCS
fprintf(stderr,"string_from_pyobj(str='%s',len=%d,inistr='%s',obj=%p)\n",(char*)str,*len,(char *)inistr,obj);
#endif
  if (obj == Py_None) {
    if (*len == -1)
      *len = strlen(inistr); /* Will this cause problems? */
    STRINGMALLOC(*str,*len);
    STRINGCOPYN(*str,inistr,*len+1);
    return 1;
  }
  if (PyArray_Check(obj)) {
    if ((arr = (PyArrayObject *)obj) == NULL)
      goto capi_fail;
    if (!ISCONTIGUOUS(arr)) {
      PyErr_SetString(PyExc_ValueError,"array object is non-contiguous.");
      goto capi_fail;
    }
    if (*len == -1)
      *len = (PyArray_ITEMSIZE(arr))*PyArray_SIZE(arr);
    STRINGMALLOC(*str,*len);
    STRINGCOPYN(*str,PyArray_DATA(arr),*len+1);
    return 1;
  }
  if (PyString_Check(obj)) {
    tmp = obj;
    Py_INCREF(tmp);
  }
#if PY_VERSION_HEX >= 0x03000000
  else if (PyUnicode_Check(obj)) {
    tmp = PyUnicode_AsASCIIString(obj);
  }
  else {
    PyObject *tmp2;
    tmp2 = PyObject_Str(obj);
    if (tmp2) {
      tmp = PyUnicode_AsASCIIString(tmp2);
      Py_DECREF(tmp2);
    }
    else {
      tmp = NULL;
    }
  }
#else
  else {
    tmp = PyObject_Str(obj);
  }
#endif
  if (tmp == NULL) goto capi_fail;
  if (*len == -1)
    *len = PyString_GET_SIZE(tmp);
  STRINGMALLOC(*str,*len);
  STRINGCOPYN(*str,PyString_AS_STRING(tmp),*len+1);
  Py_DECREF(tmp);
  return 1;
capi_fail:
  Py_XDECREF(tmp);
  {
    PyObject* err = PyErr_Occurred();
    if (err==NULL) err = lib_error;
    PyErr_SetString(err,errmess);
  }
  return 0;
}

static int double_from_pyobj(double* v,PyObject *obj,const char *errmess) {
  PyObject* tmp = NULL;
  if (PyFloat_Check(obj)) {
#ifdef __sgi
    *v = PyFloat_AsDouble(obj);
#else
    *v = PyFloat_AS_DOUBLE(obj);
#endif
    return 1;
  }
  tmp = PyNumber_Float(obj);
  if (tmp) {
#ifdef __sgi
    *v = PyFloat_AsDouble(tmp);
#else
    *v = PyFloat_AS_DOUBLE(tmp);
#endif
    Py_DECREF(tmp);
    return 1;
  }
  if (PyComplex_Check(obj))
    tmp = PyObject_GetAttrString(obj,"real");
  else if (PyString_Check(obj) || PyUnicode_Check(obj))
    /*pass*/;
  else if (PySequence_Check(obj))
    tmp = PySequence_GetItem(obj,0);
  if (tmp) {
    PyErr_Clear();
    if (double_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
    Py_DECREF(tmp);
  }
  {
    PyObject* err = PyErr_Occurred();
    if (err==NULL) err = lib_error;
    PyErr_SetString(err,errmess);
  }
  return 0;
}

static int try_pyarr_from_int(PyObject* obj,int* v) {
  TRYPYARRAYTEMPLATE(int,'i');
}


/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/
/*need_callbacks*/

/*********************** See f2py2e/rules.py: buildapi ***********************/

/************************************* ts *************************************/
static char doc_f2py_rout_lib_mbd_ts[] = "\
ts(id,[always])\n\nWrapper for ``ts``.\
\n\nParameters\n----------\n"
"id : input int\n"
"\nOther Parameters\n----------------\n"
"always : input int";
/*  */
static PyObject *f2py_rout_lib_mbd_ts(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int id = 0;
  PyObject *id_capi = Py_None;
  int always = 0;
  PyObject *always_capi = Py_None;
  static char *capi_kwlist[] = {"id","always",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:lib.mbd.ts",\
    capi_kwlist,&id_capi,&always_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable id */
    f2py_success = int_from_pyobj(&id,id_capi,"lib.mbd.ts() 1st argument (id) can't be converted to int");
  if (f2py_success) {
  /* Processing variable always */
  if (always_capi != Py_None)
    always = (int)PyObject_IsTrue(always_capi);
    f2py_success = 1;
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&id,&always);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of always*/
  /* End of cleaning variable always */
  } /*if (f2py_success) of id*/
  /* End of cleaning variable id */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/********************************* end of ts *********************************/

/********************************* clock_rate *********************************/
static char doc_f2py_rout_lib_mbd_clock_rate[] = "\
rate = clock_rate()\n\nWrapper for ``clock_rate``.\
\n\nReturns\n-------\n"
"rate : int";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_clock_rate(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int clock_rate = 0;
  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":lib.mbd.clock_rate",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
  /* Processing variable clock_rate */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&clock_rate);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("i",clock_rate);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable clock_rate */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of clock_rate *****************************/

/******************************* get_ts_energy *******************************/
static char doc_f2py_rout_lib_mbd_get_ts_energy[] = "\
ene = get_ts_energy(mode,version,xyz,c6,alpha_0,[r_vdw,s_r,d,overlap,damping_custom,unit_cell])\n\nWrapper for ``get_ts_energy``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"version : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"c6 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"alpha_0 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"\nOther Parameters\n----------------\n"
"r_vdw : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"s_r : input float\n"
"d : input float\n"
"overlap : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"damping_custom : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"\nReturns\n-------\n"
"ene : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_ts_energy(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,string,double*,double*,double*,double*,double*,double*,double*,double*,double*,int*,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double get_ts_energy = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  string version = NULL;
  int slen(version);
  PyObject *version_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *c6 = NULL;
  npy_intp c6_Dims[1] = {-1};
  const int c6_Rank = 1;
  PyArrayObject *capi_c6_tmp = NULL;
  int capi_c6_intent = 0;
  PyObject *c6_capi = Py_None;
  double *alpha_0 = NULL;
  npy_intp alpha_0_Dims[1] = {-1};
  const int alpha_0_Rank = 1;
  PyArrayObject *capi_alpha_0_tmp = NULL;
  int capi_alpha_0_intent = 0;
  PyObject *alpha_0_capi = Py_None;
  double *r_vdw = NULL;
  npy_intp r_vdw_Dims[1] = {-1};
  const int r_vdw_Rank = 1;
  PyArrayObject *capi_r_vdw_tmp = NULL;
  int capi_r_vdw_intent = 0;
  PyObject *r_vdw_capi = Py_None;
  double s_r = 0;
  PyObject *s_r_capi = Py_None;
  double d = 0;
  PyObject *d_capi = Py_None;
  double *overlap = NULL;
  npy_intp overlap_Dims[2] = {-1, -1};
  const int overlap_Rank = 2;
  PyArrayObject *capi_overlap_tmp = NULL;
  int capi_overlap_intent = 0;
  PyObject *overlap_capi = Py_None;
  double *damping_custom = NULL;
  npy_intp damping_custom_Dims[2] = {-1, -1};
  const int damping_custom_Rank = 2;
  PyArrayObject *capi_damping_custom_tmp = NULL;
  int capi_damping_custom_intent = 0;
  PyObject *damping_custom_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  static char *capi_kwlist[] = {"mode","version","xyz","c6","alpha_0","r_vdw","s_r","d","overlap","damping_custom","unit_cell",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO|OOOOOO:lib.mbd.get_ts_energy",\
    capi_kwlist,&mode_capi,&version_capi,&xyz_capi,&c6_capi,&alpha_0_capi,&r_vdw_capi,&s_r_capi,&d_capi,&overlap_capi,&damping_custom_capi,&unit_cell_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.get_ts_energy to C string");
  if (f2py_success) {
  /* Processing variable version */
  slen(version) = -1;
  f2py_success = string_from_pyobj(&version,&slen(version),"",version_capi,"string_from_pyobj failed in converting 2nd argument `version' of lib.mbd.get_ts_energy to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `xyz' of lib.mbd.get_ts_energy to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable s_r */
  if (s_r_capi != Py_None)
    f2py_success = double_from_pyobj(&s_r,s_r_capi,"lib.mbd.get_ts_energy() 2nd keyword (s_r) can't be converted to double");
  if (f2py_success) {
  /* Processing variable d */
  if (d_capi != Py_None)
    f2py_success = double_from_pyobj(&d,d_capi,"lib.mbd.get_ts_energy() 3rd keyword (d) can't be converted to double");
  if (f2py_success) {
  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th keyword `unit_cell' of lib.mbd.get_ts_energy to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable c6 */
  c6_Dims[0]=size(xyz, 1);
  capi_c6_intent |= F2PY_INTENT_IN;
  capi_c6_tmp = array_from_pyobj(NPY_DOUBLE,c6_Dims,c6_Rank,capi_c6_intent,c6_capi);
  if (capi_c6_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `c6' of lib.mbd.get_ts_energy to C/Fortran array" );
  } else {
    c6 = (double *)(PyArray_DATA(capi_c6_tmp));

  /* Processing variable alpha_0 */
  alpha_0_Dims[0]=size(xyz, 1);
  capi_alpha_0_intent |= F2PY_INTENT_IN;
  capi_alpha_0_tmp = array_from_pyobj(NPY_DOUBLE,alpha_0_Dims,alpha_0_Rank,capi_alpha_0_intent,alpha_0_capi);
  if (capi_alpha_0_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `alpha_0' of lib.mbd.get_ts_energy to C/Fortran array" );
  } else {
    alpha_0 = (double *)(PyArray_DATA(capi_alpha_0_tmp));

  /* Processing variable r_vdw */
  r_vdw_Dims[0]=size(xyz, 1);
  capi_r_vdw_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_r_vdw_tmp = array_from_pyobj(NPY_DOUBLE,r_vdw_Dims,r_vdw_Rank,capi_r_vdw_intent,r_vdw_capi);
  if (capi_r_vdw_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `r_vdw' of lib.mbd.get_ts_energy to C/Fortran array" );
  } else {
    r_vdw = (double *)(PyArray_DATA(capi_r_vdw_tmp));

  /* Processing variable overlap */
  overlap_Dims[0]=size(xyz, 1),overlap_Dims[1]=size(xyz, 1);
  capi_overlap_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_overlap_tmp = array_from_pyobj(NPY_DOUBLE,overlap_Dims,overlap_Rank,capi_overlap_intent,overlap_capi);
  if (capi_overlap_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th keyword `overlap' of lib.mbd.get_ts_energy to C/Fortran array" );
  } else {
    overlap = (double *)(PyArray_DATA(capi_overlap_tmp));

  /* Processing variable damping_custom */
  damping_custom_Dims[0]=size(xyz, 1),damping_custom_Dims[1]=size(xyz, 1);
  capi_damping_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_damping_custom_tmp = array_from_pyobj(NPY_DOUBLE,damping_custom_Dims,damping_custom_Rank,capi_damping_custom_intent,damping_custom_capi);
  if (capi_damping_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th keyword `damping_custom' of lib.mbd.get_ts_energy to C/Fortran array" );
  } else {
    damping_custom = (double *)(PyArray_DATA(capi_damping_custom_tmp));

  /* Processing variable get_ts_energy */
  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_ts_energy,mode,version,xyz,c6,alpha_0,r_vdw,&s_r,&d,overlap,damping_custom,unit_cell,&f2py_xyz_d0,&f2py_xyz_d1,slen(mode),slen(version));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",get_ts_energy);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  /* End of cleaning variable get_ts_energy */
  if((PyObject *)capi_damping_custom_tmp!=damping_custom_capi) {
    Py_XDECREF(capi_damping_custom_tmp); }
  }  /*if (capi_damping_custom_tmp == NULL) ... else of damping_custom*/
  /* End of cleaning variable damping_custom */
  if((PyObject *)capi_overlap_tmp!=overlap_capi) {
    Py_XDECREF(capi_overlap_tmp); }
  }  /*if (capi_overlap_tmp == NULL) ... else of overlap*/
  /* End of cleaning variable overlap */
  if((PyObject *)capi_r_vdw_tmp!=r_vdw_capi) {
    Py_XDECREF(capi_r_vdw_tmp); }
  }  /*if (capi_r_vdw_tmp == NULL) ... else of r_vdw*/
  /* End of cleaning variable r_vdw */
  if((PyObject *)capi_alpha_0_tmp!=alpha_0_capi) {
    Py_XDECREF(capi_alpha_0_tmp); }
  }  /*if (capi_alpha_0_tmp == NULL) ... else of alpha_0*/
  /* End of cleaning variable alpha_0 */
  if((PyObject *)capi_c6_tmp!=c6_capi) {
    Py_XDECREF(capi_c6_tmp); }
  }  /*if (capi_c6_tmp == NULL) ... else of c6*/
  /* End of cleaning variable c6 */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  } /*if (f2py_success) of d*/
  /* End of cleaning variable d */
  } /*if (f2py_success) of s_r*/
  /* End of cleaning variable s_r */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(version);
  }  /*if (f2py_success) of version*/
  /* End of cleaning variable version */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of get_ts_energy ****************************/

/***************************** add_dipole_matrix *****************************/
static char doc_f2py_rout_lib_mbd_add_dipole_matrix[] = "\
add_dipole_matrix(mode,version,xyz,[alpha,r_vdw,beta,a,overlap,c6,damping_custom,potential_custom,unit_cell,k_point,relay,relay_c])\n\nWrapper for ``add_dipole_matrix``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"version : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"\nOther Parameters\n----------------\n"
"alpha : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"r_vdw : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"beta : input float\n"
"a : input float\n"
"overlap : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"c6 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"damping_custom : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"potential_custom : input rank-4 array('d') with bounds (size(xyz, 1),size(xyz, 1),3,3)\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"k_point : input rank-1 array('d') with bounds (3)\n"
"relay : in/output rank-2 array('d') with bounds (3*size(xyz, 1),3*size(xyz, 1))\n"
"relay_c : in/output rank-2 array('D') with bounds (3*size(xyz, 1),3*size(xyz, 1))";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_add_dipole_matrix(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,string,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,complex_double*,int*,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  string version = NULL;
  int slen(version);
  PyObject *version_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *alpha = NULL;
  npy_intp alpha_Dims[1] = {-1};
  const int alpha_Rank = 1;
  PyArrayObject *capi_alpha_tmp = NULL;
  int capi_alpha_intent = 0;
  PyObject *alpha_capi = Py_None;
  double *r_vdw = NULL;
  npy_intp r_vdw_Dims[1] = {-1};
  const int r_vdw_Rank = 1;
  PyArrayObject *capi_r_vdw_tmp = NULL;
  int capi_r_vdw_intent = 0;
  PyObject *r_vdw_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  double *overlap = NULL;
  npy_intp overlap_Dims[2] = {-1, -1};
  const int overlap_Rank = 2;
  PyArrayObject *capi_overlap_tmp = NULL;
  int capi_overlap_intent = 0;
  PyObject *overlap_capi = Py_None;
  double *c6 = NULL;
  npy_intp c6_Dims[1] = {-1};
  const int c6_Rank = 1;
  PyArrayObject *capi_c6_tmp = NULL;
  int capi_c6_intent = 0;
  PyObject *c6_capi = Py_None;
  double *damping_custom = NULL;
  npy_intp damping_custom_Dims[2] = {-1, -1};
  const int damping_custom_Rank = 2;
  PyArrayObject *capi_damping_custom_tmp = NULL;
  int capi_damping_custom_intent = 0;
  PyObject *damping_custom_capi = Py_None;
  double *potential_custom = NULL;
  npy_intp potential_custom_Dims[4] = {-1, -1, -1, -1};
  const int potential_custom_Rank = 4;
  PyArrayObject *capi_potential_custom_tmp = NULL;
  int capi_potential_custom_intent = 0;
  PyObject *potential_custom_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  double *k_point = NULL;
  npy_intp k_point_Dims[1] = {-1};
  const int k_point_Rank = 1;
  PyArrayObject *capi_k_point_tmp = NULL;
  int capi_k_point_intent = 0;
  PyObject *k_point_capi = Py_None;
  double *relay = NULL;
  npy_intp relay_Dims[2] = {-1, -1};
  const int relay_Rank = 2;
  PyArrayObject *capi_relay_tmp = NULL;
  int capi_relay_intent = 0;
  PyObject *relay_capi = Py_None;
  complex_double *relay_c = NULL;
  npy_intp relay_c_Dims[2] = {-1, -1};
  const int relay_c_Rank = 2;
  PyArrayObject *capi_relay_c_tmp = NULL;
  int capi_relay_c_intent = 0;
  PyObject *relay_c_capi = Py_None;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  static char *capi_kwlist[] = {"mode","version","xyz","alpha","r_vdw","beta","a","overlap","c6","damping_custom","potential_custom","unit_cell","k_point","relay","relay_c",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO|OOOOOOOOOOOO:lib.mbd.add_dipole_matrix",\
    capi_kwlist,&mode_capi,&version_capi,&xyz_capi,&alpha_capi,&r_vdw_capi,&beta_capi,&a_capi,&overlap_capi,&c6_capi,&damping_custom_capi,&potential_custom_capi,&unit_cell_capi,&k_point_capi,&relay_capi,&relay_c_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.add_dipole_matrix to C string");
  if (f2py_success) {
  /* Processing variable version */
  slen(version) = -1;
  f2py_success = string_from_pyobj(&version,&slen(version),"",version_capi,"string_from_pyobj failed in converting 2nd argument `version' of lib.mbd.add_dipole_matrix to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `xyz' of lib.mbd.add_dipole_matrix to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable beta */
  if (beta_capi != Py_None)
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.add_dipole_matrix() 3rd keyword (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
  if (a_capi != Py_None)
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.add_dipole_matrix() 4th keyword (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 9th keyword `unit_cell' of lib.mbd.add_dipole_matrix to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable k_point */
  k_point_Dims[0]=3;
  capi_k_point_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_k_point_tmp = array_from_pyobj(NPY_DOUBLE,k_point_Dims,k_point_Rank,capi_k_point_intent,k_point_capi);
  if (capi_k_point_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 10th keyword `k_point' of lib.mbd.add_dipole_matrix to C/Fortran array" );
  } else {
    k_point = (double *)(PyArray_DATA(capi_k_point_tmp));

  /* Processing variable alpha */
  alpha_Dims[0]=size(xyz, 1);
  capi_alpha_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_alpha_tmp = array_from_pyobj(NPY_DOUBLE,alpha_Dims,alpha_Rank,capi_alpha_intent,alpha_capi);
  if (capi_alpha_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `alpha' of lib.mbd.add_dipole_matrix to C/Fortran array" );
  } else {
    alpha = (double *)(PyArray_DATA(capi_alpha_tmp));

  /* Processing variable r_vdw */
  r_vdw_Dims[0]=size(xyz, 1);
  capi_r_vdw_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_r_vdw_tmp = array_from_pyobj(NPY_DOUBLE,r_vdw_Dims,r_vdw_Rank,capi_r_vdw_intent,r_vdw_capi);
  if (capi_r_vdw_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd keyword `r_vdw' of lib.mbd.add_dipole_matrix to C/Fortran array" );
  } else {
    r_vdw = (double *)(PyArray_DATA(capi_r_vdw_tmp));

  /* Processing variable overlap */
  overlap_Dims[0]=size(xyz, 1),overlap_Dims[1]=size(xyz, 1);
  capi_overlap_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_overlap_tmp = array_from_pyobj(NPY_DOUBLE,overlap_Dims,overlap_Rank,capi_overlap_intent,overlap_capi);
  if (capi_overlap_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th keyword `overlap' of lib.mbd.add_dipole_matrix to C/Fortran array" );
  } else {
    overlap = (double *)(PyArray_DATA(capi_overlap_tmp));

  /* Processing variable c6 */
  c6_Dims[0]=size(xyz, 1);
  capi_c6_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_c6_tmp = array_from_pyobj(NPY_DOUBLE,c6_Dims,c6_Rank,capi_c6_intent,c6_capi);
  if (capi_c6_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th keyword `c6' of lib.mbd.add_dipole_matrix to C/Fortran array" );
  } else {
    c6 = (double *)(PyArray_DATA(capi_c6_tmp));

  /* Processing variable damping_custom */
  damping_custom_Dims[0]=size(xyz, 1),damping_custom_Dims[1]=size(xyz, 1);
  capi_damping_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_damping_custom_tmp = array_from_pyobj(NPY_DOUBLE,damping_custom_Dims,damping_custom_Rank,capi_damping_custom_intent,damping_custom_capi);
  if (capi_damping_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 7th keyword `damping_custom' of lib.mbd.add_dipole_matrix to C/Fortran array" );
  } else {
    damping_custom = (double *)(PyArray_DATA(capi_damping_custom_tmp));

  /* Processing variable potential_custom */
  potential_custom_Dims[0]=size(xyz, 1),potential_custom_Dims[1]=size(xyz, 1),potential_custom_Dims[2]=3,potential_custom_Dims[3]=3;
  capi_potential_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_potential_custom_tmp = array_from_pyobj(NPY_DOUBLE,potential_custom_Dims,potential_custom_Rank,capi_potential_custom_intent,potential_custom_capi);
  if (capi_potential_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 8th keyword `potential_custom' of lib.mbd.add_dipole_matrix to C/Fortran array" );
  } else {
    potential_custom = (double *)(PyArray_DATA(capi_potential_custom_tmp));

  /* Processing variable relay */
  relay_Dims[0]=3*size(xyz, 1),relay_Dims[1]=3*size(xyz, 1);
  capi_relay_intent |= F2PY_INTENT_INOUT|F2PY_OPTIONAL;
  capi_relay_tmp = array_from_pyobj(NPY_DOUBLE,relay_Dims,relay_Rank,capi_relay_intent,relay_capi);
  if (capi_relay_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 11st keyword `relay' of lib.mbd.add_dipole_matrix to C/Fortran array" );
  } else {
    relay = (double *)(PyArray_DATA(capi_relay_tmp));

  /* Processing variable relay_c */
  relay_c_Dims[0]=3*size(xyz, 1),relay_c_Dims[1]=3*size(xyz, 1);
  capi_relay_c_intent |= F2PY_INTENT_INOUT|F2PY_OPTIONAL;
  capi_relay_c_tmp = array_from_pyobj(NPY_CDOUBLE,relay_c_Dims,relay_c_Rank,capi_relay_c_intent,relay_c_capi);
  if (capi_relay_c_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 12nd keyword `relay_c' of lib.mbd.add_dipole_matrix to C/Fortran array" );
  } else {
    relay_c = (complex_double *)(PyArray_DATA(capi_relay_c_tmp));

  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(mode,version,xyz,alpha,r_vdw,&beta,&a,overlap,c6,damping_custom,potential_custom,unit_cell,k_point,relay,relay_c,&f2py_xyz_d0,&f2py_xyz_d1,slen(mode),slen(version));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  if((PyObject *)capi_relay_c_tmp!=relay_c_capi) {
    Py_XDECREF(capi_relay_c_tmp); }
  }  /*if (capi_relay_c_tmp == NULL) ... else of relay_c*/
  /* End of cleaning variable relay_c */
  if((PyObject *)capi_relay_tmp!=relay_capi) {
    Py_XDECREF(capi_relay_tmp); }
  }  /*if (capi_relay_tmp == NULL) ... else of relay*/
  /* End of cleaning variable relay */
  if((PyObject *)capi_potential_custom_tmp!=potential_custom_capi) {
    Py_XDECREF(capi_potential_custom_tmp); }
  }  /*if (capi_potential_custom_tmp == NULL) ... else of potential_custom*/
  /* End of cleaning variable potential_custom */
  if((PyObject *)capi_damping_custom_tmp!=damping_custom_capi) {
    Py_XDECREF(capi_damping_custom_tmp); }
  }  /*if (capi_damping_custom_tmp == NULL) ... else of damping_custom*/
  /* End of cleaning variable damping_custom */
  if((PyObject *)capi_c6_tmp!=c6_capi) {
    Py_XDECREF(capi_c6_tmp); }
  }  /*if (capi_c6_tmp == NULL) ... else of c6*/
  /* End of cleaning variable c6 */
  if((PyObject *)capi_overlap_tmp!=overlap_capi) {
    Py_XDECREF(capi_overlap_tmp); }
  }  /*if (capi_overlap_tmp == NULL) ... else of overlap*/
  /* End of cleaning variable overlap */
  if((PyObject *)capi_r_vdw_tmp!=r_vdw_capi) {
    Py_XDECREF(capi_r_vdw_tmp); }
  }  /*if (capi_r_vdw_tmp == NULL) ... else of r_vdw*/
  /* End of cleaning variable r_vdw */
  if((PyObject *)capi_alpha_tmp!=alpha_capi) {
    Py_XDECREF(capi_alpha_tmp); }
  }  /*if (capi_alpha_tmp == NULL) ... else of alpha*/
  /* End of cleaning variable alpha */
  if((PyObject *)capi_k_point_tmp!=k_point_capi) {
    Py_XDECREF(capi_k_point_tmp); }
  }  /*if (capi_k_point_tmp == NULL) ... else of k_point*/
  /* End of cleaning variable k_point */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(version);
  }  /*if (f2py_success) of version*/
  /* End of cleaning variable version */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of add_dipole_matrix **************************/

/*************************** add_ewald_dipole_parts ***************************/
static char doc_f2py_rout_lib_mbd_add_ewald_dipole_parts[] = "\
add_ewald_dipole_parts(mode,xyz,unit_cell,alpha,[k_point,relay,relay_c])\n\nWrapper for ``add_ewald_dipole_parts``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"alpha : input float\n"
"\nOther Parameters\n----------------\n"
"k_point : input rank-1 array('d') with bounds (3)\n"
"relay : in/output rank-2 array('d') with bounds (3*size(xyz, 1),3*size(xyz, 1))\n"
"relay_c : in/output rank-2 array('D') with bounds (3*size(xyz, 1),3*size(xyz, 1))";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_add_ewald_dipole_parts(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,double*,double*,double*,double*,double*,complex_double*,int*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  double alpha = 0;
  PyObject *alpha_capi = Py_None;
  double *k_point = NULL;
  npy_intp k_point_Dims[1] = {-1};
  const int k_point_Rank = 1;
  PyArrayObject *capi_k_point_tmp = NULL;
  int capi_k_point_intent = 0;
  PyObject *k_point_capi = Py_None;
  double *relay = NULL;
  npy_intp relay_Dims[2] = {-1, -1};
  const int relay_Rank = 2;
  PyArrayObject *capi_relay_tmp = NULL;
  int capi_relay_intent = 0;
  PyObject *relay_capi = Py_None;
  complex_double *relay_c = NULL;
  npy_intp relay_c_Dims[2] = {-1, -1};
  const int relay_c_Rank = 2;
  PyArrayObject *capi_relay_c_tmp = NULL;
  int capi_relay_c_intent = 0;
  PyObject *relay_c_capi = Py_None;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  static char *capi_kwlist[] = {"mode","xyz","unit_cell","alpha","k_point","relay","relay_c",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO|OOO:lib.mbd.add_ewald_dipole_parts",\
    capi_kwlist,&mode_capi,&xyz_capi,&unit_cell_capi,&alpha_capi,&k_point_capi,&relay_capi,&relay_c_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.add_ewald_dipole_parts to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `xyz' of lib.mbd.add_ewald_dipole_parts to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `unit_cell' of lib.mbd.add_ewald_dipole_parts to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable alpha */
    f2py_success = double_from_pyobj(&alpha,alpha_capi,"lib.mbd.add_ewald_dipole_parts() 4th argument (alpha) can't be converted to double");
  if (f2py_success) {
  /* Processing variable k_point */
  k_point_Dims[0]=3;
  capi_k_point_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_k_point_tmp = array_from_pyobj(NPY_DOUBLE,k_point_Dims,k_point_Rank,capi_k_point_intent,k_point_capi);
  if (capi_k_point_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `k_point' of lib.mbd.add_ewald_dipole_parts to C/Fortran array" );
  } else {
    k_point = (double *)(PyArray_DATA(capi_k_point_tmp));

  /* Processing variable relay */
  relay_Dims[0]=3*size(xyz, 1),relay_Dims[1]=3*size(xyz, 1);
  capi_relay_intent |= F2PY_INTENT_INOUT|F2PY_OPTIONAL;
  capi_relay_tmp = array_from_pyobj(NPY_DOUBLE,relay_Dims,relay_Rank,capi_relay_intent,relay_capi);
  if (capi_relay_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd keyword `relay' of lib.mbd.add_ewald_dipole_parts to C/Fortran array" );
  } else {
    relay = (double *)(PyArray_DATA(capi_relay_tmp));

  /* Processing variable relay_c */
  relay_c_Dims[0]=3*size(xyz, 1),relay_c_Dims[1]=3*size(xyz, 1);
  capi_relay_c_intent |= F2PY_INTENT_INOUT|F2PY_OPTIONAL;
  capi_relay_c_tmp = array_from_pyobj(NPY_CDOUBLE,relay_c_Dims,relay_c_Rank,capi_relay_c_intent,relay_c_capi);
  if (capi_relay_c_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd keyword `relay_c' of lib.mbd.add_ewald_dipole_parts to C/Fortran array" );
  } else {
    relay_c = (complex_double *)(PyArray_DATA(capi_relay_c_tmp));

  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(mode,xyz,unit_cell,&alpha,k_point,relay,relay_c,&f2py_xyz_d0,&f2py_xyz_d1,slen(mode));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  if((PyObject *)capi_relay_c_tmp!=relay_c_capi) {
    Py_XDECREF(capi_relay_c_tmp); }
  }  /*if (capi_relay_c_tmp == NULL) ... else of relay_c*/
  /* End of cleaning variable relay_c */
  if((PyObject *)capi_relay_tmp!=relay_capi) {
    Py_XDECREF(capi_relay_tmp); }
  }  /*if (capi_relay_tmp == NULL) ... else of relay*/
  /* End of cleaning variable relay */
  if((PyObject *)capi_k_point_tmp!=k_point_capi) {
    Py_XDECREF(capi_k_point_tmp); }
  }  /*if (capi_k_point_tmp == NULL) ... else of k_point*/
  /* End of cleaning variable k_point */
  } /*if (f2py_success) of alpha*/
  /* End of cleaning variable alpha */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*********************** end of add_ewald_dipole_parts ***********************/

/*********************************** do_scs ***********************************/
static char doc_f2py_rout_lib_mbd_do_scs[] = "\
alpha_full = do_scs(mode,version,xyz,alpha,[r_vdw,beta,a,lam,unit_cell])\n\nWrapper for ``do_scs``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"version : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"alpha : input rank-1 array('d') with bounds (f2py_alpha_d0)\n"
"\nOther Parameters\n----------------\n"
"r_vdw : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"beta : input float\n"
"a : input float\n"
"lam : input float\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"\nReturns\n-------\n"
"alpha_full : rank-2 array('d') with bounds (3*size(xyz, 1),3*size(xyz, 1)) and do_scs storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_do_scs(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,string,double*,double*,double*,double*,double*,double*,double*,int*,int*,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *do_scs = NULL;
  npy_intp do_scs_Dims[2] = {-1, -1};
  const int do_scs_Rank = 2;
  PyArrayObject *capi_do_scs_tmp = NULL;
  int capi_do_scs_intent = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  string version = NULL;
  int slen(version);
  PyObject *version_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *alpha = NULL;
  npy_intp alpha_Dims[1] = {-1};
  const int alpha_Rank = 1;
  PyArrayObject *capi_alpha_tmp = NULL;
  int capi_alpha_intent = 0;
  PyObject *alpha_capi = Py_None;
  double *r_vdw = NULL;
  npy_intp r_vdw_Dims[1] = {-1};
  const int r_vdw_Rank = 1;
  PyArrayObject *capi_r_vdw_tmp = NULL;
  int capi_r_vdw_intent = 0;
  PyObject *r_vdw_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  double lam = 0;
  PyObject *lam_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  int f2py_alpha_d0 = 0;
  static char *capi_kwlist[] = {"mode","version","xyz","alpha","r_vdw","beta","a","lam","unit_cell",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO|OOOOO:lib.mbd.do_scs",\
    capi_kwlist,&mode_capi,&version_capi,&xyz_capi,&alpha_capi,&r_vdw_capi,&beta_capi,&a_capi,&lam_capi,&unit_cell_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.do_scs to C string");
  if (f2py_success) {
  /* Processing variable version */
  slen(version) = -1;
  f2py_success = string_from_pyobj(&version,&slen(version),"",version_capi,"string_from_pyobj failed in converting 2nd argument `version' of lib.mbd.do_scs to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `xyz' of lib.mbd.do_scs to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable alpha */
  ;
  capi_alpha_intent |= F2PY_INTENT_IN;
  capi_alpha_tmp = array_from_pyobj(NPY_DOUBLE,alpha_Dims,alpha_Rank,capi_alpha_intent,alpha_capi);
  if (capi_alpha_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `alpha' of lib.mbd.do_scs to C/Fortran array" );
  } else {
    alpha = (double *)(PyArray_DATA(capi_alpha_tmp));

  /* Processing variable beta */
  if (beta_capi != Py_None)
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.do_scs() 2nd keyword (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
  if (a_capi != Py_None)
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.do_scs() 3rd keyword (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th keyword `unit_cell' of lib.mbd.do_scs to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable lam */
  if (lam_capi != Py_None)
    f2py_success = double_from_pyobj(&lam,lam_capi,"lib.mbd.do_scs() 4th keyword (lam) can't be converted to double");
  if (f2py_success) {
  /* Processing variable r_vdw */
  r_vdw_Dims[0]=size(xyz, 1);
  capi_r_vdw_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_r_vdw_tmp = array_from_pyobj(NPY_DOUBLE,r_vdw_Dims,r_vdw_Rank,capi_r_vdw_intent,r_vdw_capi);
  if (capi_r_vdw_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `r_vdw' of lib.mbd.do_scs to C/Fortran array" );
  } else {
    r_vdw = (double *)(PyArray_DATA(capi_r_vdw_tmp));

  /* Processing variable do_scs */
  do_scs_Dims[0]=3*size(xyz, 1),do_scs_Dims[1]=3*size(xyz, 1);
  capi_do_scs_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_do_scs_tmp = array_from_pyobj(NPY_DOUBLE,do_scs_Dims,do_scs_Rank,capi_do_scs_intent,Py_None);
  if (capi_do_scs_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `do_scs' of lib.mbd.do_scs to C/Fortran array" );
  } else {
    do_scs = (double *)(PyArray_DATA(capi_do_scs_tmp));

  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
  /* Processing variable f2py_alpha_d0 */
  f2py_alpha_d0 = shape(alpha, 0);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(do_scs,mode,version,xyz,alpha,r_vdw,&beta,&a,&lam,unit_cell,&f2py_xyz_d0,&f2py_xyz_d1,&f2py_alpha_d0,slen(mode),slen(version));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_do_scs_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_alpha_d0 */
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  }  /*if (capi_do_scs_tmp == NULL) ... else of do_scs*/
  /* End of cleaning variable do_scs */
  if((PyObject *)capi_r_vdw_tmp!=r_vdw_capi) {
    Py_XDECREF(capi_r_vdw_tmp); }
  }  /*if (capi_r_vdw_tmp == NULL) ... else of r_vdw*/
  /* End of cleaning variable r_vdw */
  } /*if (f2py_success) of lam*/
  /* End of cleaning variable lam */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  if((PyObject *)capi_alpha_tmp!=alpha_capi) {
    Py_XDECREF(capi_alpha_tmp); }
  }  /*if (capi_alpha_tmp == NULL) ... else of alpha*/
  /* End of cleaning variable alpha */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(version);
  }  /*if (f2py_success) of version*/
  /* End of cleaning variable version */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of do_scs *******************************/

/******************************* do_scs_k_point *******************************/
static char doc_f2py_rout_lib_mbd_do_scs_k_point[] = "\
alpha_full = do_scs_k_point(mode,version,xyz,alpha,k_point,[r_vdw,beta,a,lam,unit_cell])\n\nWrapper for ``do_scs_k_point``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"version : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"alpha : input rank-1 array('d') with bounds (f2py_alpha_d0)\n"
"k_point : input rank-1 array('d') with bounds (3)\n"
"\nOther Parameters\n----------------\n"
"r_vdw : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"beta : input float\n"
"a : input float\n"
"lam : input float\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"\nReturns\n-------\n"
"alpha_full : rank-2 array('D') with bounds (3*size(xyz, 1),3*size(xyz, 1)) and do_scs_k_point storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_do_scs_k_point(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(complex_double*,string,string,double*,double*,double*,double*,double*,double*,double*,double*,int*,int*,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  complex_double *do_scs_k_point = NULL;
  npy_intp do_scs_k_point_Dims[2] = {-1, -1};
  const int do_scs_k_point_Rank = 2;
  PyArrayObject *capi_do_scs_k_point_tmp = NULL;
  int capi_do_scs_k_point_intent = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  string version = NULL;
  int slen(version);
  PyObject *version_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *alpha = NULL;
  npy_intp alpha_Dims[1] = {-1};
  const int alpha_Rank = 1;
  PyArrayObject *capi_alpha_tmp = NULL;
  int capi_alpha_intent = 0;
  PyObject *alpha_capi = Py_None;
  double *k_point = NULL;
  npy_intp k_point_Dims[1] = {-1};
  const int k_point_Rank = 1;
  PyArrayObject *capi_k_point_tmp = NULL;
  int capi_k_point_intent = 0;
  PyObject *k_point_capi = Py_None;
  double *r_vdw = NULL;
  npy_intp r_vdw_Dims[1] = {-1};
  const int r_vdw_Rank = 1;
  PyArrayObject *capi_r_vdw_tmp = NULL;
  int capi_r_vdw_intent = 0;
  PyObject *r_vdw_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  double lam = 0;
  PyObject *lam_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  int f2py_alpha_d0 = 0;
  static char *capi_kwlist[] = {"mode","version","xyz","alpha","k_point","r_vdw","beta","a","lam","unit_cell",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO|OOOOO:lib.mbd.do_scs_k_point",\
    capi_kwlist,&mode_capi,&version_capi,&xyz_capi,&alpha_capi,&k_point_capi,&r_vdw_capi,&beta_capi,&a_capi,&lam_capi,&unit_cell_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.do_scs_k_point to C string");
  if (f2py_success) {
  /* Processing variable version */
  slen(version) = -1;
  f2py_success = string_from_pyobj(&version,&slen(version),"",version_capi,"string_from_pyobj failed in converting 2nd argument `version' of lib.mbd.do_scs_k_point to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `xyz' of lib.mbd.do_scs_k_point to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable alpha */
  ;
  capi_alpha_intent |= F2PY_INTENT_IN;
  capi_alpha_tmp = array_from_pyobj(NPY_DOUBLE,alpha_Dims,alpha_Rank,capi_alpha_intent,alpha_capi);
  if (capi_alpha_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `alpha' of lib.mbd.do_scs_k_point to C/Fortran array" );
  } else {
    alpha = (double *)(PyArray_DATA(capi_alpha_tmp));

  /* Processing variable k_point */
  k_point_Dims[0]=3;
  capi_k_point_intent |= F2PY_INTENT_IN;
  capi_k_point_tmp = array_from_pyobj(NPY_DOUBLE,k_point_Dims,k_point_Rank,capi_k_point_intent,k_point_capi);
  if (capi_k_point_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `k_point' of lib.mbd.do_scs_k_point to C/Fortran array" );
  } else {
    k_point = (double *)(PyArray_DATA(capi_k_point_tmp));

  /* Processing variable beta */
  if (beta_capi != Py_None)
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.do_scs_k_point() 2nd keyword (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
  if (a_capi != Py_None)
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.do_scs_k_point() 3rd keyword (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th keyword `unit_cell' of lib.mbd.do_scs_k_point to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable lam */
  if (lam_capi != Py_None)
    f2py_success = double_from_pyobj(&lam,lam_capi,"lib.mbd.do_scs_k_point() 4th keyword (lam) can't be converted to double");
  if (f2py_success) {
  /* Processing variable r_vdw */
  r_vdw_Dims[0]=size(xyz, 1);
  capi_r_vdw_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_r_vdw_tmp = array_from_pyobj(NPY_DOUBLE,r_vdw_Dims,r_vdw_Rank,capi_r_vdw_intent,r_vdw_capi);
  if (capi_r_vdw_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `r_vdw' of lib.mbd.do_scs_k_point to C/Fortran array" );
  } else {
    r_vdw = (double *)(PyArray_DATA(capi_r_vdw_tmp));

  /* Processing variable do_scs_k_point */
  do_scs_k_point_Dims[0]=3*size(xyz, 1),do_scs_k_point_Dims[1]=3*size(xyz, 1);
  capi_do_scs_k_point_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_do_scs_k_point_tmp = array_from_pyobj(NPY_CDOUBLE,do_scs_k_point_Dims,do_scs_k_point_Rank,capi_do_scs_k_point_intent,Py_None);
  if (capi_do_scs_k_point_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `do_scs_k_point' of lib.mbd.do_scs_k_point to C/Fortran array" );
  } else {
    do_scs_k_point = (complex_double *)(PyArray_DATA(capi_do_scs_k_point_tmp));

  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
  /* Processing variable f2py_alpha_d0 */
  f2py_alpha_d0 = shape(alpha, 0);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(do_scs_k_point,mode,version,xyz,alpha,k_point,r_vdw,&beta,&a,&lam,unit_cell,&f2py_xyz_d0,&f2py_xyz_d1,&f2py_alpha_d0,slen(mode),slen(version));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_do_scs_k_point_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_alpha_d0 */
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  }  /*if (capi_do_scs_k_point_tmp == NULL) ... else of do_scs_k_point*/
  /* End of cleaning variable do_scs_k_point */
  if((PyObject *)capi_r_vdw_tmp!=r_vdw_capi) {
    Py_XDECREF(capi_r_vdw_tmp); }
  }  /*if (capi_r_vdw_tmp == NULL) ... else of r_vdw*/
  /* End of cleaning variable r_vdw */
  } /*if (f2py_success) of lam*/
  /* End of cleaning variable lam */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  if((PyObject *)capi_k_point_tmp!=k_point_capi) {
    Py_XDECREF(capi_k_point_tmp); }
  }  /*if (capi_k_point_tmp == NULL) ... else of k_point*/
  /* End of cleaning variable k_point */
  if((PyObject *)capi_alpha_tmp!=alpha_capi) {
    Py_XDECREF(capi_alpha_tmp); }
  }  /*if (capi_alpha_tmp == NULL) ... else of alpha*/
  /* End of cleaning variable alpha */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(version);
  }  /*if (f2py_success) of version*/
  /* End of cleaning variable version */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of do_scs_k_point ***************************/

/********************************* init_grid *********************************/
static char doc_f2py_rout_lib_mbd_init_grid[] = "\
init_grid(n)\n\nWrapper for ``init_grid``.\
\n\nParameters\n----------\n"
"n : input int";
/*  */
static PyObject *f2py_rout_lib_mbd_init_grid(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int n = 0;
  PyObject *n_capi = Py_None;
  static char *capi_kwlist[] = {"n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.init_grid",\
    capi_kwlist,&n_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable n */
    f2py_success = int_from_pyobj(&n,n_capi,"lib.mbd.init_grid() 1st argument (n) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&n);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of init_grid ******************************/

/******************************* init_eqi_grid *******************************/
static char doc_f2py_rout_lib_mbd_init_eqi_grid[] = "\
init_eqi_grid(n,a,b)\n\nWrapper for ``init_eqi_grid``.\
\n\nParameters\n----------\n"
"n : input int\n"
"a : input float\n"
"b : input float";
/*  */
static PyObject *f2py_rout_lib_mbd_init_eqi_grid(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int n = 0;
  PyObject *n_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  double b = 0;
  PyObject *b_capi = Py_None;
  static char *capi_kwlist[] = {"n","a","b",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd.init_eqi_grid",\
    capi_kwlist,&n_capi,&a_capi,&b_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable n */
    f2py_success = int_from_pyobj(&n,n_capi,"lib.mbd.init_eqi_grid() 1st argument (n) can't be converted to int");
  if (f2py_success) {
  /* Processing variable a */
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.init_eqi_grid() 2nd argument (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable b */
    f2py_success = double_from_pyobj(&b,b_capi,"lib.mbd.init_eqi_grid() 3rd argument (b) can't be converted to double");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&n,&a,&b);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of b*/
  /* End of cleaning variable b */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of init_eqi_grid ****************************/

/**************************** test_frequency_grid ****************************/
static char doc_f2py_rout_lib_mbd_test_frequency_grid[] = "\
error = test_frequency_grid()\n\nWrapper for ``test_frequency_grid``.\
\n\nReturns\n-------\n"
"error : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_test_frequency_grid(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float test_frequency_grid = 0;
  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":lib.mbd.test_frequency_grid",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
  /* Processing variable test_frequency_grid */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&test_frequency_grid);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("f",test_frequency_grid);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable test_frequency_grid */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of test_frequency_grid *************************/

/******************************** destroy_grid ********************************/
static char doc_f2py_rout_lib_mbd_destroy_grid[] = "\
destroy_grid()\n\nWrapper for ``destroy_grid``.\
\n";
/*  */
static PyObject *f2py_rout_lib_mbd_destroy_grid(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":lib.mbd.destroy_grid",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of destroy_grid ****************************/

/********************************** run_scs **********************************/
static char doc_f2py_rout_lib_mbd_run_scs[] = "\
alpha_scs = run_scs(mode,version,xyz,alpha,[r_vdw,beta,a,unit_cell])\n\nWrapper for ``run_scs``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"version : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"alpha : input rank-2 array('d') with bounds (f2py_alpha_d0,f2py_alpha_d1)\n"
"\nOther Parameters\n----------------\n"
"r_vdw : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"beta : input float\n"
"a : input float\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"\nReturns\n-------\n"
"alpha_scs : rank-2 array('d') with bounds (size(alpha, 1),size(alpha, 2)) and run_scs storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_run_scs(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,string,double*,double*,double*,double*,double*,double*,int*,int*,int*,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *run_scs = NULL;
  npy_intp run_scs_Dims[2] = {-1, -1};
  const int run_scs_Rank = 2;
  PyArrayObject *capi_run_scs_tmp = NULL;
  int capi_run_scs_intent = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  string version = NULL;
  int slen(version);
  PyObject *version_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *alpha = NULL;
  npy_intp alpha_Dims[2] = {-1, -1};
  const int alpha_Rank = 2;
  PyArrayObject *capi_alpha_tmp = NULL;
  int capi_alpha_intent = 0;
  PyObject *alpha_capi = Py_None;
  double *r_vdw = NULL;
  npy_intp r_vdw_Dims[1] = {-1};
  const int r_vdw_Rank = 1;
  PyArrayObject *capi_r_vdw_tmp = NULL;
  int capi_r_vdw_intent = 0;
  PyObject *r_vdw_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  int f2py_alpha_d0 = 0;
  int f2py_alpha_d1 = 0;
  static char *capi_kwlist[] = {"mode","version","xyz","alpha","r_vdw","beta","a","unit_cell",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO|OOOO:lib.mbd.run_scs",\
    capi_kwlist,&mode_capi,&version_capi,&xyz_capi,&alpha_capi,&r_vdw_capi,&beta_capi,&a_capi,&unit_cell_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.run_scs to C string");
  if (f2py_success) {
  /* Processing variable version */
  slen(version) = -1;
  f2py_success = string_from_pyobj(&version,&slen(version),"",version_capi,"string_from_pyobj failed in converting 2nd argument `version' of lib.mbd.run_scs to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `xyz' of lib.mbd.run_scs to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable alpha */
  ;
  capi_alpha_intent |= F2PY_INTENT_IN;
  capi_alpha_tmp = array_from_pyobj(NPY_DOUBLE,alpha_Dims,alpha_Rank,capi_alpha_intent,alpha_capi);
  if (capi_alpha_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `alpha' of lib.mbd.run_scs to C/Fortran array" );
  } else {
    alpha = (double *)(PyArray_DATA(capi_alpha_tmp));

  /* Processing variable beta */
  if (beta_capi != Py_None)
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.run_scs() 2nd keyword (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
  if (a_capi != Py_None)
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.run_scs() 3rd keyword (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th keyword `unit_cell' of lib.mbd.run_scs to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable r_vdw */
  r_vdw_Dims[0]=size(xyz, 1);
  capi_r_vdw_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_r_vdw_tmp = array_from_pyobj(NPY_DOUBLE,r_vdw_Dims,r_vdw_Rank,capi_r_vdw_intent,r_vdw_capi);
  if (capi_r_vdw_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `r_vdw' of lib.mbd.run_scs to C/Fortran array" );
  } else {
    r_vdw = (double *)(PyArray_DATA(capi_r_vdw_tmp));

  /* Processing variable run_scs */
  run_scs_Dims[0]=size(alpha, 1),run_scs_Dims[1]=size(alpha, 2);
  capi_run_scs_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_run_scs_tmp = array_from_pyobj(NPY_DOUBLE,run_scs_Dims,run_scs_Rank,capi_run_scs_intent,Py_None);
  if (capi_run_scs_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `run_scs' of lib.mbd.run_scs to C/Fortran array" );
  } else {
    run_scs = (double *)(PyArray_DATA(capi_run_scs_tmp));

  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
  /* Processing variable f2py_alpha_d0 */
  f2py_alpha_d0 = shape(alpha, 0);
  /* Processing variable f2py_alpha_d1 */
  f2py_alpha_d1 = shape(alpha, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(run_scs,mode,version,xyz,alpha,r_vdw,&beta,&a,unit_cell,&f2py_xyz_d0,&f2py_xyz_d1,&f2py_alpha_d0,&f2py_alpha_d1,slen(mode),slen(version));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_run_scs_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_alpha_d1 */
  /* End of cleaning variable f2py_alpha_d0 */
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  }  /*if (capi_run_scs_tmp == NULL) ... else of run_scs*/
  /* End of cleaning variable run_scs */
  if((PyObject *)capi_r_vdw_tmp!=r_vdw_capi) {
    Py_XDECREF(capi_r_vdw_tmp); }
  }  /*if (capi_r_vdw_tmp == NULL) ... else of r_vdw*/
  /* End of cleaning variable r_vdw */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  if((PyObject *)capi_alpha_tmp!=alpha_capi) {
    Py_XDECREF(capi_alpha_tmp); }
  }  /*if (capi_alpha_tmp == NULL) ... else of alpha*/
  /* End of cleaning variable alpha */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(version);
  }  /*if (f2py_success) of version*/
  /* End of cleaning variable version */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of run_scs *******************************/

/******************************* get_mbd_energy *******************************/
static char doc_f2py_rout_lib_mbd_get_mbd_energy[] = "\
ene = get_mbd_energy(mode,version,xyz,alpha_0,omega,[supercell,k_grid,unit_cell,r_vdw,beta,a,overlap,c6,damping_custom,potential_custom])\n\nWrapper for ``get_mbd_energy``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"version : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"alpha_0 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"omega : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"\nOther Parameters\n----------------\n"
"supercell : input rank-1 array('i') with bounds (3)\n"
"k_grid : input rank-2 array('d') with bounds (f2py_k_grid_d0,f2py_k_grid_d1)\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"r_vdw : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"beta : input float\n"
"a : input float\n"
"overlap : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"c6 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"damping_custom : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"potential_custom : input rank-4 array('d') with bounds (size(xyz, 1),size(xyz, 1),3,3)\n"
"\nReturns\n-------\n"
"ene : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_mbd_energy(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,string,double*,double*,double*,int*,double*,double*,double*,double*,double*,double*,double*,double*,double*,int*,int*,int*,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double get_mbd_energy = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  string version = NULL;
  int slen(version);
  PyObject *version_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *alpha_0 = NULL;
  npy_intp alpha_0_Dims[1] = {-1};
  const int alpha_0_Rank = 1;
  PyArrayObject *capi_alpha_0_tmp = NULL;
  int capi_alpha_0_intent = 0;
  PyObject *alpha_0_capi = Py_None;
  double *omega = NULL;
  npy_intp omega_Dims[1] = {-1};
  const int omega_Rank = 1;
  PyArrayObject *capi_omega_tmp = NULL;
  int capi_omega_intent = 0;
  PyObject *omega_capi = Py_None;
  int *supercell = NULL;
  npy_intp supercell_Dims[1] = {-1};
  const int supercell_Rank = 1;
  PyArrayObject *capi_supercell_tmp = NULL;
  int capi_supercell_intent = 0;
  PyObject *supercell_capi = Py_None;
  double *k_grid = NULL;
  npy_intp k_grid_Dims[2] = {-1, -1};
  const int k_grid_Rank = 2;
  PyArrayObject *capi_k_grid_tmp = NULL;
  int capi_k_grid_intent = 0;
  PyObject *k_grid_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  double *r_vdw = NULL;
  npy_intp r_vdw_Dims[1] = {-1};
  const int r_vdw_Rank = 1;
  PyArrayObject *capi_r_vdw_tmp = NULL;
  int capi_r_vdw_intent = 0;
  PyObject *r_vdw_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  double *overlap = NULL;
  npy_intp overlap_Dims[2] = {-1, -1};
  const int overlap_Rank = 2;
  PyArrayObject *capi_overlap_tmp = NULL;
  int capi_overlap_intent = 0;
  PyObject *overlap_capi = Py_None;
  double *c6 = NULL;
  npy_intp c6_Dims[1] = {-1};
  const int c6_Rank = 1;
  PyArrayObject *capi_c6_tmp = NULL;
  int capi_c6_intent = 0;
  PyObject *c6_capi = Py_None;
  double *damping_custom = NULL;
  npy_intp damping_custom_Dims[2] = {-1, -1};
  const int damping_custom_Rank = 2;
  PyArrayObject *capi_damping_custom_tmp = NULL;
  int capi_damping_custom_intent = 0;
  PyObject *damping_custom_capi = Py_None;
  double *potential_custom = NULL;
  npy_intp potential_custom_Dims[4] = {-1, -1, -1, -1};
  const int potential_custom_Rank = 4;
  PyArrayObject *capi_potential_custom_tmp = NULL;
  int capi_potential_custom_intent = 0;
  PyObject *potential_custom_capi = Py_None;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  int f2py_k_grid_d0 = 0;
  int f2py_k_grid_d1 = 0;
  static char *capi_kwlist[] = {"mode","version","xyz","alpha_0","omega","supercell","k_grid","unit_cell","r_vdw","beta","a","overlap","c6","damping_custom","potential_custom",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO|OOOOOOOOOO:lib.mbd.get_mbd_energy",\
    capi_kwlist,&mode_capi,&version_capi,&xyz_capi,&alpha_0_capi,&omega_capi,&supercell_capi,&k_grid_capi,&unit_cell_capi,&r_vdw_capi,&beta_capi,&a_capi,&overlap_capi,&c6_capi,&damping_custom_capi,&potential_custom_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.get_mbd_energy to C string");
  if (f2py_success) {
  /* Processing variable version */
  slen(version) = -1;
  f2py_success = string_from_pyobj(&version,&slen(version),"",version_capi,"string_from_pyobj failed in converting 2nd argument `version' of lib.mbd.get_mbd_energy to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `xyz' of lib.mbd.get_mbd_energy to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable k_grid */
  ;
  capi_k_grid_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_k_grid_tmp = array_from_pyobj(NPY_DOUBLE,k_grid_Dims,k_grid_Rank,capi_k_grid_intent,k_grid_capi);
  if (capi_k_grid_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd keyword `k_grid' of lib.mbd.get_mbd_energy to C/Fortran array" );
  } else {
    k_grid = (double *)(PyArray_DATA(capi_k_grid_tmp));

  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd keyword `unit_cell' of lib.mbd.get_mbd_energy to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable supercell */
  supercell_Dims[0]=3;
  capi_supercell_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_supercell_tmp = array_from_pyobj(NPY_INT,supercell_Dims,supercell_Rank,capi_supercell_intent,supercell_capi);
  if (capi_supercell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `supercell' of lib.mbd.get_mbd_energy to C/Fortran array" );
  } else {
    supercell = (int *)(PyArray_DATA(capi_supercell_tmp));

  /* Processing variable beta */
  if (beta_capi != Py_None)
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.get_mbd_energy() 5th keyword (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
  if (a_capi != Py_None)
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.get_mbd_energy() 6th keyword (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable alpha_0 */
  alpha_0_Dims[0]=size(xyz, 1);
  capi_alpha_0_intent |= F2PY_INTENT_IN;
  capi_alpha_0_tmp = array_from_pyobj(NPY_DOUBLE,alpha_0_Dims,alpha_0_Rank,capi_alpha_0_intent,alpha_0_capi);
  if (capi_alpha_0_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `alpha_0' of lib.mbd.get_mbd_energy to C/Fortran array" );
  } else {
    alpha_0 = (double *)(PyArray_DATA(capi_alpha_0_tmp));

  /* Processing variable omega */
  omega_Dims[0]=size(xyz, 1);
  capi_omega_intent |= F2PY_INTENT_IN;
  capi_omega_tmp = array_from_pyobj(NPY_DOUBLE,omega_Dims,omega_Rank,capi_omega_intent,omega_capi);
  if (capi_omega_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `omega' of lib.mbd.get_mbd_energy to C/Fortran array" );
  } else {
    omega = (double *)(PyArray_DATA(capi_omega_tmp));

  /* Processing variable r_vdw */
  r_vdw_Dims[0]=size(xyz, 1);
  capi_r_vdw_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_r_vdw_tmp = array_from_pyobj(NPY_DOUBLE,r_vdw_Dims,r_vdw_Rank,capi_r_vdw_intent,r_vdw_capi);
  if (capi_r_vdw_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th keyword `r_vdw' of lib.mbd.get_mbd_energy to C/Fortran array" );
  } else {
    r_vdw = (double *)(PyArray_DATA(capi_r_vdw_tmp));

  /* Processing variable overlap */
  overlap_Dims[0]=size(xyz, 1),overlap_Dims[1]=size(xyz, 1);
  capi_overlap_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_overlap_tmp = array_from_pyobj(NPY_DOUBLE,overlap_Dims,overlap_Rank,capi_overlap_intent,overlap_capi);
  if (capi_overlap_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 7th keyword `overlap' of lib.mbd.get_mbd_energy to C/Fortran array" );
  } else {
    overlap = (double *)(PyArray_DATA(capi_overlap_tmp));

  /* Processing variable c6 */
  c6_Dims[0]=size(xyz, 1);
  capi_c6_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_c6_tmp = array_from_pyobj(NPY_DOUBLE,c6_Dims,c6_Rank,capi_c6_intent,c6_capi);
  if (capi_c6_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 8th keyword `c6' of lib.mbd.get_mbd_energy to C/Fortran array" );
  } else {
    c6 = (double *)(PyArray_DATA(capi_c6_tmp));

  /* Processing variable damping_custom */
  damping_custom_Dims[0]=size(xyz, 1),damping_custom_Dims[1]=size(xyz, 1);
  capi_damping_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_damping_custom_tmp = array_from_pyobj(NPY_DOUBLE,damping_custom_Dims,damping_custom_Rank,capi_damping_custom_intent,damping_custom_capi);
  if (capi_damping_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 9th keyword `damping_custom' of lib.mbd.get_mbd_energy to C/Fortran array" );
  } else {
    damping_custom = (double *)(PyArray_DATA(capi_damping_custom_tmp));

  /* Processing variable potential_custom */
  potential_custom_Dims[0]=size(xyz, 1),potential_custom_Dims[1]=size(xyz, 1),potential_custom_Dims[2]=3,potential_custom_Dims[3]=3;
  capi_potential_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_potential_custom_tmp = array_from_pyobj(NPY_DOUBLE,potential_custom_Dims,potential_custom_Rank,capi_potential_custom_intent,potential_custom_capi);
  if (capi_potential_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 10th keyword `potential_custom' of lib.mbd.get_mbd_energy to C/Fortran array" );
  } else {
    potential_custom = (double *)(PyArray_DATA(capi_potential_custom_tmp));

  /* Processing variable get_mbd_energy */
  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
  /* Processing variable f2py_k_grid_d0 */
  f2py_k_grid_d0 = shape(k_grid, 0);
  /* Processing variable f2py_k_grid_d1 */
  f2py_k_grid_d1 = shape(k_grid, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_mbd_energy,mode,version,xyz,alpha_0,omega,supercell,k_grid,unit_cell,r_vdw,&beta,&a,overlap,c6,damping_custom,potential_custom,&f2py_xyz_d0,&f2py_xyz_d1,&f2py_k_grid_d0,&f2py_k_grid_d1,slen(mode),slen(version));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",get_mbd_energy);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_k_grid_d1 */
  /* End of cleaning variable f2py_k_grid_d0 */
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  /* End of cleaning variable get_mbd_energy */
  if((PyObject *)capi_potential_custom_tmp!=potential_custom_capi) {
    Py_XDECREF(capi_potential_custom_tmp); }
  }  /*if (capi_potential_custom_tmp == NULL) ... else of potential_custom*/
  /* End of cleaning variable potential_custom */
  if((PyObject *)capi_damping_custom_tmp!=damping_custom_capi) {
    Py_XDECREF(capi_damping_custom_tmp); }
  }  /*if (capi_damping_custom_tmp == NULL) ... else of damping_custom*/
  /* End of cleaning variable damping_custom */
  if((PyObject *)capi_c6_tmp!=c6_capi) {
    Py_XDECREF(capi_c6_tmp); }
  }  /*if (capi_c6_tmp == NULL) ... else of c6*/
  /* End of cleaning variable c6 */
  if((PyObject *)capi_overlap_tmp!=overlap_capi) {
    Py_XDECREF(capi_overlap_tmp); }
  }  /*if (capi_overlap_tmp == NULL) ... else of overlap*/
  /* End of cleaning variable overlap */
  if((PyObject *)capi_r_vdw_tmp!=r_vdw_capi) {
    Py_XDECREF(capi_r_vdw_tmp); }
  }  /*if (capi_r_vdw_tmp == NULL) ... else of r_vdw*/
  /* End of cleaning variable r_vdw */
  if((PyObject *)capi_omega_tmp!=omega_capi) {
    Py_XDECREF(capi_omega_tmp); }
  }  /*if (capi_omega_tmp == NULL) ... else of omega*/
  /* End of cleaning variable omega */
  if((PyObject *)capi_alpha_0_tmp!=alpha_0_capi) {
    Py_XDECREF(capi_alpha_0_tmp); }
  }  /*if (capi_alpha_0_tmp == NULL) ... else of alpha_0*/
  /* End of cleaning variable alpha_0 */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  if((PyObject *)capi_supercell_tmp!=supercell_capi) {
    Py_XDECREF(capi_supercell_tmp); }
  }  /*if (capi_supercell_tmp == NULL) ... else of supercell*/
  /* End of cleaning variable supercell */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  if((PyObject *)capi_k_grid_tmp!=k_grid_capi) {
    Py_XDECREF(capi_k_grid_tmp); }
  }  /*if (capi_k_grid_tmp == NULL) ... else of k_grid*/
  /* End of cleaning variable k_grid */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(version);
  }  /*if (f2py_success) of version*/
  /* End of cleaning variable version */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of get_mbd_energy ***************************/

/*************************** get_single_mbd_energy ***************************/
static char doc_f2py_rout_lib_mbd_get_single_mbd_energy[] = "\
ene,mode_enes,modes = get_single_mbd_energy(mode,version,xyz,alpha_0,omega,[r_vdw,beta,a,overlap,c6,damping_custom,potential_custom,unit_cell])\n\nWrapper for ``get_single_mbd_energy``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"version : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"alpha_0 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"omega : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"\nOther Parameters\n----------------\n"
"r_vdw : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"beta : input float\n"
"a : input float\n"
"overlap : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"c6 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"damping_custom : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"potential_custom : input rank-4 array('d') with bounds (size(xyz, 1),size(xyz, 1),3,3)\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"\nReturns\n-------\n"
"ene : float\n"
"mode_enes : rank-1 array('d') with bounds (3*size(xyz, 1))\n"
"modes : rank-2 array('d') with bounds (3*size(xyz, 1),3*size(xyz, 1))";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_single_mbd_energy(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,string,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,int*,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double get_single_mbd_energy = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  string version = NULL;
  int slen(version);
  PyObject *version_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *alpha_0 = NULL;
  npy_intp alpha_0_Dims[1] = {-1};
  const int alpha_0_Rank = 1;
  PyArrayObject *capi_alpha_0_tmp = NULL;
  int capi_alpha_0_intent = 0;
  PyObject *alpha_0_capi = Py_None;
  double *omega = NULL;
  npy_intp omega_Dims[1] = {-1};
  const int omega_Rank = 1;
  PyArrayObject *capi_omega_tmp = NULL;
  int capi_omega_intent = 0;
  PyObject *omega_capi = Py_None;
  double *r_vdw = NULL;
  npy_intp r_vdw_Dims[1] = {-1};
  const int r_vdw_Rank = 1;
  PyArrayObject *capi_r_vdw_tmp = NULL;
  int capi_r_vdw_intent = 0;
  PyObject *r_vdw_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  double *overlap = NULL;
  npy_intp overlap_Dims[2] = {-1, -1};
  const int overlap_Rank = 2;
  PyArrayObject *capi_overlap_tmp = NULL;
  int capi_overlap_intent = 0;
  PyObject *overlap_capi = Py_None;
  double *c6 = NULL;
  npy_intp c6_Dims[1] = {-1};
  const int c6_Rank = 1;
  PyArrayObject *capi_c6_tmp = NULL;
  int capi_c6_intent = 0;
  PyObject *c6_capi = Py_None;
  double *damping_custom = NULL;
  npy_intp damping_custom_Dims[2] = {-1, -1};
  const int damping_custom_Rank = 2;
  PyArrayObject *capi_damping_custom_tmp = NULL;
  int capi_damping_custom_intent = 0;
  PyObject *damping_custom_capi = Py_None;
  double *potential_custom = NULL;
  npy_intp potential_custom_Dims[4] = {-1, -1, -1, -1};
  const int potential_custom_Rank = 4;
  PyArrayObject *capi_potential_custom_tmp = NULL;
  int capi_potential_custom_intent = 0;
  PyObject *potential_custom_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  double *mode_enes = NULL;
  npy_intp mode_enes_Dims[1] = {-1};
  const int mode_enes_Rank = 1;
  PyArrayObject *capi_mode_enes_tmp = NULL;
  int capi_mode_enes_intent = 0;
  double *modes = NULL;
  npy_intp modes_Dims[2] = {-1, -1};
  const int modes_Rank = 2;
  PyArrayObject *capi_modes_tmp = NULL;
  int capi_modes_intent = 0;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  static char *capi_kwlist[] = {"mode","version","xyz","alpha_0","omega","r_vdw","beta","a","overlap","c6","damping_custom","potential_custom","unit_cell",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO|OOOOOOOO:lib.mbd.get_single_mbd_energy",\
    capi_kwlist,&mode_capi,&version_capi,&xyz_capi,&alpha_0_capi,&omega_capi,&r_vdw_capi,&beta_capi,&a_capi,&overlap_capi,&c6_capi,&damping_custom_capi,&potential_custom_capi,&unit_cell_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.get_single_mbd_energy to C string");
  if (f2py_success) {
  /* Processing variable version */
  slen(version) = -1;
  f2py_success = string_from_pyobj(&version,&slen(version),"",version_capi,"string_from_pyobj failed in converting 2nd argument `version' of lib.mbd.get_single_mbd_energy to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `xyz' of lib.mbd.get_single_mbd_energy to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable beta */
  if (beta_capi != Py_None)
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.get_single_mbd_energy() 2nd keyword (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
  if (a_capi != Py_None)
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.get_single_mbd_energy() 3rd keyword (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 8th keyword `unit_cell' of lib.mbd.get_single_mbd_energy to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable alpha_0 */
  alpha_0_Dims[0]=size(xyz, 1);
  capi_alpha_0_intent |= F2PY_INTENT_IN;
  capi_alpha_0_tmp = array_from_pyobj(NPY_DOUBLE,alpha_0_Dims,alpha_0_Rank,capi_alpha_0_intent,alpha_0_capi);
  if (capi_alpha_0_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `alpha_0' of lib.mbd.get_single_mbd_energy to C/Fortran array" );
  } else {
    alpha_0 = (double *)(PyArray_DATA(capi_alpha_0_tmp));

  /* Processing variable omega */
  omega_Dims[0]=size(xyz, 1);
  capi_omega_intent |= F2PY_INTENT_IN;
  capi_omega_tmp = array_from_pyobj(NPY_DOUBLE,omega_Dims,omega_Rank,capi_omega_intent,omega_capi);
  if (capi_omega_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `omega' of lib.mbd.get_single_mbd_energy to C/Fortran array" );
  } else {
    omega = (double *)(PyArray_DATA(capi_omega_tmp));

  /* Processing variable r_vdw */
  r_vdw_Dims[0]=size(xyz, 1);
  capi_r_vdw_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_r_vdw_tmp = array_from_pyobj(NPY_DOUBLE,r_vdw_Dims,r_vdw_Rank,capi_r_vdw_intent,r_vdw_capi);
  if (capi_r_vdw_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `r_vdw' of lib.mbd.get_single_mbd_energy to C/Fortran array" );
  } else {
    r_vdw = (double *)(PyArray_DATA(capi_r_vdw_tmp));

  /* Processing variable overlap */
  overlap_Dims[0]=size(xyz, 1),overlap_Dims[1]=size(xyz, 1);
  capi_overlap_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_overlap_tmp = array_from_pyobj(NPY_DOUBLE,overlap_Dims,overlap_Rank,capi_overlap_intent,overlap_capi);
  if (capi_overlap_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th keyword `overlap' of lib.mbd.get_single_mbd_energy to C/Fortran array" );
  } else {
    overlap = (double *)(PyArray_DATA(capi_overlap_tmp));

  /* Processing variable c6 */
  c6_Dims[0]=size(xyz, 1);
  capi_c6_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_c6_tmp = array_from_pyobj(NPY_DOUBLE,c6_Dims,c6_Rank,capi_c6_intent,c6_capi);
  if (capi_c6_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th keyword `c6' of lib.mbd.get_single_mbd_energy to C/Fortran array" );
  } else {
    c6 = (double *)(PyArray_DATA(capi_c6_tmp));

  /* Processing variable damping_custom */
  damping_custom_Dims[0]=size(xyz, 1),damping_custom_Dims[1]=size(xyz, 1);
  capi_damping_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_damping_custom_tmp = array_from_pyobj(NPY_DOUBLE,damping_custom_Dims,damping_custom_Rank,capi_damping_custom_intent,damping_custom_capi);
  if (capi_damping_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th keyword `damping_custom' of lib.mbd.get_single_mbd_energy to C/Fortran array" );
  } else {
    damping_custom = (double *)(PyArray_DATA(capi_damping_custom_tmp));

  /* Processing variable potential_custom */
  potential_custom_Dims[0]=size(xyz, 1),potential_custom_Dims[1]=size(xyz, 1),potential_custom_Dims[2]=3,potential_custom_Dims[3]=3;
  capi_potential_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_potential_custom_tmp = array_from_pyobj(NPY_DOUBLE,potential_custom_Dims,potential_custom_Rank,capi_potential_custom_intent,potential_custom_capi);
  if (capi_potential_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 7th keyword `potential_custom' of lib.mbd.get_single_mbd_energy to C/Fortran array" );
  } else {
    potential_custom = (double *)(PyArray_DATA(capi_potential_custom_tmp));

  /* Processing variable mode_enes */
  mode_enes_Dims[0]=3*size(xyz, 1);
  capi_mode_enes_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_mode_enes_tmp = array_from_pyobj(NPY_DOUBLE,mode_enes_Dims,mode_enes_Rank,capi_mode_enes_intent,Py_None);
  if (capi_mode_enes_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `mode_enes' of lib.mbd.get_single_mbd_energy to C/Fortran array" );
  } else {
    mode_enes = (double *)(PyArray_DATA(capi_mode_enes_tmp));

  /* Processing variable modes */
  modes_Dims[0]=3*size(xyz, 1),modes_Dims[1]=3*size(xyz, 1);
  capi_modes_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_modes_tmp = array_from_pyobj(NPY_DOUBLE,modes_Dims,modes_Rank,capi_modes_intent,Py_None);
  if (capi_modes_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `modes' of lib.mbd.get_single_mbd_energy to C/Fortran array" );
  } else {
    modes = (double *)(PyArray_DATA(capi_modes_tmp));

  /* Processing variable get_single_mbd_energy */
  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_single_mbd_energy,mode,version,xyz,alpha_0,omega,r_vdw,&beta,&a,overlap,c6,damping_custom,potential_custom,unit_cell,mode_enes,modes,&f2py_xyz_d0,&f2py_xyz_d1,slen(mode),slen(version));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("dNN",get_single_mbd_energy,capi_mode_enes_tmp,capi_modes_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  /* End of cleaning variable get_single_mbd_energy */
  }  /*if (capi_modes_tmp == NULL) ... else of modes*/
  /* End of cleaning variable modes */
  }  /*if (capi_mode_enes_tmp == NULL) ... else of mode_enes*/
  /* End of cleaning variable mode_enes */
  if((PyObject *)capi_potential_custom_tmp!=potential_custom_capi) {
    Py_XDECREF(capi_potential_custom_tmp); }
  }  /*if (capi_potential_custom_tmp == NULL) ... else of potential_custom*/
  /* End of cleaning variable potential_custom */
  if((PyObject *)capi_damping_custom_tmp!=damping_custom_capi) {
    Py_XDECREF(capi_damping_custom_tmp); }
  }  /*if (capi_damping_custom_tmp == NULL) ... else of damping_custom*/
  /* End of cleaning variable damping_custom */
  if((PyObject *)capi_c6_tmp!=c6_capi) {
    Py_XDECREF(capi_c6_tmp); }
  }  /*if (capi_c6_tmp == NULL) ... else of c6*/
  /* End of cleaning variable c6 */
  if((PyObject *)capi_overlap_tmp!=overlap_capi) {
    Py_XDECREF(capi_overlap_tmp); }
  }  /*if (capi_overlap_tmp == NULL) ... else of overlap*/
  /* End of cleaning variable overlap */
  if((PyObject *)capi_r_vdw_tmp!=r_vdw_capi) {
    Py_XDECREF(capi_r_vdw_tmp); }
  }  /*if (capi_r_vdw_tmp == NULL) ... else of r_vdw*/
  /* End of cleaning variable r_vdw */
  if((PyObject *)capi_omega_tmp!=omega_capi) {
    Py_XDECREF(capi_omega_tmp); }
  }  /*if (capi_omega_tmp == NULL) ... else of omega*/
  /* End of cleaning variable omega */
  if((PyObject *)capi_alpha_0_tmp!=alpha_0_capi) {
    Py_XDECREF(capi_alpha_0_tmp); }
  }  /*if (capi_alpha_0_tmp == NULL) ... else of alpha_0*/
  /* End of cleaning variable alpha_0 */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(version);
  }  /*if (f2py_success) of version*/
  /* End of cleaning variable version */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of get_single_mbd_energy ************************/

/*********************** get_single_reciprocal_mbd_ene ***********************/
static char doc_f2py_rout_lib_mbd_get_single_reciprocal_mbd_ene[] = "\
ene,mode_enes,modes = get_single_reciprocal_mbd_ene(mode,version,xyz,alpha_0,omega,k_point,unit_cell,[r_vdw,beta,a,overlap,c6,damping_custom,potential_custom])\n\nWrapper for ``get_single_reciprocal_mbd_ene``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"version : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"alpha_0 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"omega : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"k_point : input rank-1 array('d') with bounds (3)\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"\nOther Parameters\n----------------\n"
"r_vdw : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"beta : input float\n"
"a : input float\n"
"overlap : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"c6 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"damping_custom : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"potential_custom : input rank-4 array('d') with bounds (size(xyz, 1),size(xyz, 1),3,3)\n"
"\nReturns\n-------\n"
"ene : float\n"
"mode_enes : rank-1 array('d') with bounds (3*size(xyz, 1))\n"
"modes : rank-2 array('D') with bounds (3*size(xyz, 1),3*size(xyz, 1))";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_single_reciprocal_mbd_ene(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,string,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,complex_double*,int*,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double get_single_reciprocal_mbd_ene = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  string version = NULL;
  int slen(version);
  PyObject *version_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *alpha_0 = NULL;
  npy_intp alpha_0_Dims[1] = {-1};
  const int alpha_0_Rank = 1;
  PyArrayObject *capi_alpha_0_tmp = NULL;
  int capi_alpha_0_intent = 0;
  PyObject *alpha_0_capi = Py_None;
  double *omega = NULL;
  npy_intp omega_Dims[1] = {-1};
  const int omega_Rank = 1;
  PyArrayObject *capi_omega_tmp = NULL;
  int capi_omega_intent = 0;
  PyObject *omega_capi = Py_None;
  double *k_point = NULL;
  npy_intp k_point_Dims[1] = {-1};
  const int k_point_Rank = 1;
  PyArrayObject *capi_k_point_tmp = NULL;
  int capi_k_point_intent = 0;
  PyObject *k_point_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  double *r_vdw = NULL;
  npy_intp r_vdw_Dims[1] = {-1};
  const int r_vdw_Rank = 1;
  PyArrayObject *capi_r_vdw_tmp = NULL;
  int capi_r_vdw_intent = 0;
  PyObject *r_vdw_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  double *overlap = NULL;
  npy_intp overlap_Dims[2] = {-1, -1};
  const int overlap_Rank = 2;
  PyArrayObject *capi_overlap_tmp = NULL;
  int capi_overlap_intent = 0;
  PyObject *overlap_capi = Py_None;
  double *c6 = NULL;
  npy_intp c6_Dims[1] = {-1};
  const int c6_Rank = 1;
  PyArrayObject *capi_c6_tmp = NULL;
  int capi_c6_intent = 0;
  PyObject *c6_capi = Py_None;
  double *damping_custom = NULL;
  npy_intp damping_custom_Dims[2] = {-1, -1};
  const int damping_custom_Rank = 2;
  PyArrayObject *capi_damping_custom_tmp = NULL;
  int capi_damping_custom_intent = 0;
  PyObject *damping_custom_capi = Py_None;
  double *potential_custom = NULL;
  npy_intp potential_custom_Dims[4] = {-1, -1, -1, -1};
  const int potential_custom_Rank = 4;
  PyArrayObject *capi_potential_custom_tmp = NULL;
  int capi_potential_custom_intent = 0;
  PyObject *potential_custom_capi = Py_None;
  double *mode_enes = NULL;
  npy_intp mode_enes_Dims[1] = {-1};
  const int mode_enes_Rank = 1;
  PyArrayObject *capi_mode_enes_tmp = NULL;
  int capi_mode_enes_intent = 0;
  complex_double *modes = NULL;
  npy_intp modes_Dims[2] = {-1, -1};
  const int modes_Rank = 2;
  PyArrayObject *capi_modes_tmp = NULL;
  int capi_modes_intent = 0;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  static char *capi_kwlist[] = {"mode","version","xyz","alpha_0","omega","k_point","unit_cell","r_vdw","beta","a","overlap","c6","damping_custom","potential_custom",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOO|OOOOOOO:lib.mbd.get_single_reciprocal_mbd_ene",\
    capi_kwlist,&mode_capi,&version_capi,&xyz_capi,&alpha_0_capi,&omega_capi,&k_point_capi,&unit_cell_capi,&r_vdw_capi,&beta_capi,&a_capi,&overlap_capi,&c6_capi,&damping_custom_capi,&potential_custom_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.get_single_reciprocal_mbd_ene to C string");
  if (f2py_success) {
  /* Processing variable version */
  slen(version) = -1;
  f2py_success = string_from_pyobj(&version,&slen(version),"",version_capi,"string_from_pyobj failed in converting 2nd argument `version' of lib.mbd.get_single_reciprocal_mbd_ene to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `xyz' of lib.mbd.get_single_reciprocal_mbd_ene to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable k_point */
  k_point_Dims[0]=3;
  capi_k_point_intent |= F2PY_INTENT_IN;
  capi_k_point_tmp = array_from_pyobj(NPY_DOUBLE,k_point_Dims,k_point_Rank,capi_k_point_intent,k_point_capi);
  if (capi_k_point_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th argument `k_point' of lib.mbd.get_single_reciprocal_mbd_ene to C/Fortran array" );
  } else {
    k_point = (double *)(PyArray_DATA(capi_k_point_tmp));

  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 7th argument `unit_cell' of lib.mbd.get_single_reciprocal_mbd_ene to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable beta */
  if (beta_capi != Py_None)
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.get_single_reciprocal_mbd_ene() 2nd keyword (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
  if (a_capi != Py_None)
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.get_single_reciprocal_mbd_ene() 3rd keyword (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable alpha_0 */
  alpha_0_Dims[0]=size(xyz, 1);
  capi_alpha_0_intent |= F2PY_INTENT_IN;
  capi_alpha_0_tmp = array_from_pyobj(NPY_DOUBLE,alpha_0_Dims,alpha_0_Rank,capi_alpha_0_intent,alpha_0_capi);
  if (capi_alpha_0_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `alpha_0' of lib.mbd.get_single_reciprocal_mbd_ene to C/Fortran array" );
  } else {
    alpha_0 = (double *)(PyArray_DATA(capi_alpha_0_tmp));

  /* Processing variable omega */
  omega_Dims[0]=size(xyz, 1);
  capi_omega_intent |= F2PY_INTENT_IN;
  capi_omega_tmp = array_from_pyobj(NPY_DOUBLE,omega_Dims,omega_Rank,capi_omega_intent,omega_capi);
  if (capi_omega_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `omega' of lib.mbd.get_single_reciprocal_mbd_ene to C/Fortran array" );
  } else {
    omega = (double *)(PyArray_DATA(capi_omega_tmp));

  /* Processing variable r_vdw */
  r_vdw_Dims[0]=size(xyz, 1);
  capi_r_vdw_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_r_vdw_tmp = array_from_pyobj(NPY_DOUBLE,r_vdw_Dims,r_vdw_Rank,capi_r_vdw_intent,r_vdw_capi);
  if (capi_r_vdw_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `r_vdw' of lib.mbd.get_single_reciprocal_mbd_ene to C/Fortran array" );
  } else {
    r_vdw = (double *)(PyArray_DATA(capi_r_vdw_tmp));

  /* Processing variable overlap */
  overlap_Dims[0]=size(xyz, 1),overlap_Dims[1]=size(xyz, 1);
  capi_overlap_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_overlap_tmp = array_from_pyobj(NPY_DOUBLE,overlap_Dims,overlap_Rank,capi_overlap_intent,overlap_capi);
  if (capi_overlap_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th keyword `overlap' of lib.mbd.get_single_reciprocal_mbd_ene to C/Fortran array" );
  } else {
    overlap = (double *)(PyArray_DATA(capi_overlap_tmp));

  /* Processing variable c6 */
  c6_Dims[0]=size(xyz, 1);
  capi_c6_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_c6_tmp = array_from_pyobj(NPY_DOUBLE,c6_Dims,c6_Rank,capi_c6_intent,c6_capi);
  if (capi_c6_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th keyword `c6' of lib.mbd.get_single_reciprocal_mbd_ene to C/Fortran array" );
  } else {
    c6 = (double *)(PyArray_DATA(capi_c6_tmp));

  /* Processing variable damping_custom */
  damping_custom_Dims[0]=size(xyz, 1),damping_custom_Dims[1]=size(xyz, 1);
  capi_damping_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_damping_custom_tmp = array_from_pyobj(NPY_DOUBLE,damping_custom_Dims,damping_custom_Rank,capi_damping_custom_intent,damping_custom_capi);
  if (capi_damping_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th keyword `damping_custom' of lib.mbd.get_single_reciprocal_mbd_ene to C/Fortran array" );
  } else {
    damping_custom = (double *)(PyArray_DATA(capi_damping_custom_tmp));

  /* Processing variable potential_custom */
  potential_custom_Dims[0]=size(xyz, 1),potential_custom_Dims[1]=size(xyz, 1),potential_custom_Dims[2]=3,potential_custom_Dims[3]=3;
  capi_potential_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_potential_custom_tmp = array_from_pyobj(NPY_DOUBLE,potential_custom_Dims,potential_custom_Rank,capi_potential_custom_intent,potential_custom_capi);
  if (capi_potential_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 7th keyword `potential_custom' of lib.mbd.get_single_reciprocal_mbd_ene to C/Fortran array" );
  } else {
    potential_custom = (double *)(PyArray_DATA(capi_potential_custom_tmp));

  /* Processing variable mode_enes */
  mode_enes_Dims[0]=3*size(xyz, 1);
  capi_mode_enes_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_mode_enes_tmp = array_from_pyobj(NPY_DOUBLE,mode_enes_Dims,mode_enes_Rank,capi_mode_enes_intent,Py_None);
  if (capi_mode_enes_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `mode_enes' of lib.mbd.get_single_reciprocal_mbd_ene to C/Fortran array" );
  } else {
    mode_enes = (double *)(PyArray_DATA(capi_mode_enes_tmp));

  /* Processing variable modes */
  modes_Dims[0]=3*size(xyz, 1),modes_Dims[1]=3*size(xyz, 1);
  capi_modes_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_modes_tmp = array_from_pyobj(NPY_CDOUBLE,modes_Dims,modes_Rank,capi_modes_intent,Py_None);
  if (capi_modes_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `modes' of lib.mbd.get_single_reciprocal_mbd_ene to C/Fortran array" );
  } else {
    modes = (complex_double *)(PyArray_DATA(capi_modes_tmp));

  /* Processing variable get_single_reciprocal_mbd_ene */
  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_single_reciprocal_mbd_ene,mode,version,xyz,alpha_0,omega,k_point,unit_cell,r_vdw,&beta,&a,overlap,c6,damping_custom,potential_custom,mode_enes,modes,&f2py_xyz_d0,&f2py_xyz_d1,slen(mode),slen(version));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("dNN",get_single_reciprocal_mbd_ene,capi_mode_enes_tmp,capi_modes_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  /* End of cleaning variable get_single_reciprocal_mbd_ene */
  }  /*if (capi_modes_tmp == NULL) ... else of modes*/
  /* End of cleaning variable modes */
  }  /*if (capi_mode_enes_tmp == NULL) ... else of mode_enes*/
  /* End of cleaning variable mode_enes */
  if((PyObject *)capi_potential_custom_tmp!=potential_custom_capi) {
    Py_XDECREF(capi_potential_custom_tmp); }
  }  /*if (capi_potential_custom_tmp == NULL) ... else of potential_custom*/
  /* End of cleaning variable potential_custom */
  if((PyObject *)capi_damping_custom_tmp!=damping_custom_capi) {
    Py_XDECREF(capi_damping_custom_tmp); }
  }  /*if (capi_damping_custom_tmp == NULL) ... else of damping_custom*/
  /* End of cleaning variable damping_custom */
  if((PyObject *)capi_c6_tmp!=c6_capi) {
    Py_XDECREF(capi_c6_tmp); }
  }  /*if (capi_c6_tmp == NULL) ... else of c6*/
  /* End of cleaning variable c6 */
  if((PyObject *)capi_overlap_tmp!=overlap_capi) {
    Py_XDECREF(capi_overlap_tmp); }
  }  /*if (capi_overlap_tmp == NULL) ... else of overlap*/
  /* End of cleaning variable overlap */
  if((PyObject *)capi_r_vdw_tmp!=r_vdw_capi) {
    Py_XDECREF(capi_r_vdw_tmp); }
  }  /*if (capi_r_vdw_tmp == NULL) ... else of r_vdw*/
  /* End of cleaning variable r_vdw */
  if((PyObject *)capi_omega_tmp!=omega_capi) {
    Py_XDECREF(capi_omega_tmp); }
  }  /*if (capi_omega_tmp == NULL) ... else of omega*/
  /* End of cleaning variable omega */
  if((PyObject *)capi_alpha_0_tmp!=alpha_0_capi) {
    Py_XDECREF(capi_alpha_0_tmp); }
  }  /*if (capi_alpha_0_tmp == NULL) ... else of alpha_0*/
  /* End of cleaning variable alpha_0 */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  if((PyObject *)capi_k_point_tmp!=k_point_capi) {
    Py_XDECREF(capi_k_point_tmp); }
  }  /*if (capi_k_point_tmp == NULL) ... else of k_point*/
  /* End of cleaning variable k_point */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(version);
  }  /*if (f2py_success) of version*/
  /* End of cleaning variable version */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************** end of get_single_reciprocal_mbd_ene ********************/

/************************* get_reciprocal_mbd_energy *************************/
static char doc_f2py_rout_lib_mbd_get_reciprocal_mbd_energy[] = "\
ene,mode_enes,modes,rpa_orders = get_reciprocal_mbd_energy(mode,version,xyz,alpha_0,omega,k_grid,unit_cell,[r_vdw,beta,a,overlap,c6,damping_custom,potential_custom])\n\nWrapper for ``get_reciprocal_mbd_energy``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"version : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"alpha_0 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"omega : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"k_grid : input rank-2 array('d') with bounds (f2py_k_grid_d0,f2py_k_grid_d1)\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"\nOther Parameters\n----------------\n"
"r_vdw : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"beta : input float\n"
"a : input float\n"
"overlap : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"c6 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"damping_custom : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"potential_custom : input rank-4 array('d') with bounds (size(xyz, 1),size(xyz, 1),3,3)\n"
"\nReturns\n-------\n"
"ene : float\n"
"mode_enes : rank-2 array('d') with bounds (size(k_grid, 1),3*size(xyz, 1))\n"
"modes : rank-3 array('D') with bounds (size(k_grid, 1),3*size(xyz, 1),3*size(xyz, 1))\n"
"rpa_orders : rank-2 array('d') with bounds (size(k_grid, 1),20)";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_reciprocal_mbd_energy(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,string,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,complex_double*,double*,int*,int*,int*,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double get_reciprocal_mbd_energy = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  string version = NULL;
  int slen(version);
  PyObject *version_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *alpha_0 = NULL;
  npy_intp alpha_0_Dims[1] = {-1};
  const int alpha_0_Rank = 1;
  PyArrayObject *capi_alpha_0_tmp = NULL;
  int capi_alpha_0_intent = 0;
  PyObject *alpha_0_capi = Py_None;
  double *omega = NULL;
  npy_intp omega_Dims[1] = {-1};
  const int omega_Rank = 1;
  PyArrayObject *capi_omega_tmp = NULL;
  int capi_omega_intent = 0;
  PyObject *omega_capi = Py_None;
  double *k_grid = NULL;
  npy_intp k_grid_Dims[2] = {-1, -1};
  const int k_grid_Rank = 2;
  PyArrayObject *capi_k_grid_tmp = NULL;
  int capi_k_grid_intent = 0;
  PyObject *k_grid_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  double *r_vdw = NULL;
  npy_intp r_vdw_Dims[1] = {-1};
  const int r_vdw_Rank = 1;
  PyArrayObject *capi_r_vdw_tmp = NULL;
  int capi_r_vdw_intent = 0;
  PyObject *r_vdw_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  double *overlap = NULL;
  npy_intp overlap_Dims[2] = {-1, -1};
  const int overlap_Rank = 2;
  PyArrayObject *capi_overlap_tmp = NULL;
  int capi_overlap_intent = 0;
  PyObject *overlap_capi = Py_None;
  double *c6 = NULL;
  npy_intp c6_Dims[1] = {-1};
  const int c6_Rank = 1;
  PyArrayObject *capi_c6_tmp = NULL;
  int capi_c6_intent = 0;
  PyObject *c6_capi = Py_None;
  double *damping_custom = NULL;
  npy_intp damping_custom_Dims[2] = {-1, -1};
  const int damping_custom_Rank = 2;
  PyArrayObject *capi_damping_custom_tmp = NULL;
  int capi_damping_custom_intent = 0;
  PyObject *damping_custom_capi = Py_None;
  double *potential_custom = NULL;
  npy_intp potential_custom_Dims[4] = {-1, -1, -1, -1};
  const int potential_custom_Rank = 4;
  PyArrayObject *capi_potential_custom_tmp = NULL;
  int capi_potential_custom_intent = 0;
  PyObject *potential_custom_capi = Py_None;
  double *mode_enes = NULL;
  npy_intp mode_enes_Dims[2] = {-1, -1};
  const int mode_enes_Rank = 2;
  PyArrayObject *capi_mode_enes_tmp = NULL;
  int capi_mode_enes_intent = 0;
  complex_double *modes = NULL;
  npy_intp modes_Dims[3] = {-1, -1, -1};
  const int modes_Rank = 3;
  PyArrayObject *capi_modes_tmp = NULL;
  int capi_modes_intent = 0;
  double *rpa_orders = NULL;
  npy_intp rpa_orders_Dims[2] = {-1, -1};
  const int rpa_orders_Rank = 2;
  PyArrayObject *capi_rpa_orders_tmp = NULL;
  int capi_rpa_orders_intent = 0;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  int f2py_k_grid_d0 = 0;
  int f2py_k_grid_d1 = 0;
  static char *capi_kwlist[] = {"mode","version","xyz","alpha_0","omega","k_grid","unit_cell","r_vdw","beta","a","overlap","c6","damping_custom","potential_custom",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOO|OOOOOOO:lib.mbd.get_reciprocal_mbd_energy",\
    capi_kwlist,&mode_capi,&version_capi,&xyz_capi,&alpha_0_capi,&omega_capi,&k_grid_capi,&unit_cell_capi,&r_vdw_capi,&beta_capi,&a_capi,&overlap_capi,&c6_capi,&damping_custom_capi,&potential_custom_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.get_reciprocal_mbd_energy to C string");
  if (f2py_success) {
  /* Processing variable version */
  slen(version) = -1;
  f2py_success = string_from_pyobj(&version,&slen(version),"",version_capi,"string_from_pyobj failed in converting 2nd argument `version' of lib.mbd.get_reciprocal_mbd_energy to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `xyz' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable k_grid */
  ;
  capi_k_grid_intent |= F2PY_INTENT_IN;
  capi_k_grid_tmp = array_from_pyobj(NPY_DOUBLE,k_grid_Dims,k_grid_Rank,capi_k_grid_intent,k_grid_capi);
  if (capi_k_grid_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th argument `k_grid' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    k_grid = (double *)(PyArray_DATA(capi_k_grid_tmp));

  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 7th argument `unit_cell' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable beta */
  if (beta_capi != Py_None)
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.get_reciprocal_mbd_energy() 2nd keyword (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
  if (a_capi != Py_None)
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.get_reciprocal_mbd_energy() 3rd keyword (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable alpha_0 */
  alpha_0_Dims[0]=size(xyz, 1);
  capi_alpha_0_intent |= F2PY_INTENT_IN;
  capi_alpha_0_tmp = array_from_pyobj(NPY_DOUBLE,alpha_0_Dims,alpha_0_Rank,capi_alpha_0_intent,alpha_0_capi);
  if (capi_alpha_0_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `alpha_0' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    alpha_0 = (double *)(PyArray_DATA(capi_alpha_0_tmp));

  /* Processing variable omega */
  omega_Dims[0]=size(xyz, 1);
  capi_omega_intent |= F2PY_INTENT_IN;
  capi_omega_tmp = array_from_pyobj(NPY_DOUBLE,omega_Dims,omega_Rank,capi_omega_intent,omega_capi);
  if (capi_omega_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `omega' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    omega = (double *)(PyArray_DATA(capi_omega_tmp));

  /* Processing variable r_vdw */
  r_vdw_Dims[0]=size(xyz, 1);
  capi_r_vdw_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_r_vdw_tmp = array_from_pyobj(NPY_DOUBLE,r_vdw_Dims,r_vdw_Rank,capi_r_vdw_intent,r_vdw_capi);
  if (capi_r_vdw_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `r_vdw' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    r_vdw = (double *)(PyArray_DATA(capi_r_vdw_tmp));

  /* Processing variable overlap */
  overlap_Dims[0]=size(xyz, 1),overlap_Dims[1]=size(xyz, 1);
  capi_overlap_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_overlap_tmp = array_from_pyobj(NPY_DOUBLE,overlap_Dims,overlap_Rank,capi_overlap_intent,overlap_capi);
  if (capi_overlap_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th keyword `overlap' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    overlap = (double *)(PyArray_DATA(capi_overlap_tmp));

  /* Processing variable c6 */
  c6_Dims[0]=size(xyz, 1);
  capi_c6_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_c6_tmp = array_from_pyobj(NPY_DOUBLE,c6_Dims,c6_Rank,capi_c6_intent,c6_capi);
  if (capi_c6_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th keyword `c6' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    c6 = (double *)(PyArray_DATA(capi_c6_tmp));

  /* Processing variable damping_custom */
  damping_custom_Dims[0]=size(xyz, 1),damping_custom_Dims[1]=size(xyz, 1);
  capi_damping_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_damping_custom_tmp = array_from_pyobj(NPY_DOUBLE,damping_custom_Dims,damping_custom_Rank,capi_damping_custom_intent,damping_custom_capi);
  if (capi_damping_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th keyword `damping_custom' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    damping_custom = (double *)(PyArray_DATA(capi_damping_custom_tmp));

  /* Processing variable potential_custom */
  potential_custom_Dims[0]=size(xyz, 1),potential_custom_Dims[1]=size(xyz, 1),potential_custom_Dims[2]=3,potential_custom_Dims[3]=3;
  capi_potential_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_potential_custom_tmp = array_from_pyobj(NPY_DOUBLE,potential_custom_Dims,potential_custom_Rank,capi_potential_custom_intent,potential_custom_capi);
  if (capi_potential_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 7th keyword `potential_custom' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    potential_custom = (double *)(PyArray_DATA(capi_potential_custom_tmp));

  /* Processing variable mode_enes */
  mode_enes_Dims[0]=size(k_grid, 1),mode_enes_Dims[1]=3*size(xyz, 1);
  capi_mode_enes_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_mode_enes_tmp = array_from_pyobj(NPY_DOUBLE,mode_enes_Dims,mode_enes_Rank,capi_mode_enes_intent,Py_None);
  if (capi_mode_enes_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `mode_enes' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    mode_enes = (double *)(PyArray_DATA(capi_mode_enes_tmp));

  /* Processing variable rpa_orders */
  rpa_orders_Dims[0]=size(k_grid, 1),rpa_orders_Dims[1]=20;
  capi_rpa_orders_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_rpa_orders_tmp = array_from_pyobj(NPY_DOUBLE,rpa_orders_Dims,rpa_orders_Rank,capi_rpa_orders_intent,Py_None);
  if (capi_rpa_orders_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `rpa_orders' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    rpa_orders = (double *)(PyArray_DATA(capi_rpa_orders_tmp));

  /* Processing variable modes */
  modes_Dims[0]=size(k_grid, 1),modes_Dims[1]=3*size(xyz, 1),modes_Dims[2]=3*size(xyz, 1);
  capi_modes_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_modes_tmp = array_from_pyobj(NPY_CDOUBLE,modes_Dims,modes_Rank,capi_modes_intent,Py_None);
  if (capi_modes_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `modes' of lib.mbd.get_reciprocal_mbd_energy to C/Fortran array" );
  } else {
    modes = (complex_double *)(PyArray_DATA(capi_modes_tmp));

  /* Processing variable get_reciprocal_mbd_energy */
  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
  /* Processing variable f2py_k_grid_d0 */
  f2py_k_grid_d0 = shape(k_grid, 0);
  /* Processing variable f2py_k_grid_d1 */
  f2py_k_grid_d1 = shape(k_grid, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_reciprocal_mbd_energy,mode,version,xyz,alpha_0,omega,k_grid,unit_cell,r_vdw,&beta,&a,overlap,c6,damping_custom,potential_custom,mode_enes,modes,rpa_orders,&f2py_xyz_d0,&f2py_xyz_d1,&f2py_k_grid_d0,&f2py_k_grid_d1,slen(mode),slen(version));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("dNNN",get_reciprocal_mbd_energy,capi_mode_enes_tmp,capi_modes_tmp,capi_rpa_orders_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_k_grid_d1 */
  /* End of cleaning variable f2py_k_grid_d0 */
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  /* End of cleaning variable get_reciprocal_mbd_energy */
  }  /*if (capi_modes_tmp == NULL) ... else of modes*/
  /* End of cleaning variable modes */
  }  /*if (capi_rpa_orders_tmp == NULL) ... else of rpa_orders*/
  /* End of cleaning variable rpa_orders */
  }  /*if (capi_mode_enes_tmp == NULL) ... else of mode_enes*/
  /* End of cleaning variable mode_enes */
  if((PyObject *)capi_potential_custom_tmp!=potential_custom_capi) {
    Py_XDECREF(capi_potential_custom_tmp); }
  }  /*if (capi_potential_custom_tmp == NULL) ... else of potential_custom*/
  /* End of cleaning variable potential_custom */
  if((PyObject *)capi_damping_custom_tmp!=damping_custom_capi) {
    Py_XDECREF(capi_damping_custom_tmp); }
  }  /*if (capi_damping_custom_tmp == NULL) ... else of damping_custom*/
  /* End of cleaning variable damping_custom */
  if((PyObject *)capi_c6_tmp!=c6_capi) {
    Py_XDECREF(capi_c6_tmp); }
  }  /*if (capi_c6_tmp == NULL) ... else of c6*/
  /* End of cleaning variable c6 */
  if((PyObject *)capi_overlap_tmp!=overlap_capi) {
    Py_XDECREF(capi_overlap_tmp); }
  }  /*if (capi_overlap_tmp == NULL) ... else of overlap*/
  /* End of cleaning variable overlap */
  if((PyObject *)capi_r_vdw_tmp!=r_vdw_capi) {
    Py_XDECREF(capi_r_vdw_tmp); }
  }  /*if (capi_r_vdw_tmp == NULL) ... else of r_vdw*/
  /* End of cleaning variable r_vdw */
  if((PyObject *)capi_omega_tmp!=omega_capi) {
    Py_XDECREF(capi_omega_tmp); }
  }  /*if (capi_omega_tmp == NULL) ... else of omega*/
  /* End of cleaning variable omega */
  if((PyObject *)capi_alpha_0_tmp!=alpha_0_capi) {
    Py_XDECREF(capi_alpha_0_tmp); }
  }  /*if (capi_alpha_0_tmp == NULL) ... else of alpha_0*/
  /* End of cleaning variable alpha_0 */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  if((PyObject *)capi_k_grid_tmp!=k_grid_capi) {
    Py_XDECREF(capi_k_grid_tmp); }
  }  /*if (capi_k_grid_tmp == NULL) ... else of k_grid*/
  /* End of cleaning variable k_grid */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(version);
  }  /*if (f2py_success) of version*/
  /* End of cleaning variable version */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/********************** end of get_reciprocal_mbd_energy **********************/

/************************** get_supercell_mbd_energy **************************/
static char doc_f2py_rout_lib_mbd_get_supercell_mbd_energy[] = "\
ene,rpa_orders = get_supercell_mbd_energy(mode,version,xyz,alpha_0,omega,unit_cell,supercell,[r_vdw,beta,a,c6])\n\nWrapper for ``get_supercell_mbd_energy``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"version : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"alpha_0 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"omega : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"supercell : input rank-1 array('i') with bounds (3)\n"
"\nOther Parameters\n----------------\n"
"r_vdw : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"beta : input float\n"
"a : input float\n"
"c6 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"\nReturns\n-------\n"
"ene : float\n"
"rpa_orders : rank-1 array('d') with bounds (20)";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_supercell_mbd_energy(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,string,double*,double*,double*,double*,int*,double*,double*,double*,double*,double*,int*,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double get_supercell_mbd_energy = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  string version = NULL;
  int slen(version);
  PyObject *version_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *alpha_0 = NULL;
  npy_intp alpha_0_Dims[1] = {-1};
  const int alpha_0_Rank = 1;
  PyArrayObject *capi_alpha_0_tmp = NULL;
  int capi_alpha_0_intent = 0;
  PyObject *alpha_0_capi = Py_None;
  double *omega = NULL;
  npy_intp omega_Dims[1] = {-1};
  const int omega_Rank = 1;
  PyArrayObject *capi_omega_tmp = NULL;
  int capi_omega_intent = 0;
  PyObject *omega_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  int *supercell = NULL;
  npy_intp supercell_Dims[1] = {-1};
  const int supercell_Rank = 1;
  PyArrayObject *capi_supercell_tmp = NULL;
  int capi_supercell_intent = 0;
  PyObject *supercell_capi = Py_None;
  double *r_vdw = NULL;
  npy_intp r_vdw_Dims[1] = {-1};
  const int r_vdw_Rank = 1;
  PyArrayObject *capi_r_vdw_tmp = NULL;
  int capi_r_vdw_intent = 0;
  PyObject *r_vdw_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  double *c6 = NULL;
  npy_intp c6_Dims[1] = {-1};
  const int c6_Rank = 1;
  PyArrayObject *capi_c6_tmp = NULL;
  int capi_c6_intent = 0;
  PyObject *c6_capi = Py_None;
  double *rpa_orders = NULL;
  npy_intp rpa_orders_Dims[1] = {-1};
  const int rpa_orders_Rank = 1;
  PyArrayObject *capi_rpa_orders_tmp = NULL;
  int capi_rpa_orders_intent = 0;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  static char *capi_kwlist[] = {"mode","version","xyz","alpha_0","omega","unit_cell","supercell","r_vdw","beta","a","c6",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOO|OOOO:lib.mbd.get_supercell_mbd_energy",\
    capi_kwlist,&mode_capi,&version_capi,&xyz_capi,&alpha_0_capi,&omega_capi,&unit_cell_capi,&supercell_capi,&r_vdw_capi,&beta_capi,&a_capi,&c6_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.get_supercell_mbd_energy to C string");
  if (f2py_success) {
  /* Processing variable version */
  slen(version) = -1;
  f2py_success = string_from_pyobj(&version,&slen(version),"",version_capi,"string_from_pyobj failed in converting 2nd argument `version' of lib.mbd.get_supercell_mbd_energy to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `xyz' of lib.mbd.get_supercell_mbd_energy to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th argument `unit_cell' of lib.mbd.get_supercell_mbd_energy to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable supercell */
  supercell_Dims[0]=3;
  capi_supercell_intent |= F2PY_INTENT_IN;
  capi_supercell_tmp = array_from_pyobj(NPY_INT,supercell_Dims,supercell_Rank,capi_supercell_intent,supercell_capi);
  if (capi_supercell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 7th argument `supercell' of lib.mbd.get_supercell_mbd_energy to C/Fortran array" );
  } else {
    supercell = (int *)(PyArray_DATA(capi_supercell_tmp));

  /* Processing variable beta */
  if (beta_capi != Py_None)
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.get_supercell_mbd_energy() 2nd keyword (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
  if (a_capi != Py_None)
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.get_supercell_mbd_energy() 3rd keyword (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable rpa_orders */
  rpa_orders_Dims[0]=20;
  capi_rpa_orders_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_rpa_orders_tmp = array_from_pyobj(NPY_DOUBLE,rpa_orders_Dims,rpa_orders_Rank,capi_rpa_orders_intent,Py_None);
  if (capi_rpa_orders_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `rpa_orders' of lib.mbd.get_supercell_mbd_energy to C/Fortran array" );
  } else {
    rpa_orders = (double *)(PyArray_DATA(capi_rpa_orders_tmp));

  /* Processing variable alpha_0 */
  alpha_0_Dims[0]=size(xyz, 1);
  capi_alpha_0_intent |= F2PY_INTENT_IN;
  capi_alpha_0_tmp = array_from_pyobj(NPY_DOUBLE,alpha_0_Dims,alpha_0_Rank,capi_alpha_0_intent,alpha_0_capi);
  if (capi_alpha_0_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `alpha_0' of lib.mbd.get_supercell_mbd_energy to C/Fortran array" );
  } else {
    alpha_0 = (double *)(PyArray_DATA(capi_alpha_0_tmp));

  /* Processing variable omega */
  omega_Dims[0]=size(xyz, 1);
  capi_omega_intent |= F2PY_INTENT_IN;
  capi_omega_tmp = array_from_pyobj(NPY_DOUBLE,omega_Dims,omega_Rank,capi_omega_intent,omega_capi);
  if (capi_omega_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `omega' of lib.mbd.get_supercell_mbd_energy to C/Fortran array" );
  } else {
    omega = (double *)(PyArray_DATA(capi_omega_tmp));

  /* Processing variable r_vdw */
  r_vdw_Dims[0]=size(xyz, 1);
  capi_r_vdw_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_r_vdw_tmp = array_from_pyobj(NPY_DOUBLE,r_vdw_Dims,r_vdw_Rank,capi_r_vdw_intent,r_vdw_capi);
  if (capi_r_vdw_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `r_vdw' of lib.mbd.get_supercell_mbd_energy to C/Fortran array" );
  } else {
    r_vdw = (double *)(PyArray_DATA(capi_r_vdw_tmp));

  /* Processing variable c6 */
  c6_Dims[0]=size(xyz, 1);
  capi_c6_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_c6_tmp = array_from_pyobj(NPY_DOUBLE,c6_Dims,c6_Rank,capi_c6_intent,c6_capi);
  if (capi_c6_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th keyword `c6' of lib.mbd.get_supercell_mbd_energy to C/Fortran array" );
  } else {
    c6 = (double *)(PyArray_DATA(capi_c6_tmp));

  /* Processing variable get_supercell_mbd_energy */
  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_supercell_mbd_energy,mode,version,xyz,alpha_0,omega,unit_cell,supercell,r_vdw,&beta,&a,c6,rpa_orders,&f2py_xyz_d0,&f2py_xyz_d1,slen(mode),slen(version));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("dN",get_supercell_mbd_energy,capi_rpa_orders_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  /* End of cleaning variable get_supercell_mbd_energy */
  if((PyObject *)capi_c6_tmp!=c6_capi) {
    Py_XDECREF(capi_c6_tmp); }
  }  /*if (capi_c6_tmp == NULL) ... else of c6*/
  /* End of cleaning variable c6 */
  if((PyObject *)capi_r_vdw_tmp!=r_vdw_capi) {
    Py_XDECREF(capi_r_vdw_tmp); }
  }  /*if (capi_r_vdw_tmp == NULL) ... else of r_vdw*/
  /* End of cleaning variable r_vdw */
  if((PyObject *)capi_omega_tmp!=omega_capi) {
    Py_XDECREF(capi_omega_tmp); }
  }  /*if (capi_omega_tmp == NULL) ... else of omega*/
  /* End of cleaning variable omega */
  if((PyObject *)capi_alpha_0_tmp!=alpha_0_capi) {
    Py_XDECREF(capi_alpha_0_tmp); }
  }  /*if (capi_alpha_0_tmp == NULL) ... else of alpha_0*/
  /* End of cleaning variable alpha_0 */
  }  /*if (capi_rpa_orders_tmp == NULL) ... else of rpa_orders*/
  /* End of cleaning variable rpa_orders */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  if((PyObject *)capi_supercell_tmp!=supercell_capi) {
    Py_XDECREF(capi_supercell_tmp); }
  }  /*if (capi_supercell_tmp == NULL) ... else of supercell*/
  /* End of cleaning variable supercell */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(version);
  }  /*if (f2py_success) of version*/
  /* End of cleaning variable version */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/********************** end of get_supercell_mbd_energy **********************/

/*************************** get_single_rpa_energy ***************************/
static char doc_f2py_rout_lib_mbd_get_single_rpa_energy[] = "\
ene,rpa_orders = get_single_rpa_energy(mode,version,xyz,alpha,[r_vdw,beta,a,overlap,c6,damping_custom,potential_custom,unit_cell])\n\nWrapper for ``get_single_rpa_energy``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"version : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"alpha : input rank-2 array('d') with bounds (f2py_alpha_d0,f2py_alpha_d1)\n"
"\nOther Parameters\n----------------\n"
"r_vdw : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"beta : input float\n"
"a : input float\n"
"overlap : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"c6 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"damping_custom : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"potential_custom : input rank-4 array('d') with bounds (size(xyz, 1),size(xyz, 1),3,3)\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"\nReturns\n-------\n"
"ene : float\n"
"rpa_orders : rank-1 array('d') with bounds (20)";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_single_rpa_energy(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,string,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,int*,int*,int*,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double get_single_rpa_energy = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  string version = NULL;
  int slen(version);
  PyObject *version_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *alpha = NULL;
  npy_intp alpha_Dims[2] = {-1, -1};
  const int alpha_Rank = 2;
  PyArrayObject *capi_alpha_tmp = NULL;
  int capi_alpha_intent = 0;
  PyObject *alpha_capi = Py_None;
  double *r_vdw = NULL;
  npy_intp r_vdw_Dims[1] = {-1};
  const int r_vdw_Rank = 1;
  PyArrayObject *capi_r_vdw_tmp = NULL;
  int capi_r_vdw_intent = 0;
  PyObject *r_vdw_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  double *overlap = NULL;
  npy_intp overlap_Dims[2] = {-1, -1};
  const int overlap_Rank = 2;
  PyArrayObject *capi_overlap_tmp = NULL;
  int capi_overlap_intent = 0;
  PyObject *overlap_capi = Py_None;
  double *c6 = NULL;
  npy_intp c6_Dims[1] = {-1};
  const int c6_Rank = 1;
  PyArrayObject *capi_c6_tmp = NULL;
  int capi_c6_intent = 0;
  PyObject *c6_capi = Py_None;
  double *damping_custom = NULL;
  npy_intp damping_custom_Dims[2] = {-1, -1};
  const int damping_custom_Rank = 2;
  PyArrayObject *capi_damping_custom_tmp = NULL;
  int capi_damping_custom_intent = 0;
  PyObject *damping_custom_capi = Py_None;
  double *potential_custom = NULL;
  npy_intp potential_custom_Dims[4] = {-1, -1, -1, -1};
  const int potential_custom_Rank = 4;
  PyArrayObject *capi_potential_custom_tmp = NULL;
  int capi_potential_custom_intent = 0;
  PyObject *potential_custom_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  double *rpa_orders = NULL;
  npy_intp rpa_orders_Dims[1] = {-1};
  const int rpa_orders_Rank = 1;
  PyArrayObject *capi_rpa_orders_tmp = NULL;
  int capi_rpa_orders_intent = 0;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  int f2py_alpha_d0 = 0;
  int f2py_alpha_d1 = 0;
  static char *capi_kwlist[] = {"mode","version","xyz","alpha","r_vdw","beta","a","overlap","c6","damping_custom","potential_custom","unit_cell",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO|OOOOOOOO:lib.mbd.get_single_rpa_energy",\
    capi_kwlist,&mode_capi,&version_capi,&xyz_capi,&alpha_capi,&r_vdw_capi,&beta_capi,&a_capi,&overlap_capi,&c6_capi,&damping_custom_capi,&potential_custom_capi,&unit_cell_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.get_single_rpa_energy to C string");
  if (f2py_success) {
  /* Processing variable version */
  slen(version) = -1;
  f2py_success = string_from_pyobj(&version,&slen(version),"",version_capi,"string_from_pyobj failed in converting 2nd argument `version' of lib.mbd.get_single_rpa_energy to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `xyz' of lib.mbd.get_single_rpa_energy to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable alpha */
  ;
  capi_alpha_intent |= F2PY_INTENT_IN;
  capi_alpha_tmp = array_from_pyobj(NPY_DOUBLE,alpha_Dims,alpha_Rank,capi_alpha_intent,alpha_capi);
  if (capi_alpha_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `alpha' of lib.mbd.get_single_rpa_energy to C/Fortran array" );
  } else {
    alpha = (double *)(PyArray_DATA(capi_alpha_tmp));

  /* Processing variable beta */
  if (beta_capi != Py_None)
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.get_single_rpa_energy() 2nd keyword (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
  if (a_capi != Py_None)
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.get_single_rpa_energy() 3rd keyword (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 8th keyword `unit_cell' of lib.mbd.get_single_rpa_energy to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable rpa_orders */
  rpa_orders_Dims[0]=20;
  capi_rpa_orders_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_rpa_orders_tmp = array_from_pyobj(NPY_DOUBLE,rpa_orders_Dims,rpa_orders_Rank,capi_rpa_orders_intent,Py_None);
  if (capi_rpa_orders_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `rpa_orders' of lib.mbd.get_single_rpa_energy to C/Fortran array" );
  } else {
    rpa_orders = (double *)(PyArray_DATA(capi_rpa_orders_tmp));

  /* Processing variable r_vdw */
  r_vdw_Dims[0]=size(xyz, 1);
  capi_r_vdw_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_r_vdw_tmp = array_from_pyobj(NPY_DOUBLE,r_vdw_Dims,r_vdw_Rank,capi_r_vdw_intent,r_vdw_capi);
  if (capi_r_vdw_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `r_vdw' of lib.mbd.get_single_rpa_energy to C/Fortran array" );
  } else {
    r_vdw = (double *)(PyArray_DATA(capi_r_vdw_tmp));

  /* Processing variable overlap */
  overlap_Dims[0]=size(xyz, 1),overlap_Dims[1]=size(xyz, 1);
  capi_overlap_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_overlap_tmp = array_from_pyobj(NPY_DOUBLE,overlap_Dims,overlap_Rank,capi_overlap_intent,overlap_capi);
  if (capi_overlap_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th keyword `overlap' of lib.mbd.get_single_rpa_energy to C/Fortran array" );
  } else {
    overlap = (double *)(PyArray_DATA(capi_overlap_tmp));

  /* Processing variable c6 */
  c6_Dims[0]=size(xyz, 1);
  capi_c6_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_c6_tmp = array_from_pyobj(NPY_DOUBLE,c6_Dims,c6_Rank,capi_c6_intent,c6_capi);
  if (capi_c6_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th keyword `c6' of lib.mbd.get_single_rpa_energy to C/Fortran array" );
  } else {
    c6 = (double *)(PyArray_DATA(capi_c6_tmp));

  /* Processing variable damping_custom */
  damping_custom_Dims[0]=size(xyz, 1),damping_custom_Dims[1]=size(xyz, 1);
  capi_damping_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_damping_custom_tmp = array_from_pyobj(NPY_DOUBLE,damping_custom_Dims,damping_custom_Rank,capi_damping_custom_intent,damping_custom_capi);
  if (capi_damping_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th keyword `damping_custom' of lib.mbd.get_single_rpa_energy to C/Fortran array" );
  } else {
    damping_custom = (double *)(PyArray_DATA(capi_damping_custom_tmp));

  /* Processing variable potential_custom */
  potential_custom_Dims[0]=size(xyz, 1),potential_custom_Dims[1]=size(xyz, 1),potential_custom_Dims[2]=3,potential_custom_Dims[3]=3;
  capi_potential_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_potential_custom_tmp = array_from_pyobj(NPY_DOUBLE,potential_custom_Dims,potential_custom_Rank,capi_potential_custom_intent,potential_custom_capi);
  if (capi_potential_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 7th keyword `potential_custom' of lib.mbd.get_single_rpa_energy to C/Fortran array" );
  } else {
    potential_custom = (double *)(PyArray_DATA(capi_potential_custom_tmp));

  /* Processing variable get_single_rpa_energy */
  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
  /* Processing variable f2py_alpha_d0 */
  f2py_alpha_d0 = shape(alpha, 0);
  /* Processing variable f2py_alpha_d1 */
  f2py_alpha_d1 = shape(alpha, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_single_rpa_energy,mode,version,xyz,alpha,r_vdw,&beta,&a,overlap,c6,damping_custom,potential_custom,unit_cell,rpa_orders,&f2py_xyz_d0,&f2py_xyz_d1,&f2py_alpha_d0,&f2py_alpha_d1,slen(mode),slen(version));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("dN",get_single_rpa_energy,capi_rpa_orders_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_alpha_d1 */
  /* End of cleaning variable f2py_alpha_d0 */
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  /* End of cleaning variable get_single_rpa_energy */
  if((PyObject *)capi_potential_custom_tmp!=potential_custom_capi) {
    Py_XDECREF(capi_potential_custom_tmp); }
  }  /*if (capi_potential_custom_tmp == NULL) ... else of potential_custom*/
  /* End of cleaning variable potential_custom */
  if((PyObject *)capi_damping_custom_tmp!=damping_custom_capi) {
    Py_XDECREF(capi_damping_custom_tmp); }
  }  /*if (capi_damping_custom_tmp == NULL) ... else of damping_custom*/
  /* End of cleaning variable damping_custom */
  if((PyObject *)capi_c6_tmp!=c6_capi) {
    Py_XDECREF(capi_c6_tmp); }
  }  /*if (capi_c6_tmp == NULL) ... else of c6*/
  /* End of cleaning variable c6 */
  if((PyObject *)capi_overlap_tmp!=overlap_capi) {
    Py_XDECREF(capi_overlap_tmp); }
  }  /*if (capi_overlap_tmp == NULL) ... else of overlap*/
  /* End of cleaning variable overlap */
  if((PyObject *)capi_r_vdw_tmp!=r_vdw_capi) {
    Py_XDECREF(capi_r_vdw_tmp); }
  }  /*if (capi_r_vdw_tmp == NULL) ... else of r_vdw*/
  /* End of cleaning variable r_vdw */
  }  /*if (capi_rpa_orders_tmp == NULL) ... else of rpa_orders*/
  /* End of cleaning variable rpa_orders */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  if((PyObject *)capi_alpha_tmp!=alpha_capi) {
    Py_XDECREF(capi_alpha_tmp); }
  }  /*if (capi_alpha_tmp == NULL) ... else of alpha*/
  /* End of cleaning variable alpha */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(version);
  }  /*if (f2py_success) of version*/
  /* End of cleaning variable version */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of get_single_rpa_energy ************************/

/************************** eval_mbd_nonint_density **************************/
static char doc_f2py_rout_lib_mbd_eval_mbd_nonint_density[] = "\
rho = eval_mbd_nonint_density(pts,xyz,charges,masses,omegas)\n\nWrapper for ``eval_mbd_nonint_density``.\
\n\nParameters\n----------\n"
"pts : input rank-2 array('d') with bounds (f2py_pts_d0,f2py_pts_d1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"charges : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"masses : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"omegas : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"\nReturns\n-------\n"
"rho : rank-1 array('d') with bounds (size(pts, 1)) and eval_mbd_nonint_density storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_eval_mbd_nonint_density(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,double*,double*,int*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *eval_mbd_nonint_density = NULL;
  npy_intp eval_mbd_nonint_density_Dims[1] = {-1};
  const int eval_mbd_nonint_density_Rank = 1;
  PyArrayObject *capi_eval_mbd_nonint_density_tmp = NULL;
  int capi_eval_mbd_nonint_density_intent = 0;
  double *pts = NULL;
  npy_intp pts_Dims[2] = {-1, -1};
  const int pts_Rank = 2;
  PyArrayObject *capi_pts_tmp = NULL;
  int capi_pts_intent = 0;
  PyObject *pts_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *charges = NULL;
  npy_intp charges_Dims[1] = {-1};
  const int charges_Rank = 1;
  PyArrayObject *capi_charges_tmp = NULL;
  int capi_charges_intent = 0;
  PyObject *charges_capi = Py_None;
  double *masses = NULL;
  npy_intp masses_Dims[1] = {-1};
  const int masses_Rank = 1;
  PyArrayObject *capi_masses_tmp = NULL;
  int capi_masses_intent = 0;
  PyObject *masses_capi = Py_None;
  double *omegas = NULL;
  npy_intp omegas_Dims[1] = {-1};
  const int omegas_Rank = 1;
  PyArrayObject *capi_omegas_tmp = NULL;
  int capi_omegas_intent = 0;
  PyObject *omegas_capi = Py_None;
  int f2py_pts_d0 = 0;
  int f2py_pts_d1 = 0;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  static char *capi_kwlist[] = {"pts","xyz","charges","masses","omegas",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO:lib.mbd.eval_mbd_nonint_density",\
    capi_kwlist,&pts_capi,&xyz_capi,&charges_capi,&masses_capi,&omegas_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable pts */
  ;
  capi_pts_intent |= F2PY_INTENT_IN;
  capi_pts_tmp = array_from_pyobj(NPY_DOUBLE,pts_Dims,pts_Rank,capi_pts_intent,pts_capi);
  if (capi_pts_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `pts' of lib.mbd.eval_mbd_nonint_density to C/Fortran array" );
  } else {
    pts = (double *)(PyArray_DATA(capi_pts_tmp));

  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `xyz' of lib.mbd.eval_mbd_nonint_density to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable charges */
  charges_Dims[0]=size(xyz, 1);
  capi_charges_intent |= F2PY_INTENT_IN;
  capi_charges_tmp = array_from_pyobj(NPY_DOUBLE,charges_Dims,charges_Rank,capi_charges_intent,charges_capi);
  if (capi_charges_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `charges' of lib.mbd.eval_mbd_nonint_density to C/Fortran array" );
  } else {
    charges = (double *)(PyArray_DATA(capi_charges_tmp));

  /* Processing variable masses */
  masses_Dims[0]=size(xyz, 1);
  capi_masses_intent |= F2PY_INTENT_IN;
  capi_masses_tmp = array_from_pyobj(NPY_DOUBLE,masses_Dims,masses_Rank,capi_masses_intent,masses_capi);
  if (capi_masses_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `masses' of lib.mbd.eval_mbd_nonint_density to C/Fortran array" );
  } else {
    masses = (double *)(PyArray_DATA(capi_masses_tmp));

  /* Processing variable omegas */
  omegas_Dims[0]=size(xyz, 1);
  capi_omegas_intent |= F2PY_INTENT_IN;
  capi_omegas_tmp = array_from_pyobj(NPY_DOUBLE,omegas_Dims,omegas_Rank,capi_omegas_intent,omegas_capi);
  if (capi_omegas_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `omegas' of lib.mbd.eval_mbd_nonint_density to C/Fortran array" );
  } else {
    omegas = (double *)(PyArray_DATA(capi_omegas_tmp));

  /* Processing variable eval_mbd_nonint_density */
  eval_mbd_nonint_density_Dims[0]=size(pts, 1);
  capi_eval_mbd_nonint_density_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_eval_mbd_nonint_density_tmp = array_from_pyobj(NPY_DOUBLE,eval_mbd_nonint_density_Dims,eval_mbd_nonint_density_Rank,capi_eval_mbd_nonint_density_intent,Py_None);
  if (capi_eval_mbd_nonint_density_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `eval_mbd_nonint_density' of lib.mbd.eval_mbd_nonint_density to C/Fortran array" );
  } else {
    eval_mbd_nonint_density = (double *)(PyArray_DATA(capi_eval_mbd_nonint_density_tmp));

  /* Processing variable f2py_pts_d0 */
  f2py_pts_d0 = shape(pts, 0);
  /* Processing variable f2py_pts_d1 */
  f2py_pts_d1 = shape(pts, 1);
  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(eval_mbd_nonint_density,pts,xyz,charges,masses,omegas,&f2py_pts_d0,&f2py_pts_d1,&f2py_xyz_d0,&f2py_xyz_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_eval_mbd_nonint_density_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  /* End of cleaning variable f2py_pts_d1 */
  /* End of cleaning variable f2py_pts_d0 */
  }  /*if (capi_eval_mbd_nonint_density_tmp == NULL) ... else of eval_mbd_nonint_density*/
  /* End of cleaning variable eval_mbd_nonint_density */
  if((PyObject *)capi_omegas_tmp!=omegas_capi) {
    Py_XDECREF(capi_omegas_tmp); }
  }  /*if (capi_omegas_tmp == NULL) ... else of omegas*/
  /* End of cleaning variable omegas */
  if((PyObject *)capi_masses_tmp!=masses_capi) {
    Py_XDECREF(capi_masses_tmp); }
  }  /*if (capi_masses_tmp == NULL) ... else of masses*/
  /* End of cleaning variable masses */
  if((PyObject *)capi_charges_tmp!=charges_capi) {
    Py_XDECREF(capi_charges_tmp); }
  }  /*if (capi_charges_tmp == NULL) ... else of charges*/
  /* End of cleaning variable charges */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
  if((PyObject *)capi_pts_tmp!=pts_capi) {
    Py_XDECREF(capi_pts_tmp); }
  }  /*if (capi_pts_tmp == NULL) ... else of pts*/
  /* End of cleaning variable pts */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*********************** end of eval_mbd_nonint_density ***********************/

/**************************** eval_mbd_int_density ****************************/
static char doc_f2py_rout_lib_mbd_eval_mbd_int_density[] = "\
rho = eval_mbd_int_density(pts,xyz,charges,masses,omegas,modes)\n\nWrapper for ``eval_mbd_int_density``.\
\n\nParameters\n----------\n"
"pts : input rank-2 array('d') with bounds (f2py_pts_d0,f2py_pts_d1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"charges : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"masses : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"omegas : input rank-1 array('d') with bounds (3*size(xyz, 1))\n"
"modes : input rank-2 array('d') with bounds (3*size(xyz, 1),3*size(xyz, 1))\n"
"\nReturns\n-------\n"
"rho : rank-1 array('d') with bounds (size(pts, 1)) and eval_mbd_int_density storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_eval_mbd_int_density(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,double*,double*,double*,int*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *eval_mbd_int_density = NULL;
  npy_intp eval_mbd_int_density_Dims[1] = {-1};
  const int eval_mbd_int_density_Rank = 1;
  PyArrayObject *capi_eval_mbd_int_density_tmp = NULL;
  int capi_eval_mbd_int_density_intent = 0;
  double *pts = NULL;
  npy_intp pts_Dims[2] = {-1, -1};
  const int pts_Rank = 2;
  PyArrayObject *capi_pts_tmp = NULL;
  int capi_pts_intent = 0;
  PyObject *pts_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *charges = NULL;
  npy_intp charges_Dims[1] = {-1};
  const int charges_Rank = 1;
  PyArrayObject *capi_charges_tmp = NULL;
  int capi_charges_intent = 0;
  PyObject *charges_capi = Py_None;
  double *masses = NULL;
  npy_intp masses_Dims[1] = {-1};
  const int masses_Rank = 1;
  PyArrayObject *capi_masses_tmp = NULL;
  int capi_masses_intent = 0;
  PyObject *masses_capi = Py_None;
  double *omegas = NULL;
  npy_intp omegas_Dims[1] = {-1};
  const int omegas_Rank = 1;
  PyArrayObject *capi_omegas_tmp = NULL;
  int capi_omegas_intent = 0;
  PyObject *omegas_capi = Py_None;
  double *modes = NULL;
  npy_intp modes_Dims[2] = {-1, -1};
  const int modes_Rank = 2;
  PyArrayObject *capi_modes_tmp = NULL;
  int capi_modes_intent = 0;
  PyObject *modes_capi = Py_None;
  int f2py_pts_d0 = 0;
  int f2py_pts_d1 = 0;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  static char *capi_kwlist[] = {"pts","xyz","charges","masses","omegas","modes",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOO:lib.mbd.eval_mbd_int_density",\
    capi_kwlist,&pts_capi,&xyz_capi,&charges_capi,&masses_capi,&omegas_capi,&modes_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable pts */
  ;
  capi_pts_intent |= F2PY_INTENT_IN;
  capi_pts_tmp = array_from_pyobj(NPY_DOUBLE,pts_Dims,pts_Rank,capi_pts_intent,pts_capi);
  if (capi_pts_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `pts' of lib.mbd.eval_mbd_int_density to C/Fortran array" );
  } else {
    pts = (double *)(PyArray_DATA(capi_pts_tmp));

  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `xyz' of lib.mbd.eval_mbd_int_density to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable charges */
  charges_Dims[0]=size(xyz, 1);
  capi_charges_intent |= F2PY_INTENT_IN;
  capi_charges_tmp = array_from_pyobj(NPY_DOUBLE,charges_Dims,charges_Rank,capi_charges_intent,charges_capi);
  if (capi_charges_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `charges' of lib.mbd.eval_mbd_int_density to C/Fortran array" );
  } else {
    charges = (double *)(PyArray_DATA(capi_charges_tmp));

  /* Processing variable masses */
  masses_Dims[0]=size(xyz, 1);
  capi_masses_intent |= F2PY_INTENT_IN;
  capi_masses_tmp = array_from_pyobj(NPY_DOUBLE,masses_Dims,masses_Rank,capi_masses_intent,masses_capi);
  if (capi_masses_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `masses' of lib.mbd.eval_mbd_int_density to C/Fortran array" );
  } else {
    masses = (double *)(PyArray_DATA(capi_masses_tmp));

  /* Processing variable omegas */
  omegas_Dims[0]=3*size(xyz, 1);
  capi_omegas_intent |= F2PY_INTENT_IN;
  capi_omegas_tmp = array_from_pyobj(NPY_DOUBLE,omegas_Dims,omegas_Rank,capi_omegas_intent,omegas_capi);
  if (capi_omegas_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `omegas' of lib.mbd.eval_mbd_int_density to C/Fortran array" );
  } else {
    omegas = (double *)(PyArray_DATA(capi_omegas_tmp));

  /* Processing variable modes */
  modes_Dims[0]=3*size(xyz, 1),modes_Dims[1]=3*size(xyz, 1);
  capi_modes_intent |= F2PY_INTENT_IN;
  capi_modes_tmp = array_from_pyobj(NPY_DOUBLE,modes_Dims,modes_Rank,capi_modes_intent,modes_capi);
  if (capi_modes_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th argument `modes' of lib.mbd.eval_mbd_int_density to C/Fortran array" );
  } else {
    modes = (double *)(PyArray_DATA(capi_modes_tmp));

  /* Processing variable eval_mbd_int_density */
  eval_mbd_int_density_Dims[0]=size(pts, 1);
  capi_eval_mbd_int_density_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_eval_mbd_int_density_tmp = array_from_pyobj(NPY_DOUBLE,eval_mbd_int_density_Dims,eval_mbd_int_density_Rank,capi_eval_mbd_int_density_intent,Py_None);
  if (capi_eval_mbd_int_density_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `eval_mbd_int_density' of lib.mbd.eval_mbd_int_density to C/Fortran array" );
  } else {
    eval_mbd_int_density = (double *)(PyArray_DATA(capi_eval_mbd_int_density_tmp));

  /* Processing variable f2py_pts_d0 */
  f2py_pts_d0 = shape(pts, 0);
  /* Processing variable f2py_pts_d1 */
  f2py_pts_d1 = shape(pts, 1);
  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(eval_mbd_int_density,pts,xyz,charges,masses,omegas,modes,&f2py_pts_d0,&f2py_pts_d1,&f2py_xyz_d0,&f2py_xyz_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_eval_mbd_int_density_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  /* End of cleaning variable f2py_pts_d1 */
  /* End of cleaning variable f2py_pts_d0 */
  }  /*if (capi_eval_mbd_int_density_tmp == NULL) ... else of eval_mbd_int_density*/
  /* End of cleaning variable eval_mbd_int_density */
  if((PyObject *)capi_modes_tmp!=modes_capi) {
    Py_XDECREF(capi_modes_tmp); }
  }  /*if (capi_modes_tmp == NULL) ... else of modes*/
  /* End of cleaning variable modes */
  if((PyObject *)capi_omegas_tmp!=omegas_capi) {
    Py_XDECREF(capi_omegas_tmp); }
  }  /*if (capi_omegas_tmp == NULL) ... else of omegas*/
  /* End of cleaning variable omegas */
  if((PyObject *)capi_masses_tmp!=masses_capi) {
    Py_XDECREF(capi_masses_tmp); }
  }  /*if (capi_masses_tmp == NULL) ... else of masses*/
  /* End of cleaning variable masses */
  if((PyObject *)capi_charges_tmp!=charges_capi) {
    Py_XDECREF(capi_charges_tmp); }
  }  /*if (capi_charges_tmp == NULL) ... else of charges*/
  /* End of cleaning variable charges */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
  if((PyObject *)capi_pts_tmp!=pts_capi) {
    Py_XDECREF(capi_pts_tmp); }
  }  /*if (capi_pts_tmp == NULL) ... else of pts*/
  /* End of cleaning variable pts */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of eval_mbd_int_density ************************/

/*********************** get_single_reciprocal_rpa_ene ***********************/
static char doc_f2py_rout_lib_mbd_get_single_reciprocal_rpa_ene[] = "\
ene,rpa_orders = get_single_reciprocal_rpa_ene(mode,version,xyz,alpha,k_point,unit_cell,[r_vdw,beta,a,overlap,c6,damping_custom,potential_custom])\n\nWrapper for ``get_single_reciprocal_rpa_ene``.\
\n\nParameters\n----------\n"
"mode : input string(len=-1)\n"
"version : input string(len=-1)\n"
"xyz : input rank-2 array('d') with bounds (f2py_xyz_d0,f2py_xyz_d1)\n"
"alpha : input rank-2 array('d') with bounds (f2py_alpha_d0,f2py_alpha_d1)\n"
"k_point : input rank-1 array('d') with bounds (3)\n"
"unit_cell : input rank-2 array('d') with bounds (3,3)\n"
"\nOther Parameters\n----------------\n"
"r_vdw : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"beta : input float\n"
"a : input float\n"
"overlap : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"c6 : input rank-1 array('d') with bounds (size(xyz, 1))\n"
"damping_custom : input rank-2 array('d') with bounds (size(xyz, 1),size(xyz, 1))\n"
"potential_custom : input rank-4 array('d') with bounds (size(xyz, 1),size(xyz, 1),3,3)\n"
"\nReturns\n-------\n"
"ene : float\n"
"rpa_orders : rank-1 array('d') with bounds (20)";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_single_reciprocal_rpa_ene(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,string,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,int*,int*,int*,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double get_single_reciprocal_rpa_ene = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  string version = NULL;
  int slen(version);
  PyObject *version_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[2] = {-1, -1};
  const int xyz_Rank = 2;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double *alpha = NULL;
  npy_intp alpha_Dims[2] = {-1, -1};
  const int alpha_Rank = 2;
  PyArrayObject *capi_alpha_tmp = NULL;
  int capi_alpha_intent = 0;
  PyObject *alpha_capi = Py_None;
  double *k_point = NULL;
  npy_intp k_point_Dims[1] = {-1};
  const int k_point_Rank = 1;
  PyArrayObject *capi_k_point_tmp = NULL;
  int capi_k_point_intent = 0;
  PyObject *k_point_capi = Py_None;
  double *unit_cell = NULL;
  npy_intp unit_cell_Dims[2] = {-1, -1};
  const int unit_cell_Rank = 2;
  PyArrayObject *capi_unit_cell_tmp = NULL;
  int capi_unit_cell_intent = 0;
  PyObject *unit_cell_capi = Py_None;
  double *r_vdw = NULL;
  npy_intp r_vdw_Dims[1] = {-1};
  const int r_vdw_Rank = 1;
  PyArrayObject *capi_r_vdw_tmp = NULL;
  int capi_r_vdw_intent = 0;
  PyObject *r_vdw_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  double *overlap = NULL;
  npy_intp overlap_Dims[2] = {-1, -1};
  const int overlap_Rank = 2;
  PyArrayObject *capi_overlap_tmp = NULL;
  int capi_overlap_intent = 0;
  PyObject *overlap_capi = Py_None;
  double *c6 = NULL;
  npy_intp c6_Dims[1] = {-1};
  const int c6_Rank = 1;
  PyArrayObject *capi_c6_tmp = NULL;
  int capi_c6_intent = 0;
  PyObject *c6_capi = Py_None;
  double *damping_custom = NULL;
  npy_intp damping_custom_Dims[2] = {-1, -1};
  const int damping_custom_Rank = 2;
  PyArrayObject *capi_damping_custom_tmp = NULL;
  int capi_damping_custom_intent = 0;
  PyObject *damping_custom_capi = Py_None;
  double *potential_custom = NULL;
  npy_intp potential_custom_Dims[4] = {-1, -1, -1, -1};
  const int potential_custom_Rank = 4;
  PyArrayObject *capi_potential_custom_tmp = NULL;
  int capi_potential_custom_intent = 0;
  PyObject *potential_custom_capi = Py_None;
  double *rpa_orders = NULL;
  npy_intp rpa_orders_Dims[1] = {-1};
  const int rpa_orders_Rank = 1;
  PyArrayObject *capi_rpa_orders_tmp = NULL;
  int capi_rpa_orders_intent = 0;
  int f2py_xyz_d0 = 0;
  int f2py_xyz_d1 = 0;
  int f2py_alpha_d0 = 0;
  int f2py_alpha_d1 = 0;
  static char *capi_kwlist[] = {"mode","version","xyz","alpha","k_point","unit_cell","r_vdw","beta","a","overlap","c6","damping_custom","potential_custom",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOO|OOOOOOO:lib.mbd.get_single_reciprocal_rpa_ene",\
    capi_kwlist,&mode_capi,&version_capi,&xyz_capi,&alpha_capi,&k_point_capi,&unit_cell_capi,&r_vdw_capi,&beta_capi,&a_capi,&overlap_capi,&c6_capi,&damping_custom_capi,&potential_custom_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = -1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.get_single_reciprocal_rpa_ene to C string");
  if (f2py_success) {
  /* Processing variable version */
  slen(version) = -1;
  f2py_success = string_from_pyobj(&version,&slen(version),"",version_capi,"string_from_pyobj failed in converting 2nd argument `version' of lib.mbd.get_single_reciprocal_rpa_ene to C string");
  if (f2py_success) {
  /* Processing variable xyz */
  ;
  capi_xyz_intent |= F2PY_INTENT_IN;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `xyz' of lib.mbd.get_single_reciprocal_rpa_ene to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

  /* Processing variable alpha */
  ;
  capi_alpha_intent |= F2PY_INTENT_IN;
  capi_alpha_tmp = array_from_pyobj(NPY_DOUBLE,alpha_Dims,alpha_Rank,capi_alpha_intent,alpha_capi);
  if (capi_alpha_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `alpha' of lib.mbd.get_single_reciprocal_rpa_ene to C/Fortran array" );
  } else {
    alpha = (double *)(PyArray_DATA(capi_alpha_tmp));

  /* Processing variable k_point */
  k_point_Dims[0]=3;
  capi_k_point_intent |= F2PY_INTENT_IN;
  capi_k_point_tmp = array_from_pyobj(NPY_DOUBLE,k_point_Dims,k_point_Rank,capi_k_point_intent,k_point_capi);
  if (capi_k_point_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `k_point' of lib.mbd.get_single_reciprocal_rpa_ene to C/Fortran array" );
  } else {
    k_point = (double *)(PyArray_DATA(capi_k_point_tmp));

  /* Processing variable unit_cell */
  unit_cell_Dims[0]=3,unit_cell_Dims[1]=3;
  capi_unit_cell_intent |= F2PY_INTENT_IN;
  capi_unit_cell_tmp = array_from_pyobj(NPY_DOUBLE,unit_cell_Dims,unit_cell_Rank,capi_unit_cell_intent,unit_cell_capi);
  if (capi_unit_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th argument `unit_cell' of lib.mbd.get_single_reciprocal_rpa_ene to C/Fortran array" );
  } else {
    unit_cell = (double *)(PyArray_DATA(capi_unit_cell_tmp));

  /* Processing variable beta */
  if (beta_capi != Py_None)
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.get_single_reciprocal_rpa_ene() 2nd keyword (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
  if (a_capi != Py_None)
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.get_single_reciprocal_rpa_ene() 3rd keyword (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable rpa_orders */
  rpa_orders_Dims[0]=20;
  capi_rpa_orders_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_rpa_orders_tmp = array_from_pyobj(NPY_DOUBLE,rpa_orders_Dims,rpa_orders_Rank,capi_rpa_orders_intent,Py_None);
  if (capi_rpa_orders_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `rpa_orders' of lib.mbd.get_single_reciprocal_rpa_ene to C/Fortran array" );
  } else {
    rpa_orders = (double *)(PyArray_DATA(capi_rpa_orders_tmp));

  /* Processing variable r_vdw */
  r_vdw_Dims[0]=size(xyz, 1);
  capi_r_vdw_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_r_vdw_tmp = array_from_pyobj(NPY_DOUBLE,r_vdw_Dims,r_vdw_Rank,capi_r_vdw_intent,r_vdw_capi);
  if (capi_r_vdw_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `r_vdw' of lib.mbd.get_single_reciprocal_rpa_ene to C/Fortran array" );
  } else {
    r_vdw = (double *)(PyArray_DATA(capi_r_vdw_tmp));

  /* Processing variable overlap */
  overlap_Dims[0]=size(xyz, 1),overlap_Dims[1]=size(xyz, 1);
  capi_overlap_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_overlap_tmp = array_from_pyobj(NPY_DOUBLE,overlap_Dims,overlap_Rank,capi_overlap_intent,overlap_capi);
  if (capi_overlap_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th keyword `overlap' of lib.mbd.get_single_reciprocal_rpa_ene to C/Fortran array" );
  } else {
    overlap = (double *)(PyArray_DATA(capi_overlap_tmp));

  /* Processing variable c6 */
  c6_Dims[0]=size(xyz, 1);
  capi_c6_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_c6_tmp = array_from_pyobj(NPY_DOUBLE,c6_Dims,c6_Rank,capi_c6_intent,c6_capi);
  if (capi_c6_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th keyword `c6' of lib.mbd.get_single_reciprocal_rpa_ene to C/Fortran array" );
  } else {
    c6 = (double *)(PyArray_DATA(capi_c6_tmp));

  /* Processing variable damping_custom */
  damping_custom_Dims[0]=size(xyz, 1),damping_custom_Dims[1]=size(xyz, 1);
  capi_damping_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_damping_custom_tmp = array_from_pyobj(NPY_DOUBLE,damping_custom_Dims,damping_custom_Rank,capi_damping_custom_intent,damping_custom_capi);
  if (capi_damping_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th keyword `damping_custom' of lib.mbd.get_single_reciprocal_rpa_ene to C/Fortran array" );
  } else {
    damping_custom = (double *)(PyArray_DATA(capi_damping_custom_tmp));

  /* Processing variable potential_custom */
  potential_custom_Dims[0]=size(xyz, 1),potential_custom_Dims[1]=size(xyz, 1),potential_custom_Dims[2]=3,potential_custom_Dims[3]=3;
  capi_potential_custom_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_potential_custom_tmp = array_from_pyobj(NPY_DOUBLE,potential_custom_Dims,potential_custom_Rank,capi_potential_custom_intent,potential_custom_capi);
  if (capi_potential_custom_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 7th keyword `potential_custom' of lib.mbd.get_single_reciprocal_rpa_ene to C/Fortran array" );
  } else {
    potential_custom = (double *)(PyArray_DATA(capi_potential_custom_tmp));

  /* Processing variable get_single_reciprocal_rpa_ene */
  /* Processing variable f2py_xyz_d0 */
  f2py_xyz_d0 = shape(xyz, 0);
  /* Processing variable f2py_xyz_d1 */
  f2py_xyz_d1 = shape(xyz, 1);
  /* Processing variable f2py_alpha_d0 */
  f2py_alpha_d0 = shape(alpha, 0);
  /* Processing variable f2py_alpha_d1 */
  f2py_alpha_d1 = shape(alpha, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_single_reciprocal_rpa_ene,mode,version,xyz,alpha,k_point,unit_cell,r_vdw,&beta,&a,overlap,c6,damping_custom,potential_custom,rpa_orders,&f2py_xyz_d0,&f2py_xyz_d1,&f2py_alpha_d0,&f2py_alpha_d1,slen(mode),slen(version));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("dN",get_single_reciprocal_rpa_ene,capi_rpa_orders_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_alpha_d1 */
  /* End of cleaning variable f2py_alpha_d0 */
  /* End of cleaning variable f2py_xyz_d1 */
  /* End of cleaning variable f2py_xyz_d0 */
  /* End of cleaning variable get_single_reciprocal_rpa_ene */
  if((PyObject *)capi_potential_custom_tmp!=potential_custom_capi) {
    Py_XDECREF(capi_potential_custom_tmp); }
  }  /*if (capi_potential_custom_tmp == NULL) ... else of potential_custom*/
  /* End of cleaning variable potential_custom */
  if((PyObject *)capi_damping_custom_tmp!=damping_custom_capi) {
    Py_XDECREF(capi_damping_custom_tmp); }
  }  /*if (capi_damping_custom_tmp == NULL) ... else of damping_custom*/
  /* End of cleaning variable damping_custom */
  if((PyObject *)capi_c6_tmp!=c6_capi) {
    Py_XDECREF(capi_c6_tmp); }
  }  /*if (capi_c6_tmp == NULL) ... else of c6*/
  /* End of cleaning variable c6 */
  if((PyObject *)capi_overlap_tmp!=overlap_capi) {
    Py_XDECREF(capi_overlap_tmp); }
  }  /*if (capi_overlap_tmp == NULL) ... else of overlap*/
  /* End of cleaning variable overlap */
  if((PyObject *)capi_r_vdw_tmp!=r_vdw_capi) {
    Py_XDECREF(capi_r_vdw_tmp); }
  }  /*if (capi_r_vdw_tmp == NULL) ... else of r_vdw*/
  /* End of cleaning variable r_vdw */
  }  /*if (capi_rpa_orders_tmp == NULL) ... else of rpa_orders*/
  /* End of cleaning variable rpa_orders */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  if((PyObject *)capi_unit_cell_tmp!=unit_cell_capi) {
    Py_XDECREF(capi_unit_cell_tmp); }
  }  /*if (capi_unit_cell_tmp == NULL) ... else of unit_cell*/
  /* End of cleaning variable unit_cell */
  if((PyObject *)capi_k_point_tmp!=k_point_capi) {
    Py_XDECREF(capi_k_point_tmp); }
  }  /*if (capi_k_point_tmp == NULL) ... else of k_point*/
  /* End of cleaning variable k_point */
  if((PyObject *)capi_alpha_tmp!=alpha_capi) {
    Py_XDECREF(capi_alpha_tmp); }
  }  /*if (capi_alpha_tmp == NULL) ... else of alpha*/
  /* End of cleaning variable alpha */
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
    STRINGFREE(version);
  }  /*if (f2py_success) of version*/
  /* End of cleaning variable version */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************** end of get_single_reciprocal_rpa_ene ********************/

/******************************** make_g_grid ********************************/
static char doc_f2py_rout_lib_mbd_make_g_grid[] = "\
g_grid = make_g_grid(n1,n2,n3)\n\nWrapper for ``make_g_grid``.\
\n\nParameters\n----------\n"
"n1 : input int\n"
"n2 : input int\n"
"n3 : input int\n"
"\nReturns\n-------\n"
"g_grid : rank-2 array('d') with bounds (n1*n2*n3,3) and make_g_grid storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_make_g_grid(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *make_g_grid = NULL;
  npy_intp make_g_grid_Dims[2] = {-1, -1};
  const int make_g_grid_Rank = 2;
  PyArrayObject *capi_make_g_grid_tmp = NULL;
  int capi_make_g_grid_intent = 0;
  int n1 = 0;
  PyObject *n1_capi = Py_None;
  int n2 = 0;
  PyObject *n2_capi = Py_None;
  int n3 = 0;
  PyObject *n3_capi = Py_None;
  static char *capi_kwlist[] = {"n1","n2","n3",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd.make_g_grid",\
    capi_kwlist,&n1_capi,&n2_capi,&n3_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable n1 */
    f2py_success = int_from_pyobj(&n1,n1_capi,"lib.mbd.make_g_grid() 1st argument (n1) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n2 */
    f2py_success = int_from_pyobj(&n2,n2_capi,"lib.mbd.make_g_grid() 2nd argument (n2) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n3 */
    f2py_success = int_from_pyobj(&n3,n3_capi,"lib.mbd.make_g_grid() 3rd argument (n3) can't be converted to int");
  if (f2py_success) {
  /* Processing variable make_g_grid */
  make_g_grid_Dims[0]=n1*n2*n3,make_g_grid_Dims[1]=3;
  capi_make_g_grid_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_make_g_grid_tmp = array_from_pyobj(NPY_DOUBLE,make_g_grid_Dims,make_g_grid_Rank,capi_make_g_grid_intent,Py_None);
  if (capi_make_g_grid_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `make_g_grid' of lib.mbd.make_g_grid to C/Fortran array" );
  } else {
    make_g_grid = (double *)(PyArray_DATA(capi_make_g_grid_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(make_g_grid,&n1,&n2,&n3);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_make_g_grid_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_make_g_grid_tmp == NULL) ... else of make_g_grid*/
  /* End of cleaning variable make_g_grid */
  } /*if (f2py_success) of n3*/
  /* End of cleaning variable n3 */
  } /*if (f2py_success) of n2*/
  /* End of cleaning variable n2 */
  } /*if (f2py_success) of n1*/
  /* End of cleaning variable n1 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of make_g_grid *****************************/

/******************************** make_k_grid ********************************/
static char doc_f2py_rout_lib_mbd_make_k_grid[] = "\
k_grid = make_k_grid(g_grid,uc)\n\nWrapper for ``make_k_grid``.\
\n\nParameters\n----------\n"
"g_grid : input rank-2 array('d') with bounds (f2py_g_grid_d0,f2py_g_grid_d1)\n"
"uc : input rank-2 array('d') with bounds (3,3)\n"
"\nReturns\n-------\n"
"k_grid : rank-2 array('d') with bounds (size(g_grid, 1),3) and make_k_grid storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_make_k_grid(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *make_k_grid = NULL;
  npy_intp make_k_grid_Dims[2] = {-1, -1};
  const int make_k_grid_Rank = 2;
  PyArrayObject *capi_make_k_grid_tmp = NULL;
  int capi_make_k_grid_intent = 0;
  double *g_grid = NULL;
  npy_intp g_grid_Dims[2] = {-1, -1};
  const int g_grid_Rank = 2;
  PyArrayObject *capi_g_grid_tmp = NULL;
  int capi_g_grid_intent = 0;
  PyObject *g_grid_capi = Py_None;
  double *uc = NULL;
  npy_intp uc_Dims[2] = {-1, -1};
  const int uc_Rank = 2;
  PyArrayObject *capi_uc_tmp = NULL;
  int capi_uc_intent = 0;
  PyObject *uc_capi = Py_None;
  int f2py_g_grid_d0 = 0;
  int f2py_g_grid_d1 = 0;
  static char *capi_kwlist[] = {"g_grid","uc",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.make_k_grid",\
    capi_kwlist,&g_grid_capi,&uc_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable g_grid */
  ;
  capi_g_grid_intent |= F2PY_INTENT_IN;
  capi_g_grid_tmp = array_from_pyobj(NPY_DOUBLE,g_grid_Dims,g_grid_Rank,capi_g_grid_intent,g_grid_capi);
  if (capi_g_grid_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `g_grid' of lib.mbd.make_k_grid to C/Fortran array" );
  } else {
    g_grid = (double *)(PyArray_DATA(capi_g_grid_tmp));

  /* Processing variable uc */
  uc_Dims[0]=3,uc_Dims[1]=3;
  capi_uc_intent |= F2PY_INTENT_IN;
  capi_uc_tmp = array_from_pyobj(NPY_DOUBLE,uc_Dims,uc_Rank,capi_uc_intent,uc_capi);
  if (capi_uc_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `uc' of lib.mbd.make_k_grid to C/Fortran array" );
  } else {
    uc = (double *)(PyArray_DATA(capi_uc_tmp));

  /* Processing variable make_k_grid */
  make_k_grid_Dims[0]=size(g_grid, 1),make_k_grid_Dims[1]=3;
  capi_make_k_grid_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_make_k_grid_tmp = array_from_pyobj(NPY_DOUBLE,make_k_grid_Dims,make_k_grid_Rank,capi_make_k_grid_intent,Py_None);
  if (capi_make_k_grid_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `make_k_grid' of lib.mbd.make_k_grid to C/Fortran array" );
  } else {
    make_k_grid = (double *)(PyArray_DATA(capi_make_k_grid_tmp));

  /* Processing variable f2py_g_grid_d0 */
  f2py_g_grid_d0 = shape(g_grid, 0);
  /* Processing variable f2py_g_grid_d1 */
  f2py_g_grid_d1 = shape(g_grid, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(make_k_grid,g_grid,uc,&f2py_g_grid_d0,&f2py_g_grid_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_make_k_grid_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_g_grid_d1 */
  /* End of cleaning variable f2py_g_grid_d0 */
  }  /*if (capi_make_k_grid_tmp == NULL) ... else of make_k_grid*/
  /* End of cleaning variable make_k_grid */
  if((PyObject *)capi_uc_tmp!=uc_capi) {
    Py_XDECREF(capi_uc_tmp); }
  }  /*if (capi_uc_tmp == NULL) ... else of uc*/
  /* End of cleaning variable uc */
  if((PyObject *)capi_g_grid_tmp!=g_grid_capi) {
    Py_XDECREF(capi_g_grid_tmp); }
  }  /*if (capi_g_grid_tmp == NULL) ... else of g_grid*/
  /* End of cleaning variable g_grid */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of make_k_grid *****************************/

/******************************** nbody_coeffs ********************************/
static char doc_f2py_rout_lib_mbd_nbody_coeffs[] = "\
a = nbody_coeffs(k,m,n)\n\nWrapper for ``nbody_coeffs``.\
\n\nParameters\n----------\n"
"k : input int\n"
"m : input int\n"
"n : input int\n"
"\nReturns\n-------\n"
"a : int";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_nbody_coeffs(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int nbody_coeffs = 0;
  int k = 0;
  PyObject *k_capi = Py_None;
  int m = 0;
  PyObject *m_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  static char *capi_kwlist[] = {"k","m","n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd.nbody_coeffs",\
    capi_kwlist,&k_capi,&m_capi,&n_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable k */
    f2py_success = int_from_pyobj(&k,k_capi,"lib.mbd.nbody_coeffs() 1st argument (k) can't be converted to int");
  if (f2py_success) {
  /* Processing variable m */
    f2py_success = int_from_pyobj(&m,m_capi,"lib.mbd.nbody_coeffs() 2nd argument (m) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n */
    f2py_success = int_from_pyobj(&n,n_capi,"lib.mbd.nbody_coeffs() 3rd argument (n) can't be converted to int");
  if (f2py_success) {
  /* Processing variable nbody_coeffs */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&nbody_coeffs,&k,&m,&n);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("i",nbody_coeffs);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable nbody_coeffs */
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  } /*if (f2py_success) of m*/
  /* End of cleaning variable m */
  } /*if (f2py_success) of k*/
  /* End of cleaning variable k */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of nbody_coeffs ****************************/

/************************** contract_polarizability **************************/
static char doc_f2py_rout_lib_mbd_contract_polarizability[] = "\
alpha_n = contract_polarizability(alpha_3n_3n)\n\nWrapper for ``contract_polarizability``.\
\n\nParameters\n----------\n"
"alpha_3n_3n : input rank-2 array('d') with bounds (f2py_alpha_3n_3n_d0,f2py_alpha_3n_3n_d1)\n"
"\nReturns\n-------\n"
"alpha_n : rank-1 array('d') with bounds (size(alpha_3n_3n, 1)/3) and contract_polarizability storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_contract_polarizability(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *contract_polarizability = NULL;
  npy_intp contract_polarizability_Dims[1] = {-1};
  const int contract_polarizability_Rank = 1;
  PyArrayObject *capi_contract_polarizability_tmp = NULL;
  int capi_contract_polarizability_intent = 0;
  double *alpha_3n_3n = NULL;
  npy_intp alpha_3n_3n_Dims[2] = {-1, -1};
  const int alpha_3n_3n_Rank = 2;
  PyArrayObject *capi_alpha_3n_3n_tmp = NULL;
  int capi_alpha_3n_3n_intent = 0;
  PyObject *alpha_3n_3n_capi = Py_None;
  int f2py_alpha_3n_3n_d0 = 0;
  int f2py_alpha_3n_3n_d1 = 0;
  static char *capi_kwlist[] = {"alpha_3n_3n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.contract_polarizability",\
    capi_kwlist,&alpha_3n_3n_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable alpha_3n_3n */
  ;
  capi_alpha_3n_3n_intent |= F2PY_INTENT_IN;
  capi_alpha_3n_3n_tmp = array_from_pyobj(NPY_DOUBLE,alpha_3n_3n_Dims,alpha_3n_3n_Rank,capi_alpha_3n_3n_intent,alpha_3n_3n_capi);
  if (capi_alpha_3n_3n_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `alpha_3n_3n' of lib.mbd.contract_polarizability to C/Fortran array" );
  } else {
    alpha_3n_3n = (double *)(PyArray_DATA(capi_alpha_3n_3n_tmp));

  /* Processing variable contract_polarizability */
  contract_polarizability_Dims[0]=size(alpha_3n_3n, 1)/3;
  capi_contract_polarizability_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_contract_polarizability_tmp = array_from_pyobj(NPY_DOUBLE,contract_polarizability_Dims,contract_polarizability_Rank,capi_contract_polarizability_intent,Py_None);
  if (capi_contract_polarizability_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `contract_polarizability' of lib.mbd.contract_polarizability to C/Fortran array" );
  } else {
    contract_polarizability = (double *)(PyArray_DATA(capi_contract_polarizability_tmp));

  /* Processing variable f2py_alpha_3n_3n_d0 */
  f2py_alpha_3n_3n_d0 = shape(alpha_3n_3n, 0);
  /* Processing variable f2py_alpha_3n_3n_d1 */
  f2py_alpha_3n_3n_d1 = shape(alpha_3n_3n, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(contract_polarizability,alpha_3n_3n,&f2py_alpha_3n_3n_d0,&f2py_alpha_3n_3n_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_contract_polarizability_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_alpha_3n_3n_d1 */
  /* End of cleaning variable f2py_alpha_3n_3n_d0 */
  }  /*if (capi_contract_polarizability_tmp == NULL) ... else of contract_polarizability*/
  /* End of cleaning variable contract_polarizability */
  if((PyObject *)capi_alpha_3n_3n_tmp!=alpha_3n_3n_capi) {
    Py_XDECREF(capi_alpha_3n_3n_tmp); }
  }  /*if (capi_alpha_3n_3n_tmp == NULL) ... else of alpha_3n_3n*/
  /* End of cleaning variable alpha_3n_3n */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*********************** end of contract_polarizability ***********************/

/******************************* get_omega_grid *******************************/
static char doc_f2py_rout_lib_mbd_get_omega_grid[] = "\
x,w = get_omega_grid(n,l)\n\nWrapper for ``get_omega_grid``.\
\n\nParameters\n----------\n"
"n : input int\n"
"l : input float\n"
"\nReturns\n-------\n"
"x : rank-1 array('d') with bounds (n)\n"
"w : rank-1 array('d') with bounds (n)";
/*  */
static PyObject *f2py_rout_lib_mbd_get_omega_grid(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int n = 0;
  PyObject *n_capi = Py_None;
  double l = 0;
  PyObject *l_capi = Py_None;
  double *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  double *w = NULL;
  npy_intp w_Dims[1] = {-1};
  const int w_Rank = 1;
  PyArrayObject *capi_w_tmp = NULL;
  int capi_w_intent = 0;
  static char *capi_kwlist[] = {"n","l",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.get_omega_grid",\
    capi_kwlist,&n_capi,&l_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable n */
    f2py_success = int_from_pyobj(&n,n_capi,"lib.mbd.get_omega_grid() 1st argument (n) can't be converted to int");
  if (f2py_success) {
  /* Processing variable l */
    f2py_success = double_from_pyobj(&l,l_capi,"lib.mbd.get_omega_grid() 2nd argument (l) can't be converted to double");
  if (f2py_success) {
  /* Processing variable x */
  x_Dims[0]=n;
  capi_x_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_x_tmp = array_from_pyobj(NPY_DOUBLE,x_Dims,x_Rank,capi_x_intent,Py_None);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `x' of lib.mbd.get_omega_grid to C/Fortran array" );
  } else {
    x = (double *)(PyArray_DATA(capi_x_tmp));

  /* Processing variable w */
  w_Dims[0]=n;
  capi_w_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_w_tmp = array_from_pyobj(NPY_DOUBLE,w_Dims,w_Rank,capi_w_intent,Py_None);
  if (capi_w_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `w' of lib.mbd.get_omega_grid to C/Fortran array" );
  } else {
    w = (double *)(PyArray_DATA(capi_w_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&n,&l,x,w);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("NN",capi_x_tmp,capi_w_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_w_tmp == NULL) ... else of w*/
  /* End of cleaning variable w */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  } /*if (f2py_success) of l*/
  /* End of cleaning variable l */
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of get_omega_grid ***************************/

/******************************* gauss_legendre *******************************/
static char doc_f2py_rout_lib_mbd_gauss_legendre[] = "\
r,w = gauss_legendre(n)\n\nWrapper for ``gauss_legendre``.\
\n\nParameters\n----------\n"
"n : input int\n"
"\nReturns\n-------\n"
"r : rank-1 array('d') with bounds (n)\n"
"w : rank-1 array('d') with bounds (n)";
/*  */
static PyObject *f2py_rout_lib_mbd_gauss_legendre(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int n = 0;
  PyObject *n_capi = Py_None;
  double *r = NULL;
  npy_intp r_Dims[1] = {-1};
  const int r_Rank = 1;
  PyArrayObject *capi_r_tmp = NULL;
  int capi_r_intent = 0;
  double *w = NULL;
  npy_intp w_Dims[1] = {-1};
  const int w_Rank = 1;
  PyArrayObject *capi_w_tmp = NULL;
  int capi_w_intent = 0;
  static char *capi_kwlist[] = {"n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.gauss_legendre",\
    capi_kwlist,&n_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable n */
    f2py_success = int_from_pyobj(&n,n_capi,"lib.mbd.gauss_legendre() 1st argument (n) can't be converted to int");
  if (f2py_success) {
  /* Processing variable r */
  r_Dims[0]=n;
  capi_r_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_r_tmp = array_from_pyobj(NPY_DOUBLE,r_Dims,r_Rank,capi_r_intent,Py_None);
  if (capi_r_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `r' of lib.mbd.gauss_legendre to C/Fortran array" );
  } else {
    r = (double *)(PyArray_DATA(capi_r_tmp));

  /* Processing variable w */
  w_Dims[0]=n;
  capi_w_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_w_tmp = array_from_pyobj(NPY_DOUBLE,w_Dims,w_Rank,capi_w_intent,Py_None);
  if (capi_w_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `w' of lib.mbd.gauss_legendre to C/Fortran array" );
  } else {
    w = (double *)(PyArray_DATA(capi_w_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&n,r,w);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("NN",capi_r_tmp,capi_w_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_w_tmp == NULL) ... else of w*/
  /* End of cleaning variable w */
  }  /*if (capi_r_tmp == NULL) ... else of r*/
  /* End of cleaning variable r */
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of gauss_legendre ***************************/

/**************************** alpha_dynamic_ts_all ****************************/
static char doc_f2py_rout_lib_mbd_alpha_dynamic_ts_all[] = "\
alpha_dyn = alpha_dynamic_ts_all(mode,n,alpha_0,[c6,omega])\n\nWrapper for ``alpha_dynamic_ts_all``.\
\n\nParameters\n----------\n"
"mode : input string(len=1)\n"
"n : input int\n"
"alpha_0 : input rank-1 array('d') with bounds (f2py_alpha_0_d0)\n"
"\nOther Parameters\n----------------\n"
"c6 : input rank-1 array('d') with bounds (size(alpha_0))\n"
"omega : input rank-1 array('d') with bounds (size(alpha_0))\n"
"\nReturns\n-------\n"
"alpha_dyn : rank-2 array('d') with bounds (n + 1,size(alpha_0)) and alpha_dynamic_ts_all storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_alpha_dynamic_ts_all(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,int*,double*,double*,double*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *alpha_dynamic_ts_all = NULL;
  npy_intp alpha_dynamic_ts_all_Dims[2] = {-1, -1};
  const int alpha_dynamic_ts_all_Rank = 2;
  PyArrayObject *capi_alpha_dynamic_ts_all_tmp = NULL;
  int capi_alpha_dynamic_ts_all_intent = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  double *alpha_0 = NULL;
  npy_intp alpha_0_Dims[1] = {-1};
  const int alpha_0_Rank = 1;
  PyArrayObject *capi_alpha_0_tmp = NULL;
  int capi_alpha_0_intent = 0;
  PyObject *alpha_0_capi = Py_None;
  double *c6 = NULL;
  npy_intp c6_Dims[1] = {-1};
  const int c6_Rank = 1;
  PyArrayObject *capi_c6_tmp = NULL;
  int capi_c6_intent = 0;
  PyObject *c6_capi = Py_None;
  double *omega = NULL;
  npy_intp omega_Dims[1] = {-1};
  const int omega_Rank = 1;
  PyArrayObject *capi_omega_tmp = NULL;
  int capi_omega_intent = 0;
  PyObject *omega_capi = Py_None;
  int f2py_alpha_0_d0 = 0;
  static char *capi_kwlist[] = {"mode","n","alpha_0","c6","omega",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO|OO:lib.mbd.alpha_dynamic_ts_all",\
    capi_kwlist,&mode_capi,&n_capi,&alpha_0_capi,&c6_capi,&omega_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = 1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.alpha_dynamic_ts_all to C string");
  if (f2py_success) {
  /* Processing variable n */
    f2py_success = int_from_pyobj(&n,n_capi,"lib.mbd.alpha_dynamic_ts_all() 2nd argument (n) can't be converted to int");
  if (f2py_success) {
  /* Processing variable alpha_0 */
  ;
  capi_alpha_0_intent |= F2PY_INTENT_IN;
  capi_alpha_0_tmp = array_from_pyobj(NPY_DOUBLE,alpha_0_Dims,alpha_0_Rank,capi_alpha_0_intent,alpha_0_capi);
  if (capi_alpha_0_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `alpha_0' of lib.mbd.alpha_dynamic_ts_all to C/Fortran array" );
  } else {
    alpha_0 = (double *)(PyArray_DATA(capi_alpha_0_tmp));

  /* Processing variable c6 */
  c6_Dims[0]=size(alpha_0);
  capi_c6_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_c6_tmp = array_from_pyobj(NPY_DOUBLE,c6_Dims,c6_Rank,capi_c6_intent,c6_capi);
  if (capi_c6_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `c6' of lib.mbd.alpha_dynamic_ts_all to C/Fortran array" );
  } else {
    c6 = (double *)(PyArray_DATA(capi_c6_tmp));

  /* Processing variable omega */
  omega_Dims[0]=size(alpha_0);
  capi_omega_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_omega_tmp = array_from_pyobj(NPY_DOUBLE,omega_Dims,omega_Rank,capi_omega_intent,omega_capi);
  if (capi_omega_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd keyword `omega' of lib.mbd.alpha_dynamic_ts_all to C/Fortran array" );
  } else {
    omega = (double *)(PyArray_DATA(capi_omega_tmp));

  /* Processing variable alpha_dynamic_ts_all */
  alpha_dynamic_ts_all_Dims[0]=n + 1,alpha_dynamic_ts_all_Dims[1]=size(alpha_0);
  capi_alpha_dynamic_ts_all_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_alpha_dynamic_ts_all_tmp = array_from_pyobj(NPY_DOUBLE,alpha_dynamic_ts_all_Dims,alpha_dynamic_ts_all_Rank,capi_alpha_dynamic_ts_all_intent,Py_None);
  if (capi_alpha_dynamic_ts_all_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `alpha_dynamic_ts_all' of lib.mbd.alpha_dynamic_ts_all to C/Fortran array" );
  } else {
    alpha_dynamic_ts_all = (double *)(PyArray_DATA(capi_alpha_dynamic_ts_all_tmp));

  /* Processing variable f2py_alpha_0_d0 */
  f2py_alpha_0_d0 = shape(alpha_0, 0);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(alpha_dynamic_ts_all,mode,&n,alpha_0,c6,omega,&f2py_alpha_0_d0,slen(mode));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_alpha_dynamic_ts_all_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_alpha_0_d0 */
  }  /*if (capi_alpha_dynamic_ts_all_tmp == NULL) ... else of alpha_dynamic_ts_all*/
  /* End of cleaning variable alpha_dynamic_ts_all */
  if((PyObject *)capi_omega_tmp!=omega_capi) {
    Py_XDECREF(capi_omega_tmp); }
  }  /*if (capi_omega_tmp == NULL) ... else of omega*/
  /* End of cleaning variable omega */
  if((PyObject *)capi_c6_tmp!=c6_capi) {
    Py_XDECREF(capi_c6_tmp); }
  }  /*if (capi_c6_tmp == NULL) ... else of c6*/
  /* End of cleaning variable c6 */
  if((PyObject *)capi_alpha_0_tmp!=alpha_0_capi) {
    Py_XDECREF(capi_alpha_0_tmp); }
  }  /*if (capi_alpha_0_tmp == NULL) ... else of alpha_0*/
  /* End of cleaning variable alpha_0 */
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of alpha_dynamic_ts_all ************************/

/****************************** alpha_dynamic_ts ******************************/
static char doc_f2py_rout_lib_mbd_alpha_dynamic_ts[] = "\
alpha = alpha_dynamic_ts(mode,alpha_0,u,[c6,omega])\n\nWrapper for ``alpha_dynamic_ts``.\
\n\nParameters\n----------\n"
"mode : input string(len=1)\n"
"alpha_0 : input rank-1 array('d') with bounds (f2py_alpha_0_d0)\n"
"u : input float\n"
"\nOther Parameters\n----------------\n"
"c6 : input rank-1 array('d') with bounds (size(alpha_0))\n"
"omega : input rank-1 array('d') with bounds (size(alpha_0))\n"
"\nReturns\n-------\n"
"alpha : rank-1 array('d') with bounds (size(alpha_0)) and alpha_dynamic_ts storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_alpha_dynamic_ts(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,double*,double*,double*,double*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *alpha_dynamic_ts = NULL;
  npy_intp alpha_dynamic_ts_Dims[1] = {-1};
  const int alpha_dynamic_ts_Rank = 1;
  PyArrayObject *capi_alpha_dynamic_ts_tmp = NULL;
  int capi_alpha_dynamic_ts_intent = 0;
  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  double *alpha_0 = NULL;
  npy_intp alpha_0_Dims[1] = {-1};
  const int alpha_0_Rank = 1;
  PyArrayObject *capi_alpha_0_tmp = NULL;
  int capi_alpha_0_intent = 0;
  PyObject *alpha_0_capi = Py_None;
  double u = 0;
  PyObject *u_capi = Py_None;
  double *c6 = NULL;
  npy_intp c6_Dims[1] = {-1};
  const int c6_Rank = 1;
  PyArrayObject *capi_c6_tmp = NULL;
  int capi_c6_intent = 0;
  PyObject *c6_capi = Py_None;
  double *omega = NULL;
  npy_intp omega_Dims[1] = {-1};
  const int omega_Rank = 1;
  PyArrayObject *capi_omega_tmp = NULL;
  int capi_omega_intent = 0;
  PyObject *omega_capi = Py_None;
  int f2py_alpha_0_d0 = 0;
  static char *capi_kwlist[] = {"mode","alpha_0","u","c6","omega",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO|OO:lib.mbd.alpha_dynamic_ts",\
    capi_kwlist,&mode_capi,&alpha_0_capi,&u_capi,&c6_capi,&omega_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = 1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.alpha_dynamic_ts to C string");
  if (f2py_success) {
  /* Processing variable alpha_0 */
  ;
  capi_alpha_0_intent |= F2PY_INTENT_IN;
  capi_alpha_0_tmp = array_from_pyobj(NPY_DOUBLE,alpha_0_Dims,alpha_0_Rank,capi_alpha_0_intent,alpha_0_capi);
  if (capi_alpha_0_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `alpha_0' of lib.mbd.alpha_dynamic_ts to C/Fortran array" );
  } else {
    alpha_0 = (double *)(PyArray_DATA(capi_alpha_0_tmp));

  /* Processing variable u */
    f2py_success = double_from_pyobj(&u,u_capi,"lib.mbd.alpha_dynamic_ts() 3rd argument (u) can't be converted to double");
  if (f2py_success) {
  /* Processing variable c6 */
  c6_Dims[0]=size(alpha_0);
  capi_c6_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_c6_tmp = array_from_pyobj(NPY_DOUBLE,c6_Dims,c6_Rank,capi_c6_intent,c6_capi);
  if (capi_c6_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st keyword `c6' of lib.mbd.alpha_dynamic_ts to C/Fortran array" );
  } else {
    c6 = (double *)(PyArray_DATA(capi_c6_tmp));

  /* Processing variable omega */
  omega_Dims[0]=size(alpha_0);
  capi_omega_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_omega_tmp = array_from_pyobj(NPY_DOUBLE,omega_Dims,omega_Rank,capi_omega_intent,omega_capi);
  if (capi_omega_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd keyword `omega' of lib.mbd.alpha_dynamic_ts to C/Fortran array" );
  } else {
    omega = (double *)(PyArray_DATA(capi_omega_tmp));

  /* Processing variable alpha_dynamic_ts */
  alpha_dynamic_ts_Dims[0]=size(alpha_0);
  capi_alpha_dynamic_ts_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_alpha_dynamic_ts_tmp = array_from_pyobj(NPY_DOUBLE,alpha_dynamic_ts_Dims,alpha_dynamic_ts_Rank,capi_alpha_dynamic_ts_intent,Py_None);
  if (capi_alpha_dynamic_ts_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `alpha_dynamic_ts' of lib.mbd.alpha_dynamic_ts to C/Fortran array" );
  } else {
    alpha_dynamic_ts = (double *)(PyArray_DATA(capi_alpha_dynamic_ts_tmp));

  /* Processing variable f2py_alpha_0_d0 */
  f2py_alpha_0_d0 = shape(alpha_0, 0);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(alpha_dynamic_ts,mode,alpha_0,&u,c6,omega,&f2py_alpha_0_d0,slen(mode));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_alpha_dynamic_ts_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_alpha_0_d0 */
  }  /*if (capi_alpha_dynamic_ts_tmp == NULL) ... else of alpha_dynamic_ts*/
  /* End of cleaning variable alpha_dynamic_ts */
  if((PyObject *)capi_omega_tmp!=omega_capi) {
    Py_XDECREF(capi_omega_tmp); }
  }  /*if (capi_omega_tmp == NULL) ... else of omega*/
  /* End of cleaning variable omega */
  if((PyObject *)capi_c6_tmp!=c6_capi) {
    Py_XDECREF(capi_c6_tmp); }
  }  /*if (capi_c6_tmp == NULL) ... else of c6*/
  /* End of cleaning variable c6 */
  } /*if (f2py_success) of u*/
  /* End of cleaning variable u */
  if((PyObject *)capi_alpha_0_tmp!=alpha_0_capi) {
    Py_XDECREF(capi_alpha_0_tmp); }
  }  /*if (capi_alpha_0_tmp == NULL) ... else of alpha_0*/
  /* End of cleaning variable alpha_0 */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of alpha_dynamic_ts **************************/

/********************************* alpha_osc *********************************/
static char doc_f2py_rout_lib_mbd_alpha_osc[] = "\
alpha = alpha_osc(alpha_0,omega,u)\n\nWrapper for ``alpha_osc``.\
\n\nParameters\n----------\n"
"alpha_0 : input float\n"
"omega : input float\n"
"u : input float\n"
"\nReturns\n-------\n"
"alpha : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_alpha_osc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double alpha_osc = 0;
  double alpha_0 = 0;
  PyObject *alpha_0_capi = Py_None;
  double omega = 0;
  PyObject *omega_capi = Py_None;
  double u = 0;
  PyObject *u_capi = Py_None;
  static char *capi_kwlist[] = {"alpha_0","omega","u",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd.alpha_osc",\
    capi_kwlist,&alpha_0_capi,&omega_capi,&u_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable alpha_0 */
    f2py_success = double_from_pyobj(&alpha_0,alpha_0_capi,"lib.mbd.alpha_osc() 1st argument (alpha_0) can't be converted to double");
  if (f2py_success) {
  /* Processing variable omega */
    f2py_success = double_from_pyobj(&omega,omega_capi,"lib.mbd.alpha_osc() 2nd argument (omega) can't be converted to double");
  if (f2py_success) {
  /* Processing variable u */
    f2py_success = double_from_pyobj(&u,u_capi,"lib.mbd.alpha_osc() 3rd argument (u) can't be converted to double");
  if (f2py_success) {
  /* Processing variable alpha_osc */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&alpha_osc,&alpha_0,&omega,&u);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",alpha_osc);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable alpha_osc */
  } /*if (f2py_success) of u*/
  /* End of cleaning variable u */
  } /*if (f2py_success) of omega*/
  /* End of cleaning variable omega */
  } /*if (f2py_success) of alpha_0*/
  /* End of cleaning variable alpha_0 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of alpha_osc ******************************/

/********************************* combine_c6 *********************************/
static char doc_f2py_rout_lib_mbd_combine_c6[] = "\
c6_ij = combine_c6(c6_i,c6_j,alpha_0_i,alpha_0_j)\n\nWrapper for ``combine_c6``.\
\n\nParameters\n----------\n"
"c6_i : input float\n"
"c6_j : input float\n"
"alpha_0_i : input float\n"
"alpha_0_j : input float\n"
"\nReturns\n-------\n"
"c6_ij : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_combine_c6(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double combine_c6 = 0;
  double c6_i = 0;
  PyObject *c6_i_capi = Py_None;
  double c6_j = 0;
  PyObject *c6_j_capi = Py_None;
  double alpha_0_i = 0;
  PyObject *alpha_0_i_capi = Py_None;
  double alpha_0_j = 0;
  PyObject *alpha_0_j_capi = Py_None;
  static char *capi_kwlist[] = {"c6_i","c6_j","alpha_0_i","alpha_0_j",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:lib.mbd.combine_c6",\
    capi_kwlist,&c6_i_capi,&c6_j_capi,&alpha_0_i_capi,&alpha_0_j_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable c6_i */
    f2py_success = double_from_pyobj(&c6_i,c6_i_capi,"lib.mbd.combine_c6() 1st argument (c6_i) can't be converted to double");
  if (f2py_success) {
  /* Processing variable c6_j */
    f2py_success = double_from_pyobj(&c6_j,c6_j_capi,"lib.mbd.combine_c6() 2nd argument (c6_j) can't be converted to double");
  if (f2py_success) {
  /* Processing variable alpha_0_i */
    f2py_success = double_from_pyobj(&alpha_0_i,alpha_0_i_capi,"lib.mbd.combine_c6() 3rd argument (alpha_0_i) can't be converted to double");
  if (f2py_success) {
  /* Processing variable alpha_0_j */
    f2py_success = double_from_pyobj(&alpha_0_j,alpha_0_j_capi,"lib.mbd.combine_c6() 4th argument (alpha_0_j) can't be converted to double");
  if (f2py_success) {
  /* Processing variable combine_c6 */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&combine_c6,&c6_i,&c6_j,&alpha_0_i,&alpha_0_j);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",combine_c6);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable combine_c6 */
  } /*if (f2py_success) of alpha_0_j*/
  /* End of cleaning variable alpha_0_j */
  } /*if (f2py_success) of alpha_0_i*/
  /* End of cleaning variable alpha_0_i */
  } /*if (f2py_success) of c6_j*/
  /* End of cleaning variable c6_j */
  } /*if (f2py_success) of c6_i*/
  /* End of cleaning variable c6_i */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of combine_c6 *****************************/

/*********************************** v_to_r ***********************************/
static char doc_f2py_rout_lib_mbd_v_to_r[] = "\
r = v_to_r(v)\n\nWrapper for ``v_to_r``.\
\n\nParameters\n----------\n"
"v : input float\n"
"\nReturns\n-------\n"
"r : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_v_to_r(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double v_to_r = 0;
  double v = 0;
  PyObject *v_capi = Py_None;
  static char *capi_kwlist[] = {"v",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.v_to_r",\
    capi_kwlist,&v_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable v */
    f2py_success = double_from_pyobj(&v,v_capi,"lib.mbd.v_to_r() 1st argument (v) can't be converted to double");
  if (f2py_success) {
  /* Processing variable v_to_r */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&v_to_r,&v);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",v_to_r);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable v_to_r */
  } /*if (f2py_success) of v*/
  /* End of cleaning variable v */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of v_to_r *******************************/

/********************************* omega_eff *********************************/
static char doc_f2py_rout_lib_mbd_omega_eff[] = "\
omega = omega_eff(c6,alpha)\n\nWrapper for ``omega_eff``.\
\n\nParameters\n----------\n"
"c6 : input rank-1 array('d') with bounds (f2py_c6_d0)\n"
"alpha : input rank-1 array('d') with bounds (size(c6))\n"
"\nReturns\n-------\n"
"omega : rank-1 array('d') with bounds (size(c6)) and omega_eff storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_omega_eff(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *omega_eff = NULL;
  npy_intp omega_eff_Dims[1] = {-1};
  const int omega_eff_Rank = 1;
  PyArrayObject *capi_omega_eff_tmp = NULL;
  int capi_omega_eff_intent = 0;
  double *c6 = NULL;
  npy_intp c6_Dims[1] = {-1};
  const int c6_Rank = 1;
  PyArrayObject *capi_c6_tmp = NULL;
  int capi_c6_intent = 0;
  PyObject *c6_capi = Py_None;
  double *alpha = NULL;
  npy_intp alpha_Dims[1] = {-1};
  const int alpha_Rank = 1;
  PyArrayObject *capi_alpha_tmp = NULL;
  int capi_alpha_intent = 0;
  PyObject *alpha_capi = Py_None;
  int f2py_c6_d0 = 0;
  static char *capi_kwlist[] = {"c6","alpha",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.omega_eff",\
    capi_kwlist,&c6_capi,&alpha_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable c6 */
  ;
  capi_c6_intent |= F2PY_INTENT_IN;
  capi_c6_tmp = array_from_pyobj(NPY_DOUBLE,c6_Dims,c6_Rank,capi_c6_intent,c6_capi);
  if (capi_c6_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `c6' of lib.mbd.omega_eff to C/Fortran array" );
  } else {
    c6 = (double *)(PyArray_DATA(capi_c6_tmp));

  /* Processing variable alpha */
  alpha_Dims[0]=size(c6);
  capi_alpha_intent |= F2PY_INTENT_IN;
  capi_alpha_tmp = array_from_pyobj(NPY_DOUBLE,alpha_Dims,alpha_Rank,capi_alpha_intent,alpha_capi);
  if (capi_alpha_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `alpha' of lib.mbd.omega_eff to C/Fortran array" );
  } else {
    alpha = (double *)(PyArray_DATA(capi_alpha_tmp));

  /* Processing variable omega_eff */
  omega_eff_Dims[0]=size(c6);
  capi_omega_eff_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_omega_eff_tmp = array_from_pyobj(NPY_DOUBLE,omega_eff_Dims,omega_eff_Rank,capi_omega_eff_intent,Py_None);
  if (capi_omega_eff_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `omega_eff' of lib.mbd.omega_eff to C/Fortran array" );
  } else {
    omega_eff = (double *)(PyArray_DATA(capi_omega_eff_tmp));

  /* Processing variable f2py_c6_d0 */
  f2py_c6_d0 = shape(c6, 0);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(omega_eff,c6,alpha,&f2py_c6_d0);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_omega_eff_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_c6_d0 */
  }  /*if (capi_omega_eff_tmp == NULL) ... else of omega_eff*/
  /* End of cleaning variable omega_eff */
  if((PyObject *)capi_alpha_tmp!=alpha_capi) {
    Py_XDECREF(capi_alpha_tmp); }
  }  /*if (capi_alpha_tmp == NULL) ... else of alpha*/
  /* End of cleaning variable alpha */
  if((PyObject *)capi_c6_tmp!=c6_capi) {
    Py_XDECREF(capi_c6_tmp); }
  }  /*if (capi_c6_tmp == NULL) ... else of c6*/
  /* End of cleaning variable c6 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of omega_eff ******************************/

/***************************** get_sigma_selfint *****************************/
static char doc_f2py_rout_lib_mbd_get_sigma_selfint[] = "\
sigma = get_sigma_selfint(alpha)\n\nWrapper for ``get_sigma_selfint``.\
\n\nParameters\n----------\n"
"alpha : input float\n"
"\nReturns\n-------\n"
"sigma : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_sigma_selfint(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double get_sigma_selfint = 0;
  double alpha = 0;
  PyObject *alpha_capi = Py_None;
  static char *capi_kwlist[] = {"alpha",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.get_sigma_selfint",\
    capi_kwlist,&alpha_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable alpha */
    f2py_success = double_from_pyobj(&alpha,alpha_capi,"lib.mbd.get_sigma_selfint() 1st argument (alpha) can't be converted to double");
  if (f2py_success) {
  /* Processing variable get_sigma_selfint */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_sigma_selfint,&alpha);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",get_sigma_selfint);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable get_sigma_selfint */
  } /*if (f2py_success) of alpha*/
  /* End of cleaning variable alpha */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of get_sigma_selfint **************************/

/***************************** get_c6_from_alpha *****************************/
static char doc_f2py_rout_lib_mbd_get_c6_from_alpha[] = "\
c6 = get_c6_from_alpha(alpha)\n\nWrapper for ``get_c6_from_alpha``.\
\n\nParameters\n----------\n"
"alpha : input rank-2 array('d') with bounds (f2py_alpha_d0,f2py_alpha_d1)\n"
"\nReturns\n-------\n"
"c6 : rank-1 array('d') with bounds (size(alpha, 2)) and get_c6_from_alpha storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_c6_from_alpha(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *get_c6_from_alpha = NULL;
  npy_intp get_c6_from_alpha_Dims[1] = {-1};
  const int get_c6_from_alpha_Rank = 1;
  PyArrayObject *capi_get_c6_from_alpha_tmp = NULL;
  int capi_get_c6_from_alpha_intent = 0;
  double *alpha = NULL;
  npy_intp alpha_Dims[2] = {-1, -1};
  const int alpha_Rank = 2;
  PyArrayObject *capi_alpha_tmp = NULL;
  int capi_alpha_intent = 0;
  PyObject *alpha_capi = Py_None;
  int f2py_alpha_d0 = 0;
  int f2py_alpha_d1 = 0;
  static char *capi_kwlist[] = {"alpha",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.get_c6_from_alpha",\
    capi_kwlist,&alpha_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable alpha */
  ;
  capi_alpha_intent |= F2PY_INTENT_IN;
  capi_alpha_tmp = array_from_pyobj(NPY_DOUBLE,alpha_Dims,alpha_Rank,capi_alpha_intent,alpha_capi);
  if (capi_alpha_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `alpha' of lib.mbd.get_c6_from_alpha to C/Fortran array" );
  } else {
    alpha = (double *)(PyArray_DATA(capi_alpha_tmp));

  /* Processing variable get_c6_from_alpha */
  get_c6_from_alpha_Dims[0]=size(alpha, 2);
  capi_get_c6_from_alpha_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_get_c6_from_alpha_tmp = array_from_pyobj(NPY_DOUBLE,get_c6_from_alpha_Dims,get_c6_from_alpha_Rank,capi_get_c6_from_alpha_intent,Py_None);
  if (capi_get_c6_from_alpha_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `get_c6_from_alpha' of lib.mbd.get_c6_from_alpha to C/Fortran array" );
  } else {
    get_c6_from_alpha = (double *)(PyArray_DATA(capi_get_c6_from_alpha_tmp));

  /* Processing variable f2py_alpha_d0 */
  f2py_alpha_d0 = shape(alpha, 0);
  /* Processing variable f2py_alpha_d1 */
  f2py_alpha_d1 = shape(alpha, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(get_c6_from_alpha,alpha,&f2py_alpha_d0,&f2py_alpha_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_get_c6_from_alpha_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_alpha_d1 */
  /* End of cleaning variable f2py_alpha_d0 */
  }  /*if (capi_get_c6_from_alpha_tmp == NULL) ... else of get_c6_from_alpha*/
  /* End of cleaning variable get_c6_from_alpha */
  if((PyObject *)capi_alpha_tmp!=alpha_capi) {
    Py_XDECREF(capi_alpha_tmp); }
  }  /*if (capi_alpha_tmp == NULL) ... else of alpha*/
  /* End of cleaning variable alpha */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of get_c6_from_alpha **************************/

/************************** get_total_c6_from_alpha **************************/
static char doc_f2py_rout_lib_mbd_get_total_c6_from_alpha[] = "\
c6 = get_total_c6_from_alpha(alpha)\n\nWrapper for ``get_total_c6_from_alpha``.\
\n\nParameters\n----------\n"
"alpha : input rank-2 array('d') with bounds (f2py_alpha_d0,f2py_alpha_d1)\n"
"\nReturns\n-------\n"
"c6 : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_total_c6_from_alpha(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double get_total_c6_from_alpha = 0;
  double *alpha = NULL;
  npy_intp alpha_Dims[2] = {-1, -1};
  const int alpha_Rank = 2;
  PyArrayObject *capi_alpha_tmp = NULL;
  int capi_alpha_intent = 0;
  PyObject *alpha_capi = Py_None;
  int f2py_alpha_d0 = 0;
  int f2py_alpha_d1 = 0;
  static char *capi_kwlist[] = {"alpha",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.get_total_c6_from_alpha",\
    capi_kwlist,&alpha_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable alpha */
  ;
  capi_alpha_intent |= F2PY_INTENT_IN;
  capi_alpha_tmp = array_from_pyobj(NPY_DOUBLE,alpha_Dims,alpha_Rank,capi_alpha_intent,alpha_capi);
  if (capi_alpha_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `alpha' of lib.mbd.get_total_c6_from_alpha to C/Fortran array" );
  } else {
    alpha = (double *)(PyArray_DATA(capi_alpha_tmp));

  /* Processing variable get_total_c6_from_alpha */
  /* Processing variable f2py_alpha_d0 */
  f2py_alpha_d0 = shape(alpha, 0);
  /* Processing variable f2py_alpha_d1 */
  f2py_alpha_d1 = shape(alpha, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_total_c6_from_alpha,alpha,&f2py_alpha_d0,&f2py_alpha_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",get_total_c6_from_alpha);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_alpha_d1 */
  /* End of cleaning variable f2py_alpha_d0 */
  /* End of cleaning variable get_total_c6_from_alpha */
  if((PyObject *)capi_alpha_tmp!=alpha_capi) {
    Py_XDECREF(capi_alpha_tmp); }
  }  /*if (capi_alpha_tmp == NULL) ... else of alpha*/
  /* End of cleaning variable alpha */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*********************** end of get_total_c6_from_alpha ***********************/

/*********************************** t_bare ***********************************/
static char doc_f2py_rout_lib_mbd_t_bare[] = "\
t = t_bare(rxyz)\n\nWrapper for ``t_bare``.\
\n\nParameters\n----------\n"
"rxyz : input rank-1 array('d') with bounds (3)\n"
"\nReturns\n-------\n"
"t : rank-2 array('d') with bounds (3,3) and t_bare storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_t_bare(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *t_bare = NULL;
  npy_intp t_bare_Dims[2] = {-1, -1};
  const int t_bare_Rank = 2;
  PyArrayObject *capi_t_bare_tmp = NULL;
  int capi_t_bare_intent = 0;
  double *rxyz = NULL;
  npy_intp rxyz_Dims[1] = {-1};
  const int rxyz_Rank = 1;
  PyArrayObject *capi_rxyz_tmp = NULL;
  int capi_rxyz_intent = 0;
  PyObject *rxyz_capi = Py_None;
  static char *capi_kwlist[] = {"rxyz",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.t_bare",\
    capi_kwlist,&rxyz_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable rxyz */
  rxyz_Dims[0]=3;
  capi_rxyz_intent |= F2PY_INTENT_IN;
  capi_rxyz_tmp = array_from_pyobj(NPY_DOUBLE,rxyz_Dims,rxyz_Rank,capi_rxyz_intent,rxyz_capi);
  if (capi_rxyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `rxyz' of lib.mbd.t_bare to C/Fortran array" );
  } else {
    rxyz = (double *)(PyArray_DATA(capi_rxyz_tmp));

  /* Processing variable t_bare */
  t_bare_Dims[0]=3,t_bare_Dims[1]=3;
  capi_t_bare_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_t_bare_tmp = array_from_pyobj(NPY_DOUBLE,t_bare_Dims,t_bare_Rank,capi_t_bare_intent,Py_None);
  if (capi_t_bare_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `t_bare' of lib.mbd.t_bare to C/Fortran array" );
  } else {
    t_bare = (double *)(PyArray_DATA(capi_t_bare_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(t_bare,rxyz);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_t_bare_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_t_bare_tmp == NULL) ... else of t_bare*/
  /* End of cleaning variable t_bare */
  if((PyObject *)capi_rxyz_tmp!=rxyz_capi) {
    Py_XDECREF(capi_rxyz_tmp); }
  }  /*if (capi_rxyz_tmp == NULL) ... else of rxyz*/
  /* End of cleaning variable rxyz */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of t_bare *******************************/

/*********************************** b_erfc ***********************************/
static char doc_f2py_rout_lib_mbd_b_erfc[] = "\
b = b_erfc(r,a)\n\nWrapper for ``b_erfc``.\
\n\nParameters\n----------\n"
"r : input float\n"
"a : input float\n"
"\nReturns\n-------\n"
"b : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_b_erfc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float b_erfc = 0;
  double r = 0;
  PyObject *r_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  static char *capi_kwlist[] = {"r","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.b_erfc",\
    capi_kwlist,&r_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable r */
    f2py_success = double_from_pyobj(&r,r_capi,"lib.mbd.b_erfc() 1st argument (r) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.b_erfc() 2nd argument (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable b_erfc */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&b_erfc,&r,&a);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("f",b_erfc);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable b_erfc */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of r*/
  /* End of cleaning variable r */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of b_erfc *******************************/

/*********************************** c_erfc ***********************************/
static char doc_f2py_rout_lib_mbd_c_erfc[] = "\
c = c_erfc(r,a)\n\nWrapper for ``c_erfc``.\
\n\nParameters\n----------\n"
"r : input float\n"
"a : input float\n"
"\nReturns\n-------\n"
"c : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_c_erfc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float c_erfc = 0;
  double r = 0;
  PyObject *r_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  static char *capi_kwlist[] = {"r","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.c_erfc",\
    capi_kwlist,&r_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable r */
    f2py_success = double_from_pyobj(&r,r_capi,"lib.mbd.c_erfc() 1st argument (r) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.c_erfc() 2nd argument (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable c_erfc */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&c_erfc,&r,&a);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("f",c_erfc);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable c_erfc */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of r*/
  /* End of cleaning variable r */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of c_erfc *******************************/

/*********************************** t_erfc ***********************************/
static char doc_f2py_rout_lib_mbd_t_erfc[] = "\
t = t_erfc(rxyz,alpha)\n\nWrapper for ``t_erfc``.\
\n\nParameters\n----------\n"
"rxyz : input rank-1 array('d') with bounds (3)\n"
"alpha : input float\n"
"\nReturns\n-------\n"
"t : rank-2 array('d') with bounds (3,3) and t_erfc storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_t_erfc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *t_erfc = NULL;
  npy_intp t_erfc_Dims[2] = {-1, -1};
  const int t_erfc_Rank = 2;
  PyArrayObject *capi_t_erfc_tmp = NULL;
  int capi_t_erfc_intent = 0;
  double *rxyz = NULL;
  npy_intp rxyz_Dims[1] = {-1};
  const int rxyz_Rank = 1;
  PyArrayObject *capi_rxyz_tmp = NULL;
  int capi_rxyz_intent = 0;
  PyObject *rxyz_capi = Py_None;
  double alpha = 0;
  PyObject *alpha_capi = Py_None;
  static char *capi_kwlist[] = {"rxyz","alpha",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.t_erfc",\
    capi_kwlist,&rxyz_capi,&alpha_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable rxyz */
  rxyz_Dims[0]=3;
  capi_rxyz_intent |= F2PY_INTENT_IN;
  capi_rxyz_tmp = array_from_pyobj(NPY_DOUBLE,rxyz_Dims,rxyz_Rank,capi_rxyz_intent,rxyz_capi);
  if (capi_rxyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `rxyz' of lib.mbd.t_erfc to C/Fortran array" );
  } else {
    rxyz = (double *)(PyArray_DATA(capi_rxyz_tmp));

  /* Processing variable alpha */
    f2py_success = double_from_pyobj(&alpha,alpha_capi,"lib.mbd.t_erfc() 2nd argument (alpha) can't be converted to double");
  if (f2py_success) {
  /* Processing variable t_erfc */
  t_erfc_Dims[0]=3,t_erfc_Dims[1]=3;
  capi_t_erfc_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_t_erfc_tmp = array_from_pyobj(NPY_DOUBLE,t_erfc_Dims,t_erfc_Rank,capi_t_erfc_intent,Py_None);
  if (capi_t_erfc_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `t_erfc' of lib.mbd.t_erfc to C/Fortran array" );
  } else {
    t_erfc = (double *)(PyArray_DATA(capi_t_erfc_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(t_erfc,rxyz,&alpha);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_t_erfc_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_t_erfc_tmp == NULL) ... else of t_erfc*/
  /* End of cleaning variable t_erfc */
  } /*if (f2py_success) of alpha*/
  /* End of cleaning variable alpha */
  if((PyObject *)capi_rxyz_tmp!=rxyz_capi) {
    Py_XDECREF(capi_rxyz_tmp); }
  }  /*if (capi_rxyz_tmp == NULL) ... else of rxyz*/
  /* End of cleaning variable rxyz */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of t_erfc *******************************/

/******************************* damping_fermi *******************************/
static char doc_f2py_rout_lib_mbd_damping_fermi[] = "\
f = damping_fermi(r,sigma,a)\n\nWrapper for ``damping_fermi``.\
\n\nParameters\n----------\n"
"r : input float\n"
"sigma : input float\n"
"a : input float\n"
"\nReturns\n-------\n"
"f : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_damping_fermi(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double damping_fermi = 0;
  double r = 0;
  PyObject *r_capi = Py_None;
  double sigma = 0;
  PyObject *sigma_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  static char *capi_kwlist[] = {"r","sigma","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd.damping_fermi",\
    capi_kwlist,&r_capi,&sigma_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable r */
    f2py_success = double_from_pyobj(&r,r_capi,"lib.mbd.damping_fermi() 1st argument (r) can't be converted to double");
  if (f2py_success) {
  /* Processing variable sigma */
    f2py_success = double_from_pyobj(&sigma,sigma_capi,"lib.mbd.damping_fermi() 2nd argument (sigma) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.damping_fermi() 3rd argument (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable damping_fermi */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&damping_fermi,&r,&sigma,&a);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",damping_fermi);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable damping_fermi */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of sigma*/
  /* End of cleaning variable sigma */
  } /*if (f2py_success) of r*/
  /* End of cleaning variable r */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of damping_fermi ****************************/

/******************************** damping_erf ********************************/
static char doc_f2py_rout_lib_mbd_damping_erf[] = "\
f = damping_erf(r,sigma,a)\n\nWrapper for ``damping_erf``.\
\n\nParameters\n----------\n"
"r : input float\n"
"sigma : input float\n"
"a : input float\n"
"\nReturns\n-------\n"
"f : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_damping_erf(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double damping_erf = 0;
  double r = 0;
  PyObject *r_capi = Py_None;
  double sigma = 0;
  PyObject *sigma_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  static char *capi_kwlist[] = {"r","sigma","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd.damping_erf",\
    capi_kwlist,&r_capi,&sigma_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable r */
    f2py_success = double_from_pyobj(&r,r_capi,"lib.mbd.damping_erf() 1st argument (r) can't be converted to double");
  if (f2py_success) {
  /* Processing variable sigma */
    f2py_success = double_from_pyobj(&sigma,sigma_capi,"lib.mbd.damping_erf() 2nd argument (sigma) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.damping_erf() 3rd argument (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable damping_erf */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&damping_erf,&r,&sigma,&a);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",damping_erf);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable damping_erf */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of sigma*/
  /* End of cleaning variable sigma */
  } /*if (f2py_success) of r*/
  /* End of cleaning variable r */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of damping_erf *****************************/

/******************************* damping_1mexp *******************************/
static char doc_f2py_rout_lib_mbd_damping_1mexp[] = "\
f = damping_1mexp(r,sigma,a)\n\nWrapper for ``damping_1mexp``.\
\n\nParameters\n----------\n"
"r : input float\n"
"sigma : input float\n"
"a : input float\n"
"\nReturns\n-------\n"
"f : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_damping_1mexp(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double damping_1mexp = 0;
  double r = 0;
  PyObject *r_capi = Py_None;
  double sigma = 0;
  PyObject *sigma_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  static char *capi_kwlist[] = {"r","sigma","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd.damping_1mexp",\
    capi_kwlist,&r_capi,&sigma_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable r */
    f2py_success = double_from_pyobj(&r,r_capi,"lib.mbd.damping_1mexp() 1st argument (r) can't be converted to double");
  if (f2py_success) {
  /* Processing variable sigma */
    f2py_success = double_from_pyobj(&sigma,sigma_capi,"lib.mbd.damping_1mexp() 2nd argument (sigma) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.damping_1mexp() 3rd argument (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable damping_1mexp */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&damping_1mexp,&r,&sigma,&a);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",damping_1mexp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable damping_1mexp */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of sigma*/
  /* End of cleaning variable sigma */
  } /*if (f2py_success) of r*/
  /* End of cleaning variable r */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of damping_1mexp ****************************/

/****************************** damping_overlap ******************************/
static char doc_f2py_rout_lib_mbd_damping_overlap[] = "\
f = damping_overlap(r,overlap,c6,beta,a)\n\nWrapper for ``damping_overlap``.\
\n\nParameters\n----------\n"
"r : input float\n"
"overlap : input float\n"
"c6 : input float\n"
"beta : input float\n"
"a : input float\n"
"\nReturns\n-------\n"
"f : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_damping_overlap(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double damping_overlap = 0;
  double r = 0;
  PyObject *r_capi = Py_None;
  double overlap = 0;
  PyObject *overlap_capi = Py_None;
  double c6 = 0;
  PyObject *c6_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  static char *capi_kwlist[] = {"r","overlap","c6","beta","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO:lib.mbd.damping_overlap",\
    capi_kwlist,&r_capi,&overlap_capi,&c6_capi,&beta_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable r */
    f2py_success = double_from_pyobj(&r,r_capi,"lib.mbd.damping_overlap() 1st argument (r) can't be converted to double");
  if (f2py_success) {
  /* Processing variable overlap */
    f2py_success = double_from_pyobj(&overlap,overlap_capi,"lib.mbd.damping_overlap() 2nd argument (overlap) can't be converted to double");
  if (f2py_success) {
  /* Processing variable c6 */
    f2py_success = double_from_pyobj(&c6,c6_capi,"lib.mbd.damping_overlap() 3rd argument (c6) can't be converted to double");
  if (f2py_success) {
  /* Processing variable beta */
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.damping_overlap() 4th argument (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.damping_overlap() 5th argument (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable damping_overlap */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&damping_overlap,&r,&overlap,&c6,&beta,&a);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",damping_overlap);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable damping_overlap */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  } /*if (f2py_success) of c6*/
  /* End of cleaning variable c6 */
  } /*if (f2py_success) of overlap*/
  /* End of cleaning variable overlap */
  } /*if (f2py_success) of r*/
  /* End of cleaning variable r */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of damping_overlap ***************************/

/***************************** t_overlap_coulomb *****************************/
static char doc_f2py_rout_lib_mbd_t_overlap_coulomb[] = "\
t = t_overlap_coulomb(rxyz,overlap,c6,beta,a)\n\nWrapper for ``t_overlap_coulomb``.\
\n\nParameters\n----------\n"
"rxyz : input rank-1 array('d') with bounds (3)\n"
"overlap : input float\n"
"c6 : input float\n"
"beta : input float\n"
"a : input float\n"
"\nReturns\n-------\n"
"t : rank-2 array('d') with bounds (3,3) and t_overlap_coulomb storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_t_overlap_coulomb(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *t_overlap_coulomb = NULL;
  npy_intp t_overlap_coulomb_Dims[2] = {-1, -1};
  const int t_overlap_coulomb_Rank = 2;
  PyArrayObject *capi_t_overlap_coulomb_tmp = NULL;
  int capi_t_overlap_coulomb_intent = 0;
  double *rxyz = NULL;
  npy_intp rxyz_Dims[1] = {-1};
  const int rxyz_Rank = 1;
  PyArrayObject *capi_rxyz_tmp = NULL;
  int capi_rxyz_intent = 0;
  PyObject *rxyz_capi = Py_None;
  double overlap = 0;
  PyObject *overlap_capi = Py_None;
  double c6 = 0;
  PyObject *c6_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  static char *capi_kwlist[] = {"rxyz","overlap","c6","beta","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO:lib.mbd.t_overlap_coulomb",\
    capi_kwlist,&rxyz_capi,&overlap_capi,&c6_capi,&beta_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable rxyz */
  rxyz_Dims[0]=3;
  capi_rxyz_intent |= F2PY_INTENT_IN;
  capi_rxyz_tmp = array_from_pyobj(NPY_DOUBLE,rxyz_Dims,rxyz_Rank,capi_rxyz_intent,rxyz_capi);
  if (capi_rxyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `rxyz' of lib.mbd.t_overlap_coulomb to C/Fortran array" );
  } else {
    rxyz = (double *)(PyArray_DATA(capi_rxyz_tmp));

  /* Processing variable overlap */
    f2py_success = double_from_pyobj(&overlap,overlap_capi,"lib.mbd.t_overlap_coulomb() 2nd argument (overlap) can't be converted to double");
  if (f2py_success) {
  /* Processing variable c6 */
    f2py_success = double_from_pyobj(&c6,c6_capi,"lib.mbd.t_overlap_coulomb() 3rd argument (c6) can't be converted to double");
  if (f2py_success) {
  /* Processing variable beta */
    f2py_success = double_from_pyobj(&beta,beta_capi,"lib.mbd.t_overlap_coulomb() 4th argument (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.t_overlap_coulomb() 5th argument (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable t_overlap_coulomb */
  t_overlap_coulomb_Dims[0]=3,t_overlap_coulomb_Dims[1]=3;
  capi_t_overlap_coulomb_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_t_overlap_coulomb_tmp = array_from_pyobj(NPY_DOUBLE,t_overlap_coulomb_Dims,t_overlap_coulomb_Rank,capi_t_overlap_coulomb_intent,Py_None);
  if (capi_t_overlap_coulomb_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `t_overlap_coulomb' of lib.mbd.t_overlap_coulomb to C/Fortran array" );
  } else {
    t_overlap_coulomb = (double *)(PyArray_DATA(capi_t_overlap_coulomb_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(t_overlap_coulomb,rxyz,&overlap,&c6,&beta,&a);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_t_overlap_coulomb_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_t_overlap_coulomb_tmp == NULL) ... else of t_overlap_coulomb*/
  /* End of cleaning variable t_overlap_coulomb */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  } /*if (f2py_success) of c6*/
  /* End of cleaning variable c6 */
  } /*if (f2py_success) of overlap*/
  /* End of cleaning variable overlap */
  if((PyObject *)capi_rxyz_tmp!=rxyz_capi) {
    Py_XDECREF(capi_rxyz_tmp); }
  }  /*if (capi_rxyz_tmp == NULL) ... else of rxyz*/
  /* End of cleaning variable rxyz */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of t_overlap_coulomb **************************/

/****************************** t_fermi_coulomb ******************************/
static char doc_f2py_rout_lib_mbd_t_fermi_coulomb[] = "\
t = t_fermi_coulomb(rxyz,sigma,a)\n\nWrapper for ``t_fermi_coulomb``.\
\n\nParameters\n----------\n"
"rxyz : input rank-1 array('d') with bounds (3)\n"
"sigma : input float\n"
"a : input float\n"
"\nReturns\n-------\n"
"t : rank-2 array('d') with bounds (3,3) and t_fermi_coulomb storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_t_fermi_coulomb(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *t_fermi_coulomb = NULL;
  npy_intp t_fermi_coulomb_Dims[2] = {-1, -1};
  const int t_fermi_coulomb_Rank = 2;
  PyArrayObject *capi_t_fermi_coulomb_tmp = NULL;
  int capi_t_fermi_coulomb_intent = 0;
  double *rxyz = NULL;
  npy_intp rxyz_Dims[1] = {-1};
  const int rxyz_Rank = 1;
  PyArrayObject *capi_rxyz_tmp = NULL;
  int capi_rxyz_intent = 0;
  PyObject *rxyz_capi = Py_None;
  double sigma = 0;
  PyObject *sigma_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  static char *capi_kwlist[] = {"rxyz","sigma","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd.t_fermi_coulomb",\
    capi_kwlist,&rxyz_capi,&sigma_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable rxyz */
  rxyz_Dims[0]=3;
  capi_rxyz_intent |= F2PY_INTENT_IN;
  capi_rxyz_tmp = array_from_pyobj(NPY_DOUBLE,rxyz_Dims,rxyz_Rank,capi_rxyz_intent,rxyz_capi);
  if (capi_rxyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `rxyz' of lib.mbd.t_fermi_coulomb to C/Fortran array" );
  } else {
    rxyz = (double *)(PyArray_DATA(capi_rxyz_tmp));

  /* Processing variable sigma */
    f2py_success = double_from_pyobj(&sigma,sigma_capi,"lib.mbd.t_fermi_coulomb() 2nd argument (sigma) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.t_fermi_coulomb() 3rd argument (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable t_fermi_coulomb */
  t_fermi_coulomb_Dims[0]=3,t_fermi_coulomb_Dims[1]=3;
  capi_t_fermi_coulomb_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_t_fermi_coulomb_tmp = array_from_pyobj(NPY_DOUBLE,t_fermi_coulomb_Dims,t_fermi_coulomb_Rank,capi_t_fermi_coulomb_intent,Py_None);
  if (capi_t_fermi_coulomb_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `t_fermi_coulomb' of lib.mbd.t_fermi_coulomb to C/Fortran array" );
  } else {
    t_fermi_coulomb = (double *)(PyArray_DATA(capi_t_fermi_coulomb_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(t_fermi_coulomb,rxyz,&sigma,&a);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_t_fermi_coulomb_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_t_fermi_coulomb_tmp == NULL) ... else of t_fermi_coulomb*/
  /* End of cleaning variable t_fermi_coulomb */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of sigma*/
  /* End of cleaning variable sigma */
  if((PyObject *)capi_rxyz_tmp!=rxyz_capi) {
    Py_XDECREF(capi_rxyz_tmp); }
  }  /*if (capi_rxyz_tmp == NULL) ... else of rxyz*/
  /* End of cleaning variable rxyz */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of t_fermi_coulomb ***************************/

/******************************* t_erf_coulomb *******************************/
static char doc_f2py_rout_lib_mbd_t_erf_coulomb[] = "\
t = t_erf_coulomb(rxyz,sigma,a)\n\nWrapper for ``t_erf_coulomb``.\
\n\nParameters\n----------\n"
"rxyz : input rank-1 array('d') with bounds (3)\n"
"sigma : input float\n"
"a : input float\n"
"\nReturns\n-------\n"
"t : rank-2 array('d') with bounds (3,3) and t_erf_coulomb storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_t_erf_coulomb(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *t_erf_coulomb = NULL;
  npy_intp t_erf_coulomb_Dims[2] = {-1, -1};
  const int t_erf_coulomb_Rank = 2;
  PyArrayObject *capi_t_erf_coulomb_tmp = NULL;
  int capi_t_erf_coulomb_intent = 0;
  double *rxyz = NULL;
  npy_intp rxyz_Dims[1] = {-1};
  const int rxyz_Rank = 1;
  PyArrayObject *capi_rxyz_tmp = NULL;
  int capi_rxyz_intent = 0;
  PyObject *rxyz_capi = Py_None;
  double sigma = 0;
  PyObject *sigma_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  static char *capi_kwlist[] = {"rxyz","sigma","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd.t_erf_coulomb",\
    capi_kwlist,&rxyz_capi,&sigma_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable rxyz */
  rxyz_Dims[0]=3;
  capi_rxyz_intent |= F2PY_INTENT_IN;
  capi_rxyz_tmp = array_from_pyobj(NPY_DOUBLE,rxyz_Dims,rxyz_Rank,capi_rxyz_intent,rxyz_capi);
  if (capi_rxyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `rxyz' of lib.mbd.t_erf_coulomb to C/Fortran array" );
  } else {
    rxyz = (double *)(PyArray_DATA(capi_rxyz_tmp));

  /* Processing variable sigma */
    f2py_success = double_from_pyobj(&sigma,sigma_capi,"lib.mbd.t_erf_coulomb() 2nd argument (sigma) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.t_erf_coulomb() 3rd argument (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable t_erf_coulomb */
  t_erf_coulomb_Dims[0]=3,t_erf_coulomb_Dims[1]=3;
  capi_t_erf_coulomb_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_t_erf_coulomb_tmp = array_from_pyobj(NPY_DOUBLE,t_erf_coulomb_Dims,t_erf_coulomb_Rank,capi_t_erf_coulomb_intent,Py_None);
  if (capi_t_erf_coulomb_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `t_erf_coulomb' of lib.mbd.t_erf_coulomb to C/Fortran array" );
  } else {
    t_erf_coulomb = (double *)(PyArray_DATA(capi_t_erf_coulomb_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(t_erf_coulomb,rxyz,&sigma,&a);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_t_erf_coulomb_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_t_erf_coulomb_tmp == NULL) ... else of t_erf_coulomb*/
  /* End of cleaning variable t_erf_coulomb */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of sigma*/
  /* End of cleaning variable sigma */
  if((PyObject *)capi_rxyz_tmp!=rxyz_capi) {
    Py_XDECREF(capi_rxyz_tmp); }
  }  /*if (capi_rxyz_tmp == NULL) ... else of rxyz*/
  /* End of cleaning variable rxyz */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of t_erf_coulomb ****************************/

/****************************** t_1mexp_coulomb ******************************/
static char doc_f2py_rout_lib_mbd_t_1mexp_coulomb[] = "\
t = t_1mexp_coulomb(rxyz,sigma,a)\n\nWrapper for ``t_1mexp_coulomb``.\
\n\nParameters\n----------\n"
"rxyz : input rank-1 array('d') with bounds (3)\n"
"sigma : input float\n"
"a : input float\n"
"\nReturns\n-------\n"
"t : rank-2 array('d') with bounds (3,3) and t_1mexp_coulomb storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_t_1mexp_coulomb(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *t_1mexp_coulomb = NULL;
  npy_intp t_1mexp_coulomb_Dims[2] = {-1, -1};
  const int t_1mexp_coulomb_Rank = 2;
  PyArrayObject *capi_t_1mexp_coulomb_tmp = NULL;
  int capi_t_1mexp_coulomb_intent = 0;
  double *rxyz = NULL;
  npy_intp rxyz_Dims[1] = {-1};
  const int rxyz_Rank = 1;
  PyArrayObject *capi_rxyz_tmp = NULL;
  int capi_rxyz_intent = 0;
  PyObject *rxyz_capi = Py_None;
  double sigma = 0;
  PyObject *sigma_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  static char *capi_kwlist[] = {"rxyz","sigma","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd.t_1mexp_coulomb",\
    capi_kwlist,&rxyz_capi,&sigma_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable rxyz */
  rxyz_Dims[0]=3;
  capi_rxyz_intent |= F2PY_INTENT_IN;
  capi_rxyz_tmp = array_from_pyobj(NPY_DOUBLE,rxyz_Dims,rxyz_Rank,capi_rxyz_intent,rxyz_capi);
  if (capi_rxyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `rxyz' of lib.mbd.t_1mexp_coulomb to C/Fortran array" );
  } else {
    rxyz = (double *)(PyArray_DATA(capi_rxyz_tmp));

  /* Processing variable sigma */
    f2py_success = double_from_pyobj(&sigma,sigma_capi,"lib.mbd.t_1mexp_coulomb() 2nd argument (sigma) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.t_1mexp_coulomb() 3rd argument (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable t_1mexp_coulomb */
  t_1mexp_coulomb_Dims[0]=3,t_1mexp_coulomb_Dims[1]=3;
  capi_t_1mexp_coulomb_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_t_1mexp_coulomb_tmp = array_from_pyobj(NPY_DOUBLE,t_1mexp_coulomb_Dims,t_1mexp_coulomb_Rank,capi_t_1mexp_coulomb_intent,Py_None);
  if (capi_t_1mexp_coulomb_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `t_1mexp_coulomb' of lib.mbd.t_1mexp_coulomb to C/Fortran array" );
  } else {
    t_1mexp_coulomb = (double *)(PyArray_DATA(capi_t_1mexp_coulomb_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(t_1mexp_coulomb,rxyz,&sigma,&a);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_t_1mexp_coulomb_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_t_1mexp_coulomb_tmp == NULL) ... else of t_1mexp_coulomb*/
  /* End of cleaning variable t_1mexp_coulomb */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of sigma*/
  /* End of cleaning variable sigma */
  if((PyObject *)capi_rxyz_tmp!=rxyz_capi) {
    Py_XDECREF(capi_rxyz_tmp); }
  }  /*if (capi_rxyz_tmp == NULL) ... else of rxyz*/
  /* End of cleaning variable rxyz */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of t_1mexp_coulomb ***************************/

/*************************** get_damping_parameters ***************************/
static char doc_f2py_rout_lib_mbd_get_damping_parameters[] = "\
ts_d,ts_s_r,mbd_scs_a,mbd_ts_a,mbd_ts_erf_beta,mbd_ts_fermi_beta,mbd_rsscs_a,mbd_rsscs_beta = get_damping_parameters(xc)\n\nWrapper for ``get_damping_parameters``.\
\n\nParameters\n----------\n"
"xc : input string(len=-1)\n"
"\nReturns\n-------\n"
"ts_d : float\n"
"ts_s_r : float\n"
"mbd_scs_a : float\n"
"mbd_ts_a : float\n"
"mbd_ts_erf_beta : float\n"
"mbd_ts_fermi_beta : float\n"
"mbd_rsscs_a : float\n"
"mbd_rsscs_beta : float";
/*  */
static PyObject *f2py_rout_lib_mbd_get_damping_parameters(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,double*,double*,double*,double*,double*,double*,double*,double*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string xc = NULL;
  int slen(xc);
  PyObject *xc_capi = Py_None;
  double ts_d = 0;
  double ts_s_r = 0;
  double mbd_scs_a = 0;
  double mbd_ts_a = 0;
  double mbd_ts_erf_beta = 0;
  double mbd_ts_fermi_beta = 0;
  double mbd_rsscs_a = 0;
  double mbd_rsscs_beta = 0;
  static char *capi_kwlist[] = {"xc",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.get_damping_parameters",\
    capi_kwlist,&xc_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable xc */
  slen(xc) = -1;
  f2py_success = string_from_pyobj(&xc,&slen(xc),"",xc_capi,"string_from_pyobj failed in converting 1st argument `xc' of lib.mbd.get_damping_parameters to C string");
  if (f2py_success) {
  /* Processing variable ts_d */
  /* Processing variable ts_s_r */
  /* Processing variable mbd_scs_a */
  /* Processing variable mbd_ts_a */
  /* Processing variable mbd_ts_erf_beta */
  /* Processing variable mbd_ts_fermi_beta */
  /* Processing variable mbd_rsscs_a */
  /* Processing variable mbd_rsscs_beta */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(xc,&ts_d,&ts_s_r,&mbd_scs_a,&mbd_ts_a,&mbd_ts_erf_beta,&mbd_ts_fermi_beta,&mbd_rsscs_a,&mbd_rsscs_beta,slen(xc));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("dddddddd",ts_d,ts_s_r,mbd_scs_a,mbd_ts_a,mbd_ts_erf_beta,mbd_ts_fermi_beta,mbd_rsscs_a,mbd_rsscs_beta);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable mbd_rsscs_beta */
  /* End of cleaning variable mbd_rsscs_a */
  /* End of cleaning variable mbd_ts_fermi_beta */
  /* End of cleaning variable mbd_ts_erf_beta */
  /* End of cleaning variable mbd_ts_a */
  /* End of cleaning variable mbd_scs_a */
  /* End of cleaning variable ts_s_r */
  /* End of cleaning variable ts_d */
    STRINGFREE(xc);
  }  /*if (f2py_success) of xc*/
  /* End of cleaning variable xc */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*********************** end of get_damping_parameters ***********************/

/******************************* solve_lin_sys *******************************/
static char doc_f2py_rout_lib_mbd_solve_lin_sys[] = "\
x = solve_lin_sys(a,b)\n\nWrapper for ``solve_lin_sys``.\
\n\nParameters\n----------\n"
"a : input rank-2 array('d') with bounds (f2py_a_d0,f2py_a_d1)\n"
"b : input rank-1 array('d') with bounds (size(a, 1))\n"
"\nReturns\n-------\n"
"x : rank-1 array('d') with bounds (size(b)) and solve_lin_sys storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_solve_lin_sys(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *solve_lin_sys = NULL;
  npy_intp solve_lin_sys_Dims[1] = {-1};
  const int solve_lin_sys_Rank = 1;
  PyArrayObject *capi_solve_lin_sys_tmp = NULL;
  int capi_solve_lin_sys_intent = 0;
  double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  double *b = NULL;
  npy_intp b_Dims[1] = {-1};
  const int b_Rank = 1;
  PyArrayObject *capi_b_tmp = NULL;
  int capi_b_intent = 0;
  PyObject *b_capi = Py_None;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"a","b",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.solve_lin_sys",\
    capi_kwlist,&a_capi,&b_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_IN;
  capi_a_tmp = array_from_pyobj(NPY_DOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `a' of lib.mbd.solve_lin_sys to C/Fortran array" );
  } else {
    a = (double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable b */
  b_Dims[0]=size(a, 1);
  capi_b_intent |= F2PY_INTENT_IN;
  capi_b_tmp = array_from_pyobj(NPY_DOUBLE,b_Dims,b_Rank,capi_b_intent,b_capi);
  if (capi_b_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `b' of lib.mbd.solve_lin_sys to C/Fortran array" );
  } else {
    b = (double *)(PyArray_DATA(capi_b_tmp));

  /* Processing variable solve_lin_sys */
  solve_lin_sys_Dims[0]=size(b);
  capi_solve_lin_sys_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_solve_lin_sys_tmp = array_from_pyobj(NPY_DOUBLE,solve_lin_sys_Dims,solve_lin_sys_Rank,capi_solve_lin_sys_intent,Py_None);
  if (capi_solve_lin_sys_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `solve_lin_sys' of lib.mbd.solve_lin_sys to C/Fortran array" );
  } else {
    solve_lin_sys = (double *)(PyArray_DATA(capi_solve_lin_sys_tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(solve_lin_sys,a,b,&f2py_a_d0,&f2py_a_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_solve_lin_sys_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  }  /*if (capi_solve_lin_sys_tmp == NULL) ... else of solve_lin_sys*/
  /* End of cleaning variable solve_lin_sys */
  if((PyObject *)capi_b_tmp!=b_capi) {
    Py_XDECREF(capi_b_tmp); }
  }  /*if (capi_b_tmp == NULL) ... else of b*/
  /* End of cleaning variable b */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of solve_lin_sys ****************************/

/****************************** supercell_circum ******************************/
static char doc_f2py_rout_lib_mbd_supercell_circum[] = "\
sc = supercell_circum(uc,radius)\n\nWrapper for ``supercell_circum``.\
\n\nParameters\n----------\n"
"uc : input rank-2 array('d') with bounds (3,3)\n"
"radius : input float\n"
"\nReturns\n-------\n"
"sc : rank-1 array('i') with bounds (3) and supercell_circum storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_supercell_circum(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int *supercell_circum = NULL;
  npy_intp supercell_circum_Dims[1] = {-1};
  const int supercell_circum_Rank = 1;
  PyArrayObject *capi_supercell_circum_tmp = NULL;
  int capi_supercell_circum_intent = 0;
  double *uc = NULL;
  npy_intp uc_Dims[2] = {-1, -1};
  const int uc_Rank = 2;
  PyArrayObject *capi_uc_tmp = NULL;
  int capi_uc_intent = 0;
  PyObject *uc_capi = Py_None;
  double radius = 0;
  PyObject *radius_capi = Py_None;
  static char *capi_kwlist[] = {"uc","radius",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.supercell_circum",\
    capi_kwlist,&uc_capi,&radius_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable uc */
  uc_Dims[0]=3,uc_Dims[1]=3;
  capi_uc_intent |= F2PY_INTENT_IN;
  capi_uc_tmp = array_from_pyobj(NPY_DOUBLE,uc_Dims,uc_Rank,capi_uc_intent,uc_capi);
  if (capi_uc_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `uc' of lib.mbd.supercell_circum to C/Fortran array" );
  } else {
    uc = (double *)(PyArray_DATA(capi_uc_tmp));

  /* Processing variable radius */
    f2py_success = double_from_pyobj(&radius,radius_capi,"lib.mbd.supercell_circum() 2nd argument (radius) can't be converted to double");
  if (f2py_success) {
  /* Processing variable supercell_circum */
  supercell_circum_Dims[0]=3;
  capi_supercell_circum_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_supercell_circum_tmp = array_from_pyobj(NPY_INT,supercell_circum_Dims,supercell_circum_Rank,capi_supercell_circum_intent,Py_None);
  if (capi_supercell_circum_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `supercell_circum' of lib.mbd.supercell_circum to C/Fortran array" );
  } else {
    supercell_circum = (int *)(PyArray_DATA(capi_supercell_circum_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(supercell_circum,uc,&radius);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_supercell_circum_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_supercell_circum_tmp == NULL) ... else of supercell_circum*/
  /* End of cleaning variable supercell_circum */
  } /*if (f2py_success) of radius*/
  /* End of cleaning variable radius */
  if((PyObject *)capi_uc_tmp!=uc_capi) {
    Py_XDECREF(capi_uc_tmp); }
  }  /*if (capi_uc_tmp == NULL) ... else of uc*/
  /* End of cleaning variable uc */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of supercell_circum **************************/

/********************************* shift_cell *********************************/
static char doc_f2py_rout_lib_mbd_shift_cell[] = "\
shift_cell(ijk,first_cell,last_cell)\n\nWrapper for ``shift_cell``.\
\n\nParameters\n----------\n"
"ijk : in/output rank-1 array('i') with bounds (3)\n"
"first_cell : input rank-1 array('i') with bounds (3)\n"
"last_cell : input rank-1 array('i') with bounds (3)";
/*  */
static PyObject *f2py_rout_lib_mbd_shift_cell(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int *ijk = NULL;
  npy_intp ijk_Dims[1] = {-1};
  const int ijk_Rank = 1;
  PyArrayObject *capi_ijk_tmp = NULL;
  int capi_ijk_intent = 0;
  PyObject *ijk_capi = Py_None;
  int *first_cell = NULL;
  npy_intp first_cell_Dims[1] = {-1};
  const int first_cell_Rank = 1;
  PyArrayObject *capi_first_cell_tmp = NULL;
  int capi_first_cell_intent = 0;
  PyObject *first_cell_capi = Py_None;
  int *last_cell = NULL;
  npy_intp last_cell_Dims[1] = {-1};
  const int last_cell_Rank = 1;
  PyArrayObject *capi_last_cell_tmp = NULL;
  int capi_last_cell_intent = 0;
  PyObject *last_cell_capi = Py_None;
  static char *capi_kwlist[] = {"ijk","first_cell","last_cell",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd.shift_cell",\
    capi_kwlist,&ijk_capi,&first_cell_capi,&last_cell_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable ijk */
  ijk_Dims[0]=3;
  capi_ijk_intent |= F2PY_INTENT_INOUT;
  capi_ijk_tmp = array_from_pyobj(NPY_INT,ijk_Dims,ijk_Rank,capi_ijk_intent,ijk_capi);
  if (capi_ijk_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `ijk' of lib.mbd.shift_cell to C/Fortran array" );
  } else {
    ijk = (int *)(PyArray_DATA(capi_ijk_tmp));

  /* Processing variable first_cell */
  first_cell_Dims[0]=3;
  capi_first_cell_intent |= F2PY_INTENT_IN;
  capi_first_cell_tmp = array_from_pyobj(NPY_INT,first_cell_Dims,first_cell_Rank,capi_first_cell_intent,first_cell_capi);
  if (capi_first_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `first_cell' of lib.mbd.shift_cell to C/Fortran array" );
  } else {
    first_cell = (int *)(PyArray_DATA(capi_first_cell_tmp));

  /* Processing variable last_cell */
  last_cell_Dims[0]=3;
  capi_last_cell_intent |= F2PY_INTENT_IN;
  capi_last_cell_tmp = array_from_pyobj(NPY_INT,last_cell_Dims,last_cell_Rank,capi_last_cell_intent,last_cell_capi);
  if (capi_last_cell_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `last_cell' of lib.mbd.shift_cell to C/Fortran array" );
  } else {
    last_cell = (int *)(PyArray_DATA(capi_last_cell_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(ijk,first_cell,last_cell);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_last_cell_tmp!=last_cell_capi) {
    Py_XDECREF(capi_last_cell_tmp); }
  }  /*if (capi_last_cell_tmp == NULL) ... else of last_cell*/
  /* End of cleaning variable last_cell */
  if((PyObject *)capi_first_cell_tmp!=first_cell_capi) {
    Py_XDECREF(capi_first_cell_tmp); }
  }  /*if (capi_first_cell_tmp == NULL) ... else of first_cell*/
  /* End of cleaning variable first_cell */
  if((PyObject *)capi_ijk_tmp!=ijk_capi) {
    Py_XDECREF(capi_ijk_tmp); }
  }  /*if (capi_ijk_tmp == NULL) ... else of ijk*/
  /* End of cleaning variable ijk */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of shift_cell *****************************/

/************************************ eye ************************************/
static char doc_f2py_rout_lib_mbd_eye[] = "\
a = eye(n)\n\nWrapper for ``eye``.\
\n\nParameters\n----------\n"
"n : input int\n"
"\nReturns\n-------\n"
"a : rank-2 array('d') with bounds (n,n) and eye storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_eye(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *eye = NULL;
  npy_intp eye_Dims[2] = {-1, -1};
  const int eye_Rank = 2;
  PyArrayObject *capi_eye_tmp = NULL;
  int capi_eye_intent = 0;
  int n = 0;
  PyObject *n_capi = Py_None;
  static char *capi_kwlist[] = {"n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.eye",\
    capi_kwlist,&n_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable n */
    f2py_success = int_from_pyobj(&n,n_capi,"lib.mbd.eye() 1st argument (n) can't be converted to int");
  if (f2py_success) {
  /* Processing variable eye */
  eye_Dims[0]=n,eye_Dims[1]=n;
  capi_eye_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_eye_tmp = array_from_pyobj(NPY_DOUBLE,eye_Dims,eye_Rank,capi_eye_intent,Py_None);
  if (capi_eye_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `eye' of lib.mbd.eye to C/Fortran array" );
  } else {
    eye = (double *)(PyArray_DATA(capi_eye_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(eye,&n);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_eye_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_eye_tmp == NULL) ... else of eye*/
  /* End of cleaning variable eye */
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/********************************* end of eye *********************************/

/************************************ terf ************************************/
static char doc_f2py_rout_lib_mbd_terf[] = "\
terf = terf(r,r0,a)\n\nWrapper for ``terf``.\
\n\nParameters\n----------\n"
"r : input float\n"
"r0 : input float\n"
"a : input float\n"
"\nReturns\n-------\n"
"terf : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_terf(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double terf = 0;
  double r = 0;
  PyObject *r_capi = Py_None;
  double r0 = 0;
  PyObject *r0_capi = Py_None;
  double a = 0;
  PyObject *a_capi = Py_None;
  static char *capi_kwlist[] = {"r","r0","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd.terf",\
    capi_kwlist,&r_capi,&r0_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable r */
    f2py_success = double_from_pyobj(&r,r_capi,"lib.mbd.terf() 1st argument (r) can't be converted to double");
  if (f2py_success) {
  /* Processing variable r0 */
    f2py_success = double_from_pyobj(&r0,r0_capi,"lib.mbd.terf() 2nd argument (r0) can't be converted to double");
  if (f2py_success) {
  /* Processing variable a */
    f2py_success = double_from_pyobj(&a,a_capi,"lib.mbd.terf() 3rd argument (a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable terf */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&terf,&r,&r0,&a);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",terf);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable terf */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
  } /*if (f2py_success) of r0*/
  /* End of cleaning variable r0 */
  } /*if (f2py_success) of r*/
  /* End of cleaning variable r */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of terf ********************************/

/****************************** invert_ge_dble_ ******************************/
static char doc_f2py_rout_lib_mbd_invert_ge_dble_[] = "\
invert_ge_dble_(a)\n\nWrapper for ``invert_ge_dble_``.\
\n\nParameters\n----------\n"
"a : in/output rank-2 array('d') with bounds (f2py_a_d0,f2py_a_d1)";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_invert_ge_dble_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.invert_ge_dble_",\
    capi_kwlist,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_INOUT;
  capi_a_tmp = array_from_pyobj(NPY_DOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `a' of lib.mbd.invert_ge_dble_ to C/Fortran array" );
  } else {
    a = (double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(a,&f2py_a_d0,&f2py_a_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of invert_ge_dble_ ***************************/

/****************************** invert_ge_cmplx_ ******************************/
static char doc_f2py_rout_lib_mbd_invert_ge_cmplx_[] = "\
invert_ge_cmplx_(a)\n\nWrapper for ``invert_ge_cmplx_``.\
\n\nParameters\n----------\n"
"a : in/output rank-2 array('D') with bounds (f2py_a_d0,f2py_a_d1)";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_invert_ge_cmplx_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(complex_double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  complex_double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.invert_ge_cmplx_",\
    capi_kwlist,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_INOUT;
  capi_a_tmp = array_from_pyobj(NPY_CDOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `a' of lib.mbd.invert_ge_cmplx_ to C/Fortran array" );
  } else {
    a = (complex_double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(a,&f2py_a_d0,&f2py_a_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of invert_ge_cmplx_ **************************/

/********************************** inverted **********************************/
static char doc_f2py_rout_lib_mbd_inverted[] = "\
a_inv = inverted(a)\n\nWrapper for ``inverted``.\
\n\nParameters\n----------\n"
"a : input rank-2 array('d') with bounds (f2py_a_d0,f2py_a_d1)\n"
"\nReturns\n-------\n"
"a_inv : rank-2 array('d') with bounds (size(a, 1),size(a, 2)) and inverted storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_inverted(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *inverted = NULL;
  npy_intp inverted_Dims[2] = {-1, -1};
  const int inverted_Rank = 2;
  PyArrayObject *capi_inverted_tmp = NULL;
  int capi_inverted_intent = 0;
  double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.inverted",\
    capi_kwlist,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_IN;
  capi_a_tmp = array_from_pyobj(NPY_DOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `a' of lib.mbd.inverted to C/Fortran array" );
  } else {
    a = (double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable inverted */
  inverted_Dims[0]=size(a, 1),inverted_Dims[1]=size(a, 2);
  capi_inverted_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_inverted_tmp = array_from_pyobj(NPY_DOUBLE,inverted_Dims,inverted_Rank,capi_inverted_intent,Py_None);
  if (capi_inverted_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `inverted' of lib.mbd.inverted to C/Fortran array" );
  } else {
    inverted = (double *)(PyArray_DATA(capi_inverted_tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(inverted,a,&f2py_a_d0,&f2py_a_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_inverted_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  }  /*if (capi_inverted_tmp == NULL) ... else of inverted*/
  /* End of cleaning variable inverted */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of inverted ******************************/

/*************************** diagonalize_sym_dble_ ***************************/
static char doc_f2py_rout_lib_mbd_diagonalize_sym_dble_[] = "\
eigs = diagonalize_sym_dble_(mode,a)\n\nWrapper for ``diagonalize_sym_dble_``.\
\n\nParameters\n----------\n"
"mode : input string(len=1)\n"
"a : in/output rank-2 array('d') with bounds (f2py_a_d0,f2py_a_d1)\n"
"\nReturns\n-------\n"
"eigs : rank-1 array('d') with bounds (size(a, 1))";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_diagonalize_sym_dble_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,double*,double*,int*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  double *eigs = NULL;
  npy_intp eigs_Dims[1] = {-1};
  const int eigs_Rank = 1;
  PyArrayObject *capi_eigs_tmp = NULL;
  int capi_eigs_intent = 0;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"mode","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.diagonalize_sym_dble_",\
    capi_kwlist,&mode_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = 1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.diagonalize_sym_dble_ to C string");
  if (f2py_success) {
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_INOUT;
  capi_a_tmp = array_from_pyobj(NPY_DOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `a' of lib.mbd.diagonalize_sym_dble_ to C/Fortran array" );
  } else {
    a = (double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable eigs */
  eigs_Dims[0]=size(a, 1);
  capi_eigs_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_eigs_tmp = array_from_pyobj(NPY_DOUBLE,eigs_Dims,eigs_Rank,capi_eigs_intent,Py_None);
  if (capi_eigs_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `eigs' of lib.mbd.diagonalize_sym_dble_ to C/Fortran array" );
  } else {
    eigs = (double *)(PyArray_DATA(capi_eigs_tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(mode,a,eigs,&f2py_a_d0,&f2py_a_d1,slen(mode));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_eigs_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  }  /*if (capi_eigs_tmp == NULL) ... else of eigs*/
  /* End of cleaning variable eigs */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of diagonalize_sym_dble_ ************************/

/*************************** diagonalized_sym_dble_ ***************************/
static char doc_f2py_rout_lib_mbd_diagonalized_sym_dble_[] = "\
eigs,eigvecs = diagonalized_sym_dble_(a)\n\nWrapper for ``diagonalized_sym_dble_``.\
\n\nParameters\n----------\n"
"a : input rank-2 array('d') with bounds (f2py_a_d0,f2py_a_d1)\n"
"\nReturns\n-------\n"
"eigs : rank-1 array('d') with bounds (size(a, 1)) and diagonalized_sym_dble_ storage\n"
"eigvecs : rank-2 array('d') with bounds (size(a, 1),size(a, 2))";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_diagonalized_sym_dble_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *diagonalized_sym_dble_ = NULL;
  npy_intp diagonalized_sym_dble__Dims[1] = {-1};
  const int diagonalized_sym_dble__Rank = 1;
  PyArrayObject *capi_diagonalized_sym_dble__tmp = NULL;
  int capi_diagonalized_sym_dble__intent = 0;
  double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  double *eigvecs = NULL;
  npy_intp eigvecs_Dims[2] = {-1, -1};
  const int eigvecs_Rank = 2;
  PyArrayObject *capi_eigvecs_tmp = NULL;
  int capi_eigvecs_intent = 0;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.diagonalized_sym_dble_",\
    capi_kwlist,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_IN;
  capi_a_tmp = array_from_pyobj(NPY_DOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `a' of lib.mbd.diagonalized_sym_dble_ to C/Fortran array" );
  } else {
    a = (double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable eigvecs */
  eigvecs_Dims[0]=size(a, 1),eigvecs_Dims[1]=size(a, 2);
  capi_eigvecs_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_eigvecs_tmp = array_from_pyobj(NPY_DOUBLE,eigvecs_Dims,eigvecs_Rank,capi_eigvecs_intent,Py_None);
  if (capi_eigvecs_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `eigvecs' of lib.mbd.diagonalized_sym_dble_ to C/Fortran array" );
  } else {
    eigvecs = (double *)(PyArray_DATA(capi_eigvecs_tmp));

  /* Processing variable diagonalized_sym_dble_ */
  diagonalized_sym_dble__Dims[0]=size(a, 1);
  capi_diagonalized_sym_dble__intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_diagonalized_sym_dble__tmp = array_from_pyobj(NPY_DOUBLE,diagonalized_sym_dble__Dims,diagonalized_sym_dble__Rank,capi_diagonalized_sym_dble__intent,Py_None);
  if (capi_diagonalized_sym_dble__tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `diagonalized_sym_dble_' of lib.mbd.diagonalized_sym_dble_ to C/Fortran array" );
  } else {
    diagonalized_sym_dble_ = (double *)(PyArray_DATA(capi_diagonalized_sym_dble__tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(diagonalized_sym_dble_,a,eigvecs,&f2py_a_d0,&f2py_a_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("NN",capi_diagonalized_sym_dble__tmp,capi_eigvecs_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  }  /*if (capi_diagonalized_sym_dble__tmp == NULL) ... else of diagonalized_sym_dble_*/
  /* End of cleaning variable diagonalized_sym_dble_ */
  }  /*if (capi_eigvecs_tmp == NULL) ... else of eigvecs*/
  /* End of cleaning variable eigvecs */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*********************** end of diagonalized_sym_dble_ ***********************/

/**************************** diagonalize_ge_dble_ ****************************/
static char doc_f2py_rout_lib_mbd_diagonalize_ge_dble_[] = "\
eigs = diagonalize_ge_dble_(mode,a)\n\nWrapper for ``diagonalize_ge_dble_``.\
\n\nParameters\n----------\n"
"mode : input string(len=1)\n"
"a : in/output rank-2 array('d') with bounds (f2py_a_d0,f2py_a_d1)\n"
"\nReturns\n-------\n"
"eigs : rank-1 array('D') with bounds (size(a, 1))";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_diagonalize_ge_dble_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,double*,complex_double*,int*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  complex_double *eigs = NULL;
  npy_intp eigs_Dims[1] = {-1};
  const int eigs_Rank = 1;
  PyArrayObject *capi_eigs_tmp = NULL;
  int capi_eigs_intent = 0;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"mode","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.diagonalize_ge_dble_",\
    capi_kwlist,&mode_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = 1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.diagonalize_ge_dble_ to C string");
  if (f2py_success) {
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_INOUT;
  capi_a_tmp = array_from_pyobj(NPY_DOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `a' of lib.mbd.diagonalize_ge_dble_ to C/Fortran array" );
  } else {
    a = (double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable eigs */
  eigs_Dims[0]=size(a, 1);
  capi_eigs_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_eigs_tmp = array_from_pyobj(NPY_CDOUBLE,eigs_Dims,eigs_Rank,capi_eigs_intent,Py_None);
  if (capi_eigs_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `eigs' of lib.mbd.diagonalize_ge_dble_ to C/Fortran array" );
  } else {
    eigs = (complex_double *)(PyArray_DATA(capi_eigs_tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(mode,a,eigs,&f2py_a_d0,&f2py_a_d1,slen(mode));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_eigs_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  }  /*if (capi_eigs_tmp == NULL) ... else of eigs*/
  /* End of cleaning variable eigs */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of diagonalize_ge_dble_ ************************/

/*************************** diagonalized_ge_dble_ ***************************/
static char doc_f2py_rout_lib_mbd_diagonalized_ge_dble_[] = "\
eigs,eigvecs = diagonalized_ge_dble_(a)\n\nWrapper for ``diagonalized_ge_dble_``.\
\n\nParameters\n----------\n"
"a : input rank-2 array('d') with bounds (f2py_a_d0,f2py_a_d1)\n"
"\nReturns\n-------\n"
"eigs : rank-1 array('D') with bounds (size(a, 1)) and diagonalized_ge_dble_ storage\n"
"eigvecs : rank-2 array('d') with bounds (size(a, 1),size(a, 2))";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_diagonalized_ge_dble_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(complex_double*,double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  complex_double *diagonalized_ge_dble_ = NULL;
  npy_intp diagonalized_ge_dble__Dims[1] = {-1};
  const int diagonalized_ge_dble__Rank = 1;
  PyArrayObject *capi_diagonalized_ge_dble__tmp = NULL;
  int capi_diagonalized_ge_dble__intent = 0;
  double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  double *eigvecs = NULL;
  npy_intp eigvecs_Dims[2] = {-1, -1};
  const int eigvecs_Rank = 2;
  PyArrayObject *capi_eigvecs_tmp = NULL;
  int capi_eigvecs_intent = 0;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.diagonalized_ge_dble_",\
    capi_kwlist,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_IN;
  capi_a_tmp = array_from_pyobj(NPY_DOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `a' of lib.mbd.diagonalized_ge_dble_ to C/Fortran array" );
  } else {
    a = (double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable eigvecs */
  eigvecs_Dims[0]=size(a, 1),eigvecs_Dims[1]=size(a, 2);
  capi_eigvecs_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_eigvecs_tmp = array_from_pyobj(NPY_DOUBLE,eigvecs_Dims,eigvecs_Rank,capi_eigvecs_intent,Py_None);
  if (capi_eigvecs_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `eigvecs' of lib.mbd.diagonalized_ge_dble_ to C/Fortran array" );
  } else {
    eigvecs = (double *)(PyArray_DATA(capi_eigvecs_tmp));

  /* Processing variable diagonalized_ge_dble_ */
  diagonalized_ge_dble__Dims[0]=size(a, 1);
  capi_diagonalized_ge_dble__intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_diagonalized_ge_dble__tmp = array_from_pyobj(NPY_CDOUBLE,diagonalized_ge_dble__Dims,diagonalized_ge_dble__Rank,capi_diagonalized_ge_dble__intent,Py_None);
  if (capi_diagonalized_ge_dble__tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `diagonalized_ge_dble_' of lib.mbd.diagonalized_ge_dble_ to C/Fortran array" );
  } else {
    diagonalized_ge_dble_ = (complex_double *)(PyArray_DATA(capi_diagonalized_ge_dble__tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(diagonalized_ge_dble_,a,eigvecs,&f2py_a_d0,&f2py_a_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("NN",capi_diagonalized_ge_dble__tmp,capi_eigvecs_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  }  /*if (capi_diagonalized_ge_dble__tmp == NULL) ... else of diagonalized_ge_dble_*/
  /* End of cleaning variable diagonalized_ge_dble_ */
  }  /*if (capi_eigvecs_tmp == NULL) ... else of eigvecs*/
  /* End of cleaning variable eigvecs */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of diagonalized_ge_dble_ ************************/

/*************************** diagonalize_he_cmplx_ ***************************/
static char doc_f2py_rout_lib_mbd_diagonalize_he_cmplx_[] = "\
eigs = diagonalize_he_cmplx_(mode,a)\n\nWrapper for ``diagonalize_he_cmplx_``.\
\n\nParameters\n----------\n"
"mode : input string(len=1)\n"
"a : in/output rank-2 array('D') with bounds (f2py_a_d0,f2py_a_d1)\n"
"\nReturns\n-------\n"
"eigs : rank-1 array('d') with bounds (size(a, 1))";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_diagonalize_he_cmplx_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,complex_double*,double*,int*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  complex_double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  double *eigs = NULL;
  npy_intp eigs_Dims[1] = {-1};
  const int eigs_Rank = 1;
  PyArrayObject *capi_eigs_tmp = NULL;
  int capi_eigs_intent = 0;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"mode","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.diagonalize_he_cmplx_",\
    capi_kwlist,&mode_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = 1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.diagonalize_he_cmplx_ to C string");
  if (f2py_success) {
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_INOUT;
  capi_a_tmp = array_from_pyobj(NPY_CDOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `a' of lib.mbd.diagonalize_he_cmplx_ to C/Fortran array" );
  } else {
    a = (complex_double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable eigs */
  eigs_Dims[0]=size(a, 1);
  capi_eigs_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_eigs_tmp = array_from_pyobj(NPY_DOUBLE,eigs_Dims,eigs_Rank,capi_eigs_intent,Py_None);
  if (capi_eigs_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `eigs' of lib.mbd.diagonalize_he_cmplx_ to C/Fortran array" );
  } else {
    eigs = (double *)(PyArray_DATA(capi_eigs_tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(mode,a,eigs,&f2py_a_d0,&f2py_a_d1,slen(mode));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_eigs_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  }  /*if (capi_eigs_tmp == NULL) ... else of eigs*/
  /* End of cleaning variable eigs */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of diagonalize_he_cmplx_ ************************/

/*************************** diagonalize_ge_cmplx_ ***************************/
static char doc_f2py_rout_lib_mbd_diagonalize_ge_cmplx_[] = "\
eigs = diagonalize_ge_cmplx_(mode,a)\n\nWrapper for ``diagonalize_ge_cmplx_``.\
\n\nParameters\n----------\n"
"mode : input string(len=1)\n"
"a : in/output rank-2 array('D') with bounds (f2py_a_d0,f2py_a_d1)\n"
"\nReturns\n-------\n"
"eigs : rank-1 array('D') with bounds (size(a, 1))";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_diagonalize_ge_cmplx_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,complex_double*,complex_double*,int*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string mode = NULL;
  int slen(mode);
  PyObject *mode_capi = Py_None;
  complex_double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  complex_double *eigs = NULL;
  npy_intp eigs_Dims[1] = {-1};
  const int eigs_Rank = 1;
  PyArrayObject *capi_eigs_tmp = NULL;
  int capi_eigs_intent = 0;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"mode","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.diagonalize_ge_cmplx_",\
    capi_kwlist,&mode_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mode */
  slen(mode) = 1;
  f2py_success = string_from_pyobj(&mode,&slen(mode),"",mode_capi,"string_from_pyobj failed in converting 1st argument `mode' of lib.mbd.diagonalize_ge_cmplx_ to C string");
  if (f2py_success) {
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_INOUT;
  capi_a_tmp = array_from_pyobj(NPY_CDOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `a' of lib.mbd.diagonalize_ge_cmplx_ to C/Fortran array" );
  } else {
    a = (complex_double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable eigs */
  eigs_Dims[0]=size(a, 1);
  capi_eigs_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_eigs_tmp = array_from_pyobj(NPY_CDOUBLE,eigs_Dims,eigs_Rank,capi_eigs_intent,Py_None);
  if (capi_eigs_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `eigs' of lib.mbd.diagonalize_ge_cmplx_ to C/Fortran array" );
  } else {
    eigs = (complex_double *)(PyArray_DATA(capi_eigs_tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(mode,a,eigs,&f2py_a_d0,&f2py_a_d1,slen(mode));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_eigs_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  }  /*if (capi_eigs_tmp == NULL) ... else of eigs*/
  /* End of cleaning variable eigs */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
    STRINGFREE(mode);
  }  /*if (f2py_success) of mode*/
  /* End of cleaning variable mode */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of diagonalize_ge_cmplx_ ************************/

/********************************* cart_prod_ *********************************/
static char doc_f2py_rout_lib_mbd_cart_prod_[] = "\
c = cart_prod_(a,b)\n\nWrapper for ``cart_prod_``.\
\n\nParameters\n----------\n"
"a : input rank-1 array('d') with bounds (f2py_a_d0)\n"
"b : input rank-1 array('d') with bounds (f2py_b_d0)\n"
"\nReturns\n-------\n"
"c : rank-2 array('d') with bounds (size(a),size(b)) and cart_prod_ storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_cart_prod_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *cart_prod_ = NULL;
  npy_intp cart_prod__Dims[2] = {-1, -1};
  const int cart_prod__Rank = 2;
  PyArrayObject *capi_cart_prod__tmp = NULL;
  int capi_cart_prod__intent = 0;
  double *a = NULL;
  npy_intp a_Dims[1] = {-1};
  const int a_Rank = 1;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  double *b = NULL;
  npy_intp b_Dims[1] = {-1};
  const int b_Rank = 1;
  PyArrayObject *capi_b_tmp = NULL;
  int capi_b_intent = 0;
  PyObject *b_capi = Py_None;
  int f2py_a_d0 = 0;
  int f2py_b_d0 = 0;
  static char *capi_kwlist[] = {"a","b",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd.cart_prod_",\
    capi_kwlist,&a_capi,&b_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_IN;
  capi_a_tmp = array_from_pyobj(NPY_DOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `a' of lib.mbd.cart_prod_ to C/Fortran array" );
  } else {
    a = (double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable b */
  ;
  capi_b_intent |= F2PY_INTENT_IN;
  capi_b_tmp = array_from_pyobj(NPY_DOUBLE,b_Dims,b_Rank,capi_b_intent,b_capi);
  if (capi_b_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `b' of lib.mbd.cart_prod_ to C/Fortran array" );
  } else {
    b = (double *)(PyArray_DATA(capi_b_tmp));

  /* Processing variable cart_prod_ */
  cart_prod__Dims[0]=size(a),cart_prod__Dims[1]=size(b);
  capi_cart_prod__intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_cart_prod__tmp = array_from_pyobj(NPY_DOUBLE,cart_prod__Dims,cart_prod__Rank,capi_cart_prod__intent,Py_None);
  if (capi_cart_prod__tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `cart_prod_' of lib.mbd.cart_prod_ to C/Fortran array" );
  } else {
    cart_prod_ = (double *)(PyArray_DATA(capi_cart_prod__tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_b_d0 */
  f2py_b_d0 = shape(b, 0);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(cart_prod_,a,b,&f2py_a_d0,&f2py_b_d0);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_cart_prod__tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_b_d0 */
  /* End of cleaning variable f2py_a_d0 */
  }  /*if (capi_cart_prod__tmp == NULL) ... else of cart_prod_*/
  /* End of cleaning variable cart_prod_ */
  if((PyObject *)capi_b_tmp!=b_capi) {
    Py_XDECREF(capi_b_tmp); }
  }  /*if (capi_b_tmp == NULL) ... else of b*/
  /* End of cleaning variable b */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of cart_prod_ *****************************/

/********************************* get_diag_ *********************************/
static char doc_f2py_rout_lib_mbd_get_diag_[] = "\
d = get_diag_(a)\n\nWrapper for ``get_diag_``.\
\n\nParameters\n----------\n"
"a : input rank-2 array('d') with bounds (f2py_a_d0,f2py_a_d1)\n"
"\nReturns\n-------\n"
"d : rank-1 array('d') with bounds (size(a, 1)) and get_diag_ storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_diag_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *get_diag_ = NULL;
  npy_intp get_diag__Dims[1] = {-1};
  const int get_diag__Rank = 1;
  PyArrayObject *capi_get_diag__tmp = NULL;
  int capi_get_diag__intent = 0;
  double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.get_diag_",\
    capi_kwlist,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_IN;
  capi_a_tmp = array_from_pyobj(NPY_DOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `a' of lib.mbd.get_diag_ to C/Fortran array" );
  } else {
    a = (double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable get_diag_ */
  get_diag__Dims[0]=size(a, 1);
  capi_get_diag__intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_get_diag__tmp = array_from_pyobj(NPY_DOUBLE,get_diag__Dims,get_diag__Rank,capi_get_diag__intent,Py_None);
  if (capi_get_diag__tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `get_diag_' of lib.mbd.get_diag_ to C/Fortran array" );
  } else {
    get_diag_ = (double *)(PyArray_DATA(capi_get_diag__tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(get_diag_,a,&f2py_a_d0,&f2py_a_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_get_diag__tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  }  /*if (capi_get_diag__tmp == NULL) ... else of get_diag_*/
  /* End of cleaning variable get_diag_ */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of get_diag_ ******************************/

/****************************** get_diag_cmplx_ ******************************/
static char doc_f2py_rout_lib_mbd_get_diag_cmplx_[] = "\
d = get_diag_cmplx_(a)\n\nWrapper for ``get_diag_cmplx_``.\
\n\nParameters\n----------\n"
"a : input rank-2 array('D') with bounds (f2py_a_d0,f2py_a_d1)\n"
"\nReturns\n-------\n"
"d : rank-1 array('D') with bounds (size(a, 1)) and get_diag_cmplx_ storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_get_diag_cmplx_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(complex_double*,complex_double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  complex_double *get_diag_cmplx_ = NULL;
  npy_intp get_diag_cmplx__Dims[1] = {-1};
  const int get_diag_cmplx__Rank = 1;
  PyArrayObject *capi_get_diag_cmplx__tmp = NULL;
  int capi_get_diag_cmplx__intent = 0;
  complex_double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.get_diag_cmplx_",\
    capi_kwlist,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_IN;
  capi_a_tmp = array_from_pyobj(NPY_CDOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `a' of lib.mbd.get_diag_cmplx_ to C/Fortran array" );
  } else {
    a = (complex_double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable get_diag_cmplx_ */
  get_diag_cmplx__Dims[0]=size(a, 1);
  capi_get_diag_cmplx__intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_get_diag_cmplx__tmp = array_from_pyobj(NPY_CDOUBLE,get_diag_cmplx__Dims,get_diag_cmplx__Rank,capi_get_diag_cmplx__intent,Py_None);
  if (capi_get_diag_cmplx__tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `get_diag_cmplx_' of lib.mbd.get_diag_cmplx_ to C/Fortran array" );
  } else {
    get_diag_cmplx_ = (complex_double *)(PyArray_DATA(capi_get_diag_cmplx__tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(get_diag_cmplx_,a,&f2py_a_d0,&f2py_a_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_get_diag_cmplx__tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  }  /*if (capi_get_diag_cmplx__tmp == NULL) ... else of get_diag_cmplx_*/
  /* End of cleaning variable get_diag_cmplx_ */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of get_diag_cmplx_ ***************************/

/********************************* make_diag_ *********************************/
static char doc_f2py_rout_lib_mbd_make_diag_[] = "\
a = make_diag_(d)\n\nWrapper for ``make_diag_``.\
\n\nParameters\n----------\n"
"d : input rank-1 array('d') with bounds (f2py_d_d0)\n"
"\nReturns\n-------\n"
"a : rank-2 array('d') with bounds (size(d),size(d)) and make_diag_ storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_make_diag_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *make_diag_ = NULL;
  npy_intp make_diag__Dims[2] = {-1, -1};
  const int make_diag__Rank = 2;
  PyArrayObject *capi_make_diag__tmp = NULL;
  int capi_make_diag__intent = 0;
  double *d = NULL;
  npy_intp d_Dims[1] = {-1};
  const int d_Rank = 1;
  PyArrayObject *capi_d_tmp = NULL;
  int capi_d_intent = 0;
  PyObject *d_capi = Py_None;
  int f2py_d_d0 = 0;
  static char *capi_kwlist[] = {"d",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd.make_diag_",\
    capi_kwlist,&d_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable d */
  ;
  capi_d_intent |= F2PY_INTENT_IN;
  capi_d_tmp = array_from_pyobj(NPY_DOUBLE,d_Dims,d_Rank,capi_d_intent,d_capi);
  if (capi_d_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `d' of lib.mbd.make_diag_ to C/Fortran array" );
  } else {
    d = (double *)(PyArray_DATA(capi_d_tmp));

  /* Processing variable make_diag_ */
  make_diag__Dims[0]=size(d),make_diag__Dims[1]=size(d);
  capi_make_diag__intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_make_diag__tmp = array_from_pyobj(NPY_DOUBLE,make_diag__Dims,make_diag__Rank,capi_make_diag__intent,Py_None);
  if (capi_make_diag__tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `make_diag_' of lib.mbd.make_diag_ to C/Fortran array" );
  } else {
    make_diag_ = (double *)(PyArray_DATA(capi_make_diag__tmp));

  /* Processing variable f2py_d_d0 */
  f2py_d_d0 = shape(d, 0);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(make_diag_,d,&f2py_d_d0);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_make_diag__tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_d_d0 */
  }  /*if (capi_make_diag__tmp == NULL) ... else of make_diag_*/
  /* End of cleaning variable make_diag_ */
  if((PyObject *)capi_d_tmp!=d_capi) {
    Py_XDECREF(capi_d_tmp); }
  }  /*if (capi_d_tmp == NULL) ... else of d*/
  /* End of cleaning variable d */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of make_diag_ *****************************/

/********************************* tostr_int_ *********************************/
static char doc_f2py_rout_lib_mbd_tostr_int_[] = "\
tostr_int_ = tostr_int_(k,[format])\n\nWrapper for ``tostr_int_``.\
\n\nParameters\n----------\n"
"k : input int\n"
"\nOther Parameters\n----------------\n"
"format : input string(len=-1)\n"
"\nReturns\n-------\n"
"tostr_int_ : string(len=50)";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_tostr_int_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,int*,string,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string tostr_int_ = NULL;
  int slen(tostr_int_);
  PyObject *tostr_int__capi = Py_None;
  int k = 0;
  PyObject *k_capi = Py_None;
  string format = NULL;
  int slen(format);
  PyObject *format_capi = Py_None;
  static char *capi_kwlist[] = {"k","format",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:lib.mbd.tostr_int_",\
    capi_kwlist,&k_capi,&format_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable tostr_int_ */
  slen(tostr_int_) = 50;
  f2py_success = string_from_pyobj(&tostr_int_,&slen(tostr_int_),"",tostr_int__capi,"string_from_pyobj failed in converting hidden `tostr_int_' of lib.mbd.tostr_int_ to C string");
  if (f2py_success) {
  /* Processing variable k */
    f2py_success = int_from_pyobj(&k,k_capi,"lib.mbd.tostr_int_() 1st argument (k) can't be converted to int");
  if (f2py_success) {
  /* Processing variable format */
  slen(format) = -1;
  f2py_success = string_from_pyobj(&format,&slen(format),"",format_capi,"string_from_pyobj failed in converting 1st keyword `format' of lib.mbd.tostr_int_ to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(tostr_int_,&k,format,slen(tostr_int_),slen(format));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("y",tostr_int_);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(format);
  }  /*if (f2py_success) of format*/
  /* End of cleaning variable format */
  } /*if (f2py_success) of k*/
  /* End of cleaning variable k */
    STRINGFREE(tostr_int_);
  }  /*if (f2py_success) of tostr_int_*/
  /* End of cleaning variable tostr_int_ */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of tostr_int_ *****************************/

/******************************** tostr_dble_ ********************************/
static char doc_f2py_rout_lib_mbd_tostr_dble_[] = "\
tostr_dble_ = tostr_dble_(x,[format])\n\nWrapper for ``tostr_dble_``.\
\n\nParameters\n----------\n"
"x : input float\n"
"\nOther Parameters\n----------------\n"
"format : input string(len=-1)\n"
"\nReturns\n-------\n"
"tostr_dble_ : string(len=50)";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_tostr_dble_(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,double*,string,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string tostr_dble_ = NULL;
  int slen(tostr_dble_);
  PyObject *tostr_dble__capi = Py_None;
  double x = 0;
  PyObject *x_capi = Py_None;
  string format = NULL;
  int slen(format);
  PyObject *format_capi = Py_None;
  static char *capi_kwlist[] = {"x","format",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:lib.mbd.tostr_dble_",\
    capi_kwlist,&x_capi,&format_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable tostr_dble_ */
  slen(tostr_dble_) = 50;
  f2py_success = string_from_pyobj(&tostr_dble_,&slen(tostr_dble_),"",tostr_dble__capi,"string_from_pyobj failed in converting hidden `tostr_dble_' of lib.mbd.tostr_dble_ to C string");
  if (f2py_success) {
  /* Processing variable x */
    f2py_success = double_from_pyobj(&x,x_capi,"lib.mbd.tostr_dble_() 1st argument (x) can't be converted to double");
  if (f2py_success) {
  /* Processing variable format */
  slen(format) = -1;
  f2py_success = string_from_pyobj(&format,&slen(format),"",format_capi,"string_from_pyobj failed in converting 1st keyword `format' of lib.mbd.tostr_dble_ to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(tostr_dble_,&x,format,slen(tostr_dble_),slen(format));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("y",tostr_dble_);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(format);
  }  /*if (f2py_success) of format*/
  /* End of cleaning variable format */
  } /*if (f2py_success) of x*/
  /* End of cleaning variable x */
    STRINGFREE(tostr_dble_);
  }  /*if (f2py_success) of tostr_dble_*/
  /* End of cleaning variable tostr_dble_ */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of tostr_dble_ *****************************/

/************************* calc_coulomb_coupled_gauss *************************/
static char doc_f2py_rout_lib_mbd_math_calc_coulomb_coupled_gauss[] = "\
dip,coul = calc_coulomb_coupled_gauss(r1,r2,k)\n\nWrapper for ``calc_coulomb_coupled_gauss``.\
\n\nParameters\n----------\n"
"r1 : input rank-1 array('d') with bounds (3)\n"
"r2 : input rank-1 array('d') with bounds (3)\n"
"k : input rank-2 array('d') with bounds (6,6)\n"
"\nReturns\n-------\n"
"dip : rank-2 array('d') with bounds (3,3)\n"
"coul : float";
/*  */
static PyObject *f2py_rout_lib_mbd_math_calc_coulomb_coupled_gauss(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *r1 = NULL;
  npy_intp r1_Dims[1] = {-1};
  const int r1_Rank = 1;
  PyArrayObject *capi_r1_tmp = NULL;
  int capi_r1_intent = 0;
  PyObject *r1_capi = Py_None;
  double *r2 = NULL;
  npy_intp r2_Dims[1] = {-1};
  const int r2_Rank = 1;
  PyArrayObject *capi_r2_tmp = NULL;
  int capi_r2_intent = 0;
  PyObject *r2_capi = Py_None;
  double *k = NULL;
  npy_intp k_Dims[2] = {-1, -1};
  const int k_Rank = 2;
  PyArrayObject *capi_k_tmp = NULL;
  int capi_k_intent = 0;
  PyObject *k_capi = Py_None;
  double *dip = NULL;
  npy_intp dip_Dims[2] = {-1, -1};
  const int dip_Rank = 2;
  PyArrayObject *capi_dip_tmp = NULL;
  int capi_dip_intent = 0;
  double coul = 0;
  static char *capi_kwlist[] = {"r1","r2","k",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:lib.mbd_math.calc_coulomb_coupled_gauss",\
    capi_kwlist,&r1_capi,&r2_capi,&k_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable r1 */
  r1_Dims[0]=3;
  capi_r1_intent |= F2PY_INTENT_IN;
  capi_r1_tmp = array_from_pyobj(NPY_DOUBLE,r1_Dims,r1_Rank,capi_r1_intent,r1_capi);
  if (capi_r1_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `r1' of lib.mbd_math.calc_coulomb_coupled_gauss to C/Fortran array" );
  } else {
    r1 = (double *)(PyArray_DATA(capi_r1_tmp));

  /* Processing variable r2 */
  r2_Dims[0]=3;
  capi_r2_intent |= F2PY_INTENT_IN;
  capi_r2_tmp = array_from_pyobj(NPY_DOUBLE,r2_Dims,r2_Rank,capi_r2_intent,r2_capi);
  if (capi_r2_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `r2' of lib.mbd_math.calc_coulomb_coupled_gauss to C/Fortran array" );
  } else {
    r2 = (double *)(PyArray_DATA(capi_r2_tmp));

  /* Processing variable k */
  k_Dims[0]=6,k_Dims[1]=6;
  capi_k_intent |= F2PY_INTENT_IN;
  capi_k_tmp = array_from_pyobj(NPY_DOUBLE,k_Dims,k_Rank,capi_k_intent,k_capi);
  if (capi_k_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `k' of lib.mbd_math.calc_coulomb_coupled_gauss to C/Fortran array" );
  } else {
    k = (double *)(PyArray_DATA(capi_k_tmp));

  /* Processing variable dip */
  dip_Dims[0]=3,dip_Dims[1]=3;
  capi_dip_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_dip_tmp = array_from_pyobj(NPY_DOUBLE,dip_Dims,dip_Rank,capi_dip_intent,Py_None);
  if (capi_dip_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `dip' of lib.mbd_math.calc_coulomb_coupled_gauss to C/Fortran array" );
  } else {
    dip = (double *)(PyArray_DATA(capi_dip_tmp));

  /* Processing variable coul */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(r1,r2,k,dip,&coul);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("Nd",capi_dip_tmp,coul);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable coul */
  }  /*if (capi_dip_tmp == NULL) ... else of dip*/
  /* End of cleaning variable dip */
  if((PyObject *)capi_k_tmp!=k_capi) {
    Py_XDECREF(capi_k_tmp); }
  }  /*if (capi_k_tmp == NULL) ... else of k*/
  /* End of cleaning variable k */
  if((PyObject *)capi_r2_tmp!=r2_capi) {
    Py_XDECREF(capi_r2_tmp); }
  }  /*if (capi_r2_tmp == NULL) ... else of r2*/
  /* End of cleaning variable r2 */
  if((PyObject *)capi_r1_tmp!=r1_capi) {
    Py_XDECREF(capi_r1_tmp); }
  }  /*if (capi_r1_tmp == NULL) ... else of r1*/
  /* End of cleaning variable r1 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/********************* end of calc_coulomb_coupled_gauss *********************/

/*********************** get_coulomb_energy_coupled_osc ***********************/
static char doc_f2py_rout_lib_mbd_math_get_coulomb_energy_coupled_osc[] = "\
ene = get_coulomb_energy_coupled_osc(r,q,m,w_t,c)\n\nWrapper for ``get_coulomb_energy_coupled_osc``.\
\n\nParameters\n----------\n"
"r : input rank-2 array('d') with bounds (f2py_r_d0,f2py_r_d1)\n"
"q : input rank-1 array('d') with bounds (size(r, 1))\n"
"m : input rank-1 array('d') with bounds (size(r, 1))\n"
"w_t : input rank-1 array('d') with bounds (3*size(r, 1))\n"
"c : input rank-2 array('d') with bounds (3*size(r, 1),3*size(r, 1))\n"
"\nReturns\n-------\n"
"ene : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_math_get_coulomb_energy_coupled_osc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,double*,double*,double*,double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float get_coulomb_energy_coupled_osc = 0;
  double *r = NULL;
  npy_intp r_Dims[2] = {-1, -1};
  const int r_Rank = 2;
  PyArrayObject *capi_r_tmp = NULL;
  int capi_r_intent = 0;
  PyObject *r_capi = Py_None;
  double *q = NULL;
  npy_intp q_Dims[1] = {-1};
  const int q_Rank = 1;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  PyObject *q_capi = Py_None;
  double *m = NULL;
  npy_intp m_Dims[1] = {-1};
  const int m_Rank = 1;
  PyArrayObject *capi_m_tmp = NULL;
  int capi_m_intent = 0;
  PyObject *m_capi = Py_None;
  double *w_t = NULL;
  npy_intp w_t_Dims[1] = {-1};
  const int w_t_Rank = 1;
  PyArrayObject *capi_w_t_tmp = NULL;
  int capi_w_t_intent = 0;
  PyObject *w_t_capi = Py_None;
  double *c = NULL;
  npy_intp c_Dims[2] = {-1, -1};
  const int c_Rank = 2;
  PyArrayObject *capi_c_tmp = NULL;
  int capi_c_intent = 0;
  PyObject *c_capi = Py_None;
  int f2py_r_d0 = 0;
  int f2py_r_d1 = 0;
  static char *capi_kwlist[] = {"r","q","m","w_t","c",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO:lib.mbd_math.get_coulomb_energy_coupled_osc",\
    capi_kwlist,&r_capi,&q_capi,&m_capi,&w_t_capi,&c_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable r */
  ;
  capi_r_intent |= F2PY_INTENT_IN;
  capi_r_tmp = array_from_pyobj(NPY_DOUBLE,r_Dims,r_Rank,capi_r_intent,r_capi);
  if (capi_r_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `r' of lib.mbd_math.get_coulomb_energy_coupled_osc to C/Fortran array" );
  } else {
    r = (double *)(PyArray_DATA(capi_r_tmp));

  /* Processing variable q */
  q_Dims[0]=size(r, 1);
  capi_q_intent |= F2PY_INTENT_IN;
  capi_q_tmp = array_from_pyobj(NPY_DOUBLE,q_Dims,q_Rank,capi_q_intent,q_capi);
  if (capi_q_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `q' of lib.mbd_math.get_coulomb_energy_coupled_osc to C/Fortran array" );
  } else {
    q = (double *)(PyArray_DATA(capi_q_tmp));

  /* Processing variable m */
  m_Dims[0]=size(r, 1);
  capi_m_intent |= F2PY_INTENT_IN;
  capi_m_tmp = array_from_pyobj(NPY_DOUBLE,m_Dims,m_Rank,capi_m_intent,m_capi);
  if (capi_m_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `m' of lib.mbd_math.get_coulomb_energy_coupled_osc to C/Fortran array" );
  } else {
    m = (double *)(PyArray_DATA(capi_m_tmp));

  /* Processing variable w_t */
  w_t_Dims[0]=3*size(r, 1);
  capi_w_t_intent |= F2PY_INTENT_IN;
  capi_w_t_tmp = array_from_pyobj(NPY_DOUBLE,w_t_Dims,w_t_Rank,capi_w_t_intent,w_t_capi);
  if (capi_w_t_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `w_t' of lib.mbd_math.get_coulomb_energy_coupled_osc to C/Fortran array" );
  } else {
    w_t = (double *)(PyArray_DATA(capi_w_t_tmp));

  /* Processing variable c */
  c_Dims[0]=3*size(r, 1),c_Dims[1]=3*size(r, 1);
  capi_c_intent |= F2PY_INTENT_IN;
  capi_c_tmp = array_from_pyobj(NPY_DOUBLE,c_Dims,c_Rank,capi_c_intent,c_capi);
  if (capi_c_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `c' of lib.mbd_math.get_coulomb_energy_coupled_osc to C/Fortran array" );
  } else {
    c = (double *)(PyArray_DATA(capi_c_tmp));

  /* Processing variable get_coulomb_energy_coupled_osc */
  /* Processing variable f2py_r_d0 */
  f2py_r_d0 = shape(r, 0);
  /* Processing variable f2py_r_d1 */
  f2py_r_d1 = shape(r, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_coulomb_energy_coupled_osc,r,q,m,w_t,c,&f2py_r_d0,&f2py_r_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("f",get_coulomb_energy_coupled_osc);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_r_d1 */
  /* End of cleaning variable f2py_r_d0 */
  /* End of cleaning variable get_coulomb_energy_coupled_osc */
  if((PyObject *)capi_c_tmp!=c_capi) {
    Py_XDECREF(capi_c_tmp); }
  }  /*if (capi_c_tmp == NULL) ... else of c*/
  /* End of cleaning variable c */
  if((PyObject *)capi_w_t_tmp!=w_t_capi) {
    Py_XDECREF(capi_w_t_tmp); }
  }  /*if (capi_w_t_tmp == NULL) ... else of w_t*/
  /* End of cleaning variable w_t */
  if((PyObject *)capi_m_tmp!=m_capi) {
    Py_XDECREF(capi_m_tmp); }
  }  /*if (capi_m_tmp == NULL) ... else of m*/
  /* End of cleaning variable m */
  if((PyObject *)capi_q_tmp!=q_capi) {
    Py_XDECREF(capi_q_tmp); }
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
  if((PyObject *)capi_r_tmp!=r_capi) {
    Py_XDECREF(capi_r_tmp); }
  }  /*if (capi_r_tmp == NULL) ... else of r*/
  /* End of cleaning variable r */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************* end of get_coulomb_energy_coupled_osc *******************/

/*********************** get_dipole_energy_coupled_osc ***********************/
static char doc_f2py_rout_lib_mbd_math_get_dipole_energy_coupled_osc[] = "\
ene = get_dipole_energy_coupled_osc(r,a0,w,w_t,c)\n\nWrapper for ``get_dipole_energy_coupled_osc``.\
\n\nParameters\n----------\n"
"r : input rank-2 array('d') with bounds (f2py_r_d0,f2py_r_d1)\n"
"a0 : input rank-1 array('d') with bounds (size(r, 1))\n"
"w : input rank-1 array('d') with bounds (size(r, 1))\n"
"w_t : input rank-1 array('d') with bounds (3*size(r, 1))\n"
"c : input rank-2 array('d') with bounds (3*size(r, 1),3*size(r, 1))\n"
"\nReturns\n-------\n"
"ene : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_math_get_dipole_energy_coupled_osc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,double*,double*,double*,double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float get_dipole_energy_coupled_osc = 0;
  double *r = NULL;
  npy_intp r_Dims[2] = {-1, -1};
  const int r_Rank = 2;
  PyArrayObject *capi_r_tmp = NULL;
  int capi_r_intent = 0;
  PyObject *r_capi = Py_None;
  double *a0 = NULL;
  npy_intp a0_Dims[1] = {-1};
  const int a0_Rank = 1;
  PyArrayObject *capi_a0_tmp = NULL;
  int capi_a0_intent = 0;
  PyObject *a0_capi = Py_None;
  double *w = NULL;
  npy_intp w_Dims[1] = {-1};
  const int w_Rank = 1;
  PyArrayObject *capi_w_tmp = NULL;
  int capi_w_intent = 0;
  PyObject *w_capi = Py_None;
  double *w_t = NULL;
  npy_intp w_t_Dims[1] = {-1};
  const int w_t_Rank = 1;
  PyArrayObject *capi_w_t_tmp = NULL;
  int capi_w_t_intent = 0;
  PyObject *w_t_capi = Py_None;
  double *c = NULL;
  npy_intp c_Dims[2] = {-1, -1};
  const int c_Rank = 2;
  PyArrayObject *capi_c_tmp = NULL;
  int capi_c_intent = 0;
  PyObject *c_capi = Py_None;
  int f2py_r_d0 = 0;
  int f2py_r_d1 = 0;
  static char *capi_kwlist[] = {"r","a0","w","w_t","c",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO:lib.mbd_math.get_dipole_energy_coupled_osc",\
    capi_kwlist,&r_capi,&a0_capi,&w_capi,&w_t_capi,&c_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable r */
  ;
  capi_r_intent |= F2PY_INTENT_IN;
  capi_r_tmp = array_from_pyobj(NPY_DOUBLE,r_Dims,r_Rank,capi_r_intent,r_capi);
  if (capi_r_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `r' of lib.mbd_math.get_dipole_energy_coupled_osc to C/Fortran array" );
  } else {
    r = (double *)(PyArray_DATA(capi_r_tmp));

  /* Processing variable a0 */
  a0_Dims[0]=size(r, 1);
  capi_a0_intent |= F2PY_INTENT_IN;
  capi_a0_tmp = array_from_pyobj(NPY_DOUBLE,a0_Dims,a0_Rank,capi_a0_intent,a0_capi);
  if (capi_a0_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `a0' of lib.mbd_math.get_dipole_energy_coupled_osc to C/Fortran array" );
  } else {
    a0 = (double *)(PyArray_DATA(capi_a0_tmp));

  /* Processing variable w */
  w_Dims[0]=size(r, 1);
  capi_w_intent |= F2PY_INTENT_IN;
  capi_w_tmp = array_from_pyobj(NPY_DOUBLE,w_Dims,w_Rank,capi_w_intent,w_capi);
  if (capi_w_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `w' of lib.mbd_math.get_dipole_energy_coupled_osc to C/Fortran array" );
  } else {
    w = (double *)(PyArray_DATA(capi_w_tmp));

  /* Processing variable w_t */
  w_t_Dims[0]=3*size(r, 1);
  capi_w_t_intent |= F2PY_INTENT_IN;
  capi_w_t_tmp = array_from_pyobj(NPY_DOUBLE,w_t_Dims,w_t_Rank,capi_w_t_intent,w_t_capi);
  if (capi_w_t_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `w_t' of lib.mbd_math.get_dipole_energy_coupled_osc to C/Fortran array" );
  } else {
    w_t = (double *)(PyArray_DATA(capi_w_t_tmp));

  /* Processing variable c */
  c_Dims[0]=3*size(r, 1),c_Dims[1]=3*size(r, 1);
  capi_c_intent |= F2PY_INTENT_IN;
  capi_c_tmp = array_from_pyobj(NPY_DOUBLE,c_Dims,c_Rank,capi_c_intent,c_capi);
  if (capi_c_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `c' of lib.mbd_math.get_dipole_energy_coupled_osc to C/Fortran array" );
  } else {
    c = (double *)(PyArray_DATA(capi_c_tmp));

  /* Processing variable get_dipole_energy_coupled_osc */
  /* Processing variable f2py_r_d0 */
  f2py_r_d0 = shape(r, 0);
  /* Processing variable f2py_r_d1 */
  f2py_r_d1 = shape(r, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_dipole_energy_coupled_osc,r,a0,w,w_t,c,&f2py_r_d0,&f2py_r_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("f",get_dipole_energy_coupled_osc);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_r_d1 */
  /* End of cleaning variable f2py_r_d0 */
  /* End of cleaning variable get_dipole_energy_coupled_osc */
  if((PyObject *)capi_c_tmp!=c_capi) {
    Py_XDECREF(capi_c_tmp); }
  }  /*if (capi_c_tmp == NULL) ... else of c*/
  /* End of cleaning variable c */
  if((PyObject *)capi_w_t_tmp!=w_t_capi) {
    Py_XDECREF(capi_w_t_tmp); }
  }  /*if (capi_w_t_tmp == NULL) ... else of w_t*/
  /* End of cleaning variable w_t */
  if((PyObject *)capi_w_tmp!=w_capi) {
    Py_XDECREF(capi_w_tmp); }
  }  /*if (capi_w_tmp == NULL) ... else of w*/
  /* End of cleaning variable w */
  if((PyObject *)capi_a0_tmp!=a0_capi) {
    Py_XDECREF(capi_a0_tmp); }
  }  /*if (capi_a0_tmp == NULL) ... else of a0*/
  /* End of cleaning variable a0 */
  if((PyObject *)capi_r_tmp!=r_capi) {
    Py_XDECREF(capi_r_tmp); }
  }  /*if (capi_r_tmp == NULL) ... else of r*/
  /* End of cleaning variable r */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************** end of get_dipole_energy_coupled_osc ********************/

/********************************** get_det **********************************/
static char doc_f2py_rout_lib_mbd_math_get_det[] = "\
d = get_det(a)\n\nWrapper for ``get_det``.\
\n\nParameters\n----------\n"
"a : input rank-2 array('d') with bounds (f2py_a_d0,f2py_a_d1)\n"
"\nReturns\n-------\n"
"d : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_math_get_det(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float get_det = 0;
  double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd_math.get_det",\
    capi_kwlist,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_IN;
  capi_a_tmp = array_from_pyobj(NPY_DOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `a' of lib.mbd_math.get_det to C/Fortran array" );
  } else {
    a = (double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable get_det */
  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&get_det,a,&f2py_a_d0,&f2py_a_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("f",get_det);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  /* End of cleaning variable get_det */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of get_det *******************************/

/********************************* swap_ints *********************************/
static char doc_f2py_rout_lib_mbd_math_swap_ints[] = "\
swap_ints(a,b)\n\nWrapper for ``swap_ints``.\
\n\nParameters\n----------\n"
"a : in/output rank-0 array(int,'i')\n"
"b : in/output rank-0 array(int,'i')";
/*  */
static PyObject *f2py_rout_lib_mbd_math_swap_ints(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int a = 0;
  PyObject *a_capi = Py_None;
  int b = 0;
  PyObject *b_capi = Py_None;
  static char *capi_kwlist[] = {"a","b",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd_math.swap_ints",\
    capi_kwlist,&a_capi,&b_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
    f2py_success = int_from_pyobj(&a,a_capi,"lib.mbd_math.swap_ints() 1st argument (a) can't be converted to int");
  if (f2py_success) {
  /* Processing variable b */
    f2py_success = int_from_pyobj(&b,b_capi,"lib.mbd_math.swap_ints() 2nd argument (b) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&a,&b);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
  f2py_success = try_pyarr_from_int(a_capi,&a);
  if (f2py_success) {
  f2py_success = try_pyarr_from_int(b_capi,&b);
  if (f2py_success) {
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
  } /*if (f2py_success) of b pyobjfrom*/
  } /*if (f2py_success) of a pyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of b*/
  /* End of cleaning variable b */
  } /*if (f2py_success) of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of swap_ints ******************************/

/********************************* get_outer *********************************/
static char doc_f2py_rout_lib_mbd_math_get_outer[] = "\
c = get_outer(a,b)\n\nWrapper for ``get_outer``.\
\n\nParameters\n----------\n"
"a : input rank-1 array('d') with bounds (f2py_a_d0)\n"
"b : input rank-1 array('d') with bounds (f2py_b_d0)\n"
"\nReturns\n-------\n"
"c : rank-2 array('d') with bounds (size(a),size(b)) and get_outer storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_math_get_outer(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *get_outer = NULL;
  npy_intp get_outer_Dims[2] = {-1, -1};
  const int get_outer_Rank = 2;
  PyArrayObject *capi_get_outer_tmp = NULL;
  int capi_get_outer_intent = 0;
  double *a = NULL;
  npy_intp a_Dims[1] = {-1};
  const int a_Rank = 1;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  double *b = NULL;
  npy_intp b_Dims[1] = {-1};
  const int b_Rank = 1;
  PyArrayObject *capi_b_tmp = NULL;
  int capi_b_intent = 0;
  PyObject *b_capi = Py_None;
  int f2py_a_d0 = 0;
  int f2py_b_d0 = 0;
  static char *capi_kwlist[] = {"a","b",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd_math.get_outer",\
    capi_kwlist,&a_capi,&b_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_IN;
  capi_a_tmp = array_from_pyobj(NPY_DOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `a' of lib.mbd_math.get_outer to C/Fortran array" );
  } else {
    a = (double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable b */
  ;
  capi_b_intent |= F2PY_INTENT_IN;
  capi_b_tmp = array_from_pyobj(NPY_DOUBLE,b_Dims,b_Rank,capi_b_intent,b_capi);
  if (capi_b_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `b' of lib.mbd_math.get_outer to C/Fortran array" );
  } else {
    b = (double *)(PyArray_DATA(capi_b_tmp));

  /* Processing variable get_outer */
  get_outer_Dims[0]=size(a),get_outer_Dims[1]=size(b);
  capi_get_outer_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_get_outer_tmp = array_from_pyobj(NPY_DOUBLE,get_outer_Dims,get_outer_Rank,capi_get_outer_intent,Py_None);
  if (capi_get_outer_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `get_outer' of lib.mbd_math.get_outer to C/Fortran array" );
  } else {
    get_outer = (double *)(PyArray_DATA(capi_get_outer_tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_b_d0 */
  f2py_b_d0 = shape(b, 0);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(get_outer,a,b,&f2py_a_d0,&f2py_b_d0);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_get_outer_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_b_d0 */
  /* End of cleaning variable f2py_a_d0 */
  }  /*if (capi_get_outer_tmp == NULL) ... else of get_outer*/
  /* End of cleaning variable get_outer */
  if((PyObject *)capi_b_tmp!=b_capi) {
    Py_XDECREF(capi_b_tmp); }
  }  /*if (capi_b_tmp == NULL) ... else of b*/
  /* End of cleaning variable b */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of get_outer ******************************/

/******************************** print_matrix ********************************/
static char doc_f2py_rout_lib_mbd_math_print_matrix[] = "\
print_matrix(label,a)\n\nWrapper for ``print_matrix``.\
\n\nParameters\n----------\n"
"label : input string(len=-1)\n"
"a : input rank-2 array('d') with bounds (f2py_a_d0,f2py_a_d1)";
/* #declfortranroutine# */
static PyObject *f2py_rout_lib_mbd_math_print_matrix(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,double*,int*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string label = NULL;
  int slen(label);
  PyObject *label_capi = Py_None;
  double *a = NULL;
  npy_intp a_Dims[2] = {-1, -1};
  const int a_Rank = 2;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  int f2py_a_d0 = 0;
  int f2py_a_d1 = 0;
  static char *capi_kwlist[] = {"label","a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:lib.mbd_math.print_matrix",\
    capi_kwlist,&label_capi,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable label */
  slen(label) = -1;
  f2py_success = string_from_pyobj(&label,&slen(label),"",label_capi,"string_from_pyobj failed in converting 1st argument `label' of lib.mbd_math.print_matrix to C string");
  if (f2py_success) {
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_IN;
  capi_a_tmp = array_from_pyobj(NPY_DOUBLE,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `a' of lib.mbd_math.print_matrix to C/Fortran array" );
  } else {
    a = (double *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
  /* Processing variable f2py_a_d1 */
  f2py_a_d1 = shape(a, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(label,a,&f2py_a_d0,&f2py_a_d1,slen(label));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d1 */
  /* End of cleaning variable f2py_a_d0 */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
    STRINGFREE(label);
  }  /*if (f2py_success) of label*/
  /* End of cleaning variable label */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of print_matrix ****************************/

/********************************* e1_twobody *********************************/
static char doc_f2py_rout_lib_mbd_repulsion_e1_twobody[] = "\
e1_twobody(bigomab,ra,rb,coul_en_2b)\n\nWrapper for ``e1_twobody``.\
\n\nParameters\n----------\n"
"bigomab : input rank-2 array('d') with bounds (6,6)\n"
"ra : input rank-1 array('d') with bounds (3)\n"
"rb : input rank-1 array('d') with bounds (3)\n"
"coul_en_2b : input float";
/*  */
static PyObject *f2py_rout_lib_mbd_repulsion_e1_twobody(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *bigomab = NULL;
  npy_intp bigomab_Dims[2] = {-1, -1};
  const int bigomab_Rank = 2;
  PyArrayObject *capi_bigomab_tmp = NULL;
  int capi_bigomab_intent = 0;
  PyObject *bigomab_capi = Py_None;
  double *ra = NULL;
  npy_intp ra_Dims[1] = {-1};
  const int ra_Rank = 1;
  PyArrayObject *capi_ra_tmp = NULL;
  int capi_ra_intent = 0;
  PyObject *ra_capi = Py_None;
  double *rb = NULL;
  npy_intp rb_Dims[1] = {-1};
  const int rb_Rank = 1;
  PyArrayObject *capi_rb_tmp = NULL;
  int capi_rb_intent = 0;
  PyObject *rb_capi = Py_None;
  double coul_en_2b = 0;
  PyObject *coul_en_2b_capi = Py_None;
  static char *capi_kwlist[] = {"bigomab","ra","rb","coul_en_2b",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:lib.mbd_repulsion.e1_twobody",\
    capi_kwlist,&bigomab_capi,&ra_capi,&rb_capi,&coul_en_2b_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable bigomab */
  bigomab_Dims[0]=6,bigomab_Dims[1]=6;
  capi_bigomab_intent |= F2PY_INTENT_IN;
  capi_bigomab_tmp = array_from_pyobj(NPY_DOUBLE,bigomab_Dims,bigomab_Rank,capi_bigomab_intent,bigomab_capi);
  if (capi_bigomab_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `bigomab' of lib.mbd_repulsion.e1_twobody to C/Fortran array" );
  } else {
    bigomab = (double *)(PyArray_DATA(capi_bigomab_tmp));

  /* Processing variable ra */
  ra_Dims[0]=3;
  capi_ra_intent |= F2PY_INTENT_IN;
  capi_ra_tmp = array_from_pyobj(NPY_DOUBLE,ra_Dims,ra_Rank,capi_ra_intent,ra_capi);
  if (capi_ra_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `ra' of lib.mbd_repulsion.e1_twobody to C/Fortran array" );
  } else {
    ra = (double *)(PyArray_DATA(capi_ra_tmp));

  /* Processing variable rb */
  rb_Dims[0]=3;
  capi_rb_intent |= F2PY_INTENT_IN;
  capi_rb_tmp = array_from_pyobj(NPY_DOUBLE,rb_Dims,rb_Rank,capi_rb_intent,rb_capi);
  if (capi_rb_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `rb' of lib.mbd_repulsion.e1_twobody to C/Fortran array" );
  } else {
    rb = (double *)(PyArray_DATA(capi_rb_tmp));

  /* Processing variable coul_en_2b */
    f2py_success = double_from_pyobj(&coul_en_2b,coul_en_2b_capi,"lib.mbd_repulsion.e1_twobody() 4th argument (coul_en_2b) can't be converted to double");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(bigomab,ra,rb,&coul_en_2b);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of coul_en_2b*/
  /* End of cleaning variable coul_en_2b */
  if((PyObject *)capi_rb_tmp!=rb_capi) {
    Py_XDECREF(capi_rb_tmp); }
  }  /*if (capi_rb_tmp == NULL) ... else of rb*/
  /* End of cleaning variable rb */
  if((PyObject *)capi_ra_tmp!=ra_capi) {
    Py_XDECREF(capi_ra_tmp); }
  }  /*if (capi_ra_tmp == NULL) ... else of ra*/
  /* End of cleaning variable ra */
  if((PyObject *)capi_bigomab_tmp!=bigomab_capi) {
    Py_XDECREF(capi_bigomab_tmp); }
  }  /*if (capi_bigomab_tmp == NULL) ... else of bigomab*/
  /* End of cleaning variable bigomab */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of e1_twobody *****************************/

/********************************* e1_onebody *********************************/
static char doc_f2py_rout_lib_mbd_repulsion_e1_onebody[] = "\
e1_onebody(bigoma,ra,rb,coul_en_1b)\n\nWrapper for ``e1_onebody``.\
\n\nParameters\n----------\n"
"bigoma : input rank-2 array('d') with bounds (3,3)\n"
"ra : input rank-1 array('d') with bounds (3)\n"
"rb : input rank-1 array('d') with bounds (3)\n"
"coul_en_1b : input float";
/*  */
static PyObject *f2py_rout_lib_mbd_repulsion_e1_onebody(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *bigoma = NULL;
  npy_intp bigoma_Dims[2] = {-1, -1};
  const int bigoma_Rank = 2;
  PyArrayObject *capi_bigoma_tmp = NULL;
  int capi_bigoma_intent = 0;
  PyObject *bigoma_capi = Py_None;
  double *ra = NULL;
  npy_intp ra_Dims[1] = {-1};
  const int ra_Rank = 1;
  PyArrayObject *capi_ra_tmp = NULL;
  int capi_ra_intent = 0;
  PyObject *ra_capi = Py_None;
  double *rb = NULL;
  npy_intp rb_Dims[1] = {-1};
  const int rb_Rank = 1;
  PyArrayObject *capi_rb_tmp = NULL;
  int capi_rb_intent = 0;
  PyObject *rb_capi = Py_None;
  double coul_en_1b = 0;
  PyObject *coul_en_1b_capi = Py_None;
  static char *capi_kwlist[] = {"bigoma","ra","rb","coul_en_1b",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:lib.mbd_repulsion.e1_onebody",\
    capi_kwlist,&bigoma_capi,&ra_capi,&rb_capi,&coul_en_1b_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable bigoma */
  bigoma_Dims[0]=3,bigoma_Dims[1]=3;
  capi_bigoma_intent |= F2PY_INTENT_IN;
  capi_bigoma_tmp = array_from_pyobj(NPY_DOUBLE,bigoma_Dims,bigoma_Rank,capi_bigoma_intent,bigoma_capi);
  if (capi_bigoma_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `bigoma' of lib.mbd_repulsion.e1_onebody to C/Fortran array" );
  } else {
    bigoma = (double *)(PyArray_DATA(capi_bigoma_tmp));

  /* Processing variable ra */
  ra_Dims[0]=3;
  capi_ra_intent |= F2PY_INTENT_IN;
  capi_ra_tmp = array_from_pyobj(NPY_DOUBLE,ra_Dims,ra_Rank,capi_ra_intent,ra_capi);
  if (capi_ra_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `ra' of lib.mbd_repulsion.e1_onebody to C/Fortran array" );
  } else {
    ra = (double *)(PyArray_DATA(capi_ra_tmp));

  /* Processing variable rb */
  rb_Dims[0]=3;
  capi_rb_intent |= F2PY_INTENT_IN;
  capi_rb_tmp = array_from_pyobj(NPY_DOUBLE,rb_Dims,rb_Rank,capi_rb_intent,rb_capi);
  if (capi_rb_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `rb' of lib.mbd_repulsion.e1_onebody to C/Fortran array" );
  } else {
    rb = (double *)(PyArray_DATA(capi_rb_tmp));

  /* Processing variable coul_en_1b */
    f2py_success = double_from_pyobj(&coul_en_1b,coul_en_1b_capi,"lib.mbd_repulsion.e1_onebody() 4th argument (coul_en_1b) can't be converted to double");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(bigoma,ra,rb,&coul_en_1b);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of coul_en_1b*/
  /* End of cleaning variable coul_en_1b */
  if((PyObject *)capi_rb_tmp!=rb_capi) {
    Py_XDECREF(capi_rb_tmp); }
  }  /*if (capi_rb_tmp == NULL) ... else of rb*/
  /* End of cleaning variable rb */
  if((PyObject *)capi_ra_tmp!=ra_capi) {
    Py_XDECREF(capi_ra_tmp); }
  }  /*if (capi_ra_tmp == NULL) ... else of ra*/
  /* End of cleaning variable ra */
  if((PyObject *)capi_bigoma_tmp!=bigoma_capi) {
    Py_XDECREF(capi_bigoma_tmp); }
  }  /*if (capi_bigoma_tmp == NULL) ... else of bigoma*/
  /* End of cleaning variable bigoma */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of e1_onebody *****************************/

/******************************** fullcoulomb ********************************/
static char doc_f2py_rout_lib_mbd_repulsion_fullcoulomb[] = "\
e1,eatt,erep = fullcoulomb(c,coords,charge,mass,omega,omzero,[natom])\n\nWrapper for ``fullcoulomb``.\
\n\nParameters\n----------\n"
"c : input rank-2 array('d') with bounds (3 * natom,3 * natom)\n"
"coords : input rank-2 array('d') with bounds (natom,3)\n"
"charge : input rank-1 array('d') with bounds (natom)\n"
"mass : input rank-1 array('d') with bounds (natom)\n"
"omega : input rank-1 array('d') with bounds (3 * natom)\n"
"omzero : input rank-1 array('d') with bounds (natom)\n"
"\nOther Parameters\n----------------\n"
"natom : input int, optional\n    Default: (shape(c,0))/(3)\n"
"\nReturns\n-------\n"
"e1 : float\n"
"eatt : float\n"
"erep : float";
/*  */
static PyObject *f2py_rout_lib_mbd_repulsion_fullcoulomb(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,double*,double*,double*,double*,double*,double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int natom = 0;
  PyObject *natom_capi = Py_None;
  double *c = NULL;
  npy_intp c_Dims[2] = {-1, -1};
  const int c_Rank = 2;
  PyArrayObject *capi_c_tmp = NULL;
  int capi_c_intent = 0;
  PyObject *c_capi = Py_None;
  double *coords = NULL;
  npy_intp coords_Dims[2] = {-1, -1};
  const int coords_Rank = 2;
  PyArrayObject *capi_coords_tmp = NULL;
  int capi_coords_intent = 0;
  PyObject *coords_capi = Py_None;
  double *charge = NULL;
  npy_intp charge_Dims[1] = {-1};
  const int charge_Rank = 1;
  PyArrayObject *capi_charge_tmp = NULL;
  int capi_charge_intent = 0;
  PyObject *charge_capi = Py_None;
  double *mass = NULL;
  npy_intp mass_Dims[1] = {-1};
  const int mass_Rank = 1;
  PyArrayObject *capi_mass_tmp = NULL;
  int capi_mass_intent = 0;
  PyObject *mass_capi = Py_None;
  double *omega = NULL;
  npy_intp omega_Dims[1] = {-1};
  const int omega_Rank = 1;
  PyArrayObject *capi_omega_tmp = NULL;
  int capi_omega_intent = 0;
  PyObject *omega_capi = Py_None;
  double *omzero = NULL;
  npy_intp omzero_Dims[1] = {-1};
  const int omzero_Rank = 1;
  PyArrayObject *capi_omzero_tmp = NULL;
  int capi_omzero_intent = 0;
  PyObject *omzero_capi = Py_None;
  double e1 = 0;
  double eatt = 0;
  double erep = 0;
  static char *capi_kwlist[] = {"c","coords","charge","mass","omega","omzero","natom",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOO|O:lib.mbd_repulsion.fullcoulomb",\
    capi_kwlist,&c_capi,&coords_capi,&charge_capi,&mass_capi,&omega_capi,&omzero_capi,&natom_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable c */
  ;
  capi_c_intent |= F2PY_INTENT_IN;
  capi_c_tmp = array_from_pyobj(NPY_DOUBLE,c_Dims,c_Rank,capi_c_intent,c_capi);
  if (capi_c_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 1st argument `c' of lib.mbd_repulsion.fullcoulomb to C/Fortran array" );
  } else {
    c = (double *)(PyArray_DATA(capi_c_tmp));

  /* Processing variable e1 */
  /* Processing variable eatt */
  /* Processing variable erep */
  /* Processing variable natom */
  if (natom_capi == Py_None) natom = (shape(c,0))/(3); else
    f2py_success = int_from_pyobj(&natom,natom_capi,"lib.mbd_repulsion.fullcoulomb() 1st keyword (natom) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR((shape(c,0))/(3)==natom,"(shape(c,0))/(3)==natom","1st keyword natom","fullcoulomb:natom=%d",natom) {
  /* Processing variable charge */
  charge_Dims[0]=natom;
  capi_charge_intent |= F2PY_INTENT_IN;
  capi_charge_tmp = array_from_pyobj(NPY_DOUBLE,charge_Dims,charge_Rank,capi_charge_intent,charge_capi);
  if (capi_charge_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 3rd argument `charge' of lib.mbd_repulsion.fullcoulomb to C/Fortran array" );
  } else {
    charge = (double *)(PyArray_DATA(capi_charge_tmp));

  /* Processing variable mass */
  mass_Dims[0]=natom;
  capi_mass_intent |= F2PY_INTENT_IN;
  capi_mass_tmp = array_from_pyobj(NPY_DOUBLE,mass_Dims,mass_Rank,capi_mass_intent,mass_capi);
  if (capi_mass_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 4th argument `mass' of lib.mbd_repulsion.fullcoulomb to C/Fortran array" );
  } else {
    mass = (double *)(PyArray_DATA(capi_mass_tmp));

  /* Processing variable omzero */
  omzero_Dims[0]=natom;
  capi_omzero_intent |= F2PY_INTENT_IN;
  capi_omzero_tmp = array_from_pyobj(NPY_DOUBLE,omzero_Dims,omzero_Rank,capi_omzero_intent,omzero_capi);
  if (capi_omzero_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 6th argument `omzero' of lib.mbd_repulsion.fullcoulomb to C/Fortran array" );
  } else {
    omzero = (double *)(PyArray_DATA(capi_omzero_tmp));

  /* Processing variable omega */
  omega_Dims[0]=3 * natom;
  capi_omega_intent |= F2PY_INTENT_IN;
  capi_omega_tmp = array_from_pyobj(NPY_DOUBLE,omega_Dims,omega_Rank,capi_omega_intent,omega_capi);
  if (capi_omega_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 5th argument `omega' of lib.mbd_repulsion.fullcoulomb to C/Fortran array" );
  } else {
    omega = (double *)(PyArray_DATA(capi_omega_tmp));

  /* Processing variable coords */
  coords_Dims[0]=natom,coords_Dims[1]=3;
  capi_coords_intent |= F2PY_INTENT_IN;
  capi_coords_tmp = array_from_pyobj(NPY_DOUBLE,coords_Dims,coords_Rank,capi_coords_intent,coords_capi);
  if (capi_coords_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting 2nd argument `coords' of lib.mbd_repulsion.fullcoulomb to C/Fortran array" );
  } else {
    coords = (double *)(PyArray_DATA(capi_coords_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&natom,c,coords,charge,mass,omega,omzero,&e1,&eatt,&erep);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("ddd",e1,eatt,erep);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_coords_tmp!=coords_capi) {
    Py_XDECREF(capi_coords_tmp); }
  }  /*if (capi_coords_tmp == NULL) ... else of coords*/
  /* End of cleaning variable coords */
  if((PyObject *)capi_omega_tmp!=omega_capi) {
    Py_XDECREF(capi_omega_tmp); }
  }  /*if (capi_omega_tmp == NULL) ... else of omega*/
  /* End of cleaning variable omega */
  if((PyObject *)capi_omzero_tmp!=omzero_capi) {
    Py_XDECREF(capi_omzero_tmp); }
  }  /*if (capi_omzero_tmp == NULL) ... else of omzero*/
  /* End of cleaning variable omzero */
  if((PyObject *)capi_mass_tmp!=mass_capi) {
    Py_XDECREF(capi_mass_tmp); }
  }  /*if (capi_mass_tmp == NULL) ... else of mass*/
  /* End of cleaning variable mass */
  if((PyObject *)capi_charge_tmp!=charge_capi) {
    Py_XDECREF(capi_charge_tmp); }
  }  /*if (capi_charge_tmp == NULL) ... else of charge*/
  /* End of cleaning variable charge */
  } /*CHECKSCALAR((shape(c,0))/(3)==natom)*/
  } /*if (f2py_success) of natom*/
  /* End of cleaning variable natom */
  /* End of cleaning variable erep */
  /* End of cleaning variable eatt */
  /* End of cleaning variable e1 */
  if((PyObject *)capi_c_tmp!=c_capi) {
    Py_XDECREF(capi_c_tmp); }
  }  /*if (capi_c_tmp == NULL) ... else of c*/
  /* End of cleaning variable c */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of fullcoulomb *****************************/

/************************************* u2 *************************************/
static char doc_f2py_rout_lib_mbd_repulsion_u2[] = "\
bigu2 = u2(u)\n\nWrapper for ``u2``.\
\n\nParameters\n----------\n"
"u : input float\n"
"\nReturns\n-------\n"
"bigu2 : rank-2 array('d') with bounds (6,6)";
/*  */
static PyObject *f2py_rout_lib_mbd_repulsion_u2(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double u = 0;
  PyObject *u_capi = Py_None;
  double *bigu2 = NULL;
  npy_intp bigu2_Dims[2] = {-1, -1};
  const int bigu2_Rank = 2;
  PyArrayObject *capi_bigu2_tmp = NULL;
  int capi_bigu2_intent = 0;
  static char *capi_kwlist[] = {"u",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:lib.mbd_repulsion.u2",\
    capi_kwlist,&u_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable u */
    f2py_success = double_from_pyobj(&u,u_capi,"lib.mbd_repulsion.u2() 1st argument (u) can't be converted to double");
  if (f2py_success) {
  /* Processing variable bigu2 */
  bigu2_Dims[0]=6,bigu2_Dims[1]=6;
  capi_bigu2_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_bigu2_tmp = array_from_pyobj(NPY_DOUBLE,bigu2_Dims,bigu2_Rank,capi_bigu2_intent,Py_None);
  if (capi_bigu2_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(lib_error,"failed in converting hidden `bigu2' of lib.mbd_repulsion.u2 to C/Fortran array" );
  } else {
    bigu2 = (double *)(PyArray_DATA(capi_bigu2_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&u,bigu2);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_bigu2_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_bigu2_tmp == NULL) ... else of bigu2*/
  /* End of cleaning variable bigu2 */
  } /*if (f2py_success) of u*/
  /* End of cleaning variable u */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/********************************* end of u2 *********************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/

static FortranDataDef f2py_mbd_def[] = {
  {"bohr",0,{{-1}},NPY_DOUBLE},
  {"param_ts_energy_accuracy",0,{{-1}},NPY_DOUBLE},
  {"param_ts_cutoff_radius",0,{{-1}},NPY_DOUBLE},
  {"param_dipole_low_dim_cutoff",0,{{-1}},NPY_DOUBLE},
  {"param_dipole_cutoff",0,{{-1}},NPY_DOUBLE},
  {"param_mayer_scaling",0,{{-1}},NPY_DOUBLE},
  {"param_ewald_real_cutoff_scaling",0,{{-1}},NPY_DOUBLE},
  {"param_ewald_rec_cutoff_scaling",0,{{-1}},NPY_DOUBLE},
  {"param_k_grid_shift",0,{{-1}},NPY_DOUBLE},
  {"param_ewald_on",0,{{-1}},NPY_INT},
  {"param_zero_negative_eigs",0,{{-1}},NPY_INT},
  {"param_mbd_nbody_max",0,{{-1}},NPY_INT},
  {"param_rpa_order_max",0,{{-1}},NPY_INT},
  {"param_vacuum_axis",1,{{3}},NPY_INT},
  {"n_grid_omega",0,{{-1}},NPY_INT},
  {"omega_grid",1,{{-1}},NPY_DOUBLE},
  {"omega_grid_w",1,{{-1}},NPY_DOUBLE},
  {"n_timestamps",0,{{-1}},NPY_INT},
  {"measure_time",0,{{-1}},NPY_INT},
  {"timestamps",1,{{100}},NPY_INT},
  {"ts_counts",1,{{100}},NPY_INT},
  {"ts_cnt",0,{{-1}},NPY_INT},
  {"ts_rate",0,{{-1}},NPY_INT},
  {"ts_cnt_max",0,{{-1}},NPY_INT},
  {"ts_aid",0,{{-1}},NPY_INT},
  {"my_task",0,{{-1}},NPY_INT},
  {"n_tasks",0,{{-1}},NPY_INT},
  {"ts",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_ts,doc_f2py_rout_lib_mbd_ts},
  {"clock_rate",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_clock_rate,doc_f2py_rout_lib_mbd_clock_rate},
  {"get_ts_energy",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_ts_energy,doc_f2py_rout_lib_mbd_get_ts_energy},
  {"add_dipole_matrix",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_add_dipole_matrix,doc_f2py_rout_lib_mbd_add_dipole_matrix},
  {"add_ewald_dipole_parts",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_add_ewald_dipole_parts,doc_f2py_rout_lib_mbd_add_ewald_dipole_parts},
  {"do_scs",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_do_scs,doc_f2py_rout_lib_mbd_do_scs},
  {"do_scs_k_point",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_do_scs_k_point,doc_f2py_rout_lib_mbd_do_scs_k_point},
  {"init_grid",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_init_grid,doc_f2py_rout_lib_mbd_init_grid},
  {"init_eqi_grid",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_init_eqi_grid,doc_f2py_rout_lib_mbd_init_eqi_grid},
  {"test_frequency_grid",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_test_frequency_grid,doc_f2py_rout_lib_mbd_test_frequency_grid},
  {"destroy_grid",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_destroy_grid,doc_f2py_rout_lib_mbd_destroy_grid},
  {"run_scs",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_run_scs,doc_f2py_rout_lib_mbd_run_scs},
  {"get_mbd_energy",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_mbd_energy,doc_f2py_rout_lib_mbd_get_mbd_energy},
  {"get_single_mbd_energy",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_single_mbd_energy,doc_f2py_rout_lib_mbd_get_single_mbd_energy},
  {"get_single_reciprocal_mbd_ene",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_single_reciprocal_mbd_ene,doc_f2py_rout_lib_mbd_get_single_reciprocal_mbd_ene},
  {"get_reciprocal_mbd_energy",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_reciprocal_mbd_energy,doc_f2py_rout_lib_mbd_get_reciprocal_mbd_energy},
  {"get_supercell_mbd_energy",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_supercell_mbd_energy,doc_f2py_rout_lib_mbd_get_supercell_mbd_energy},
  {"get_single_rpa_energy",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_single_rpa_energy,doc_f2py_rout_lib_mbd_get_single_rpa_energy},
  {"eval_mbd_nonint_density",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_eval_mbd_nonint_density,doc_f2py_rout_lib_mbd_eval_mbd_nonint_density},
  {"eval_mbd_int_density",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_eval_mbd_int_density,doc_f2py_rout_lib_mbd_eval_mbd_int_density},
  {"get_single_reciprocal_rpa_ene",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_single_reciprocal_rpa_ene,doc_f2py_rout_lib_mbd_get_single_reciprocal_rpa_ene},
  {"make_g_grid",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_make_g_grid,doc_f2py_rout_lib_mbd_make_g_grid},
  {"make_k_grid",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_make_k_grid,doc_f2py_rout_lib_mbd_make_k_grid},
  {"nbody_coeffs",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_nbody_coeffs,doc_f2py_rout_lib_mbd_nbody_coeffs},
  {"contract_polarizability",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_contract_polarizability,doc_f2py_rout_lib_mbd_contract_polarizability},
  {"get_omega_grid",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_omega_grid,doc_f2py_rout_lib_mbd_get_omega_grid},
  {"gauss_legendre",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_gauss_legendre,doc_f2py_rout_lib_mbd_gauss_legendre},
  {"alpha_dynamic_ts_all",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_alpha_dynamic_ts_all,doc_f2py_rout_lib_mbd_alpha_dynamic_ts_all},
  {"alpha_dynamic_ts",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_alpha_dynamic_ts,doc_f2py_rout_lib_mbd_alpha_dynamic_ts},
  {"alpha_osc",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_alpha_osc,doc_f2py_rout_lib_mbd_alpha_osc},
  {"combine_c6",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_combine_c6,doc_f2py_rout_lib_mbd_combine_c6},
  {"v_to_r",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_v_to_r,doc_f2py_rout_lib_mbd_v_to_r},
  {"omega_eff",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_omega_eff,doc_f2py_rout_lib_mbd_omega_eff},
  {"get_sigma_selfint",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_sigma_selfint,doc_f2py_rout_lib_mbd_get_sigma_selfint},
  {"get_c6_from_alpha",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_c6_from_alpha,doc_f2py_rout_lib_mbd_get_c6_from_alpha},
  {"get_total_c6_from_alpha",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_total_c6_from_alpha,doc_f2py_rout_lib_mbd_get_total_c6_from_alpha},
  {"t_bare",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_t_bare,doc_f2py_rout_lib_mbd_t_bare},
  {"b_erfc",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_b_erfc,doc_f2py_rout_lib_mbd_b_erfc},
  {"c_erfc",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_c_erfc,doc_f2py_rout_lib_mbd_c_erfc},
  {"t_erfc",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_t_erfc,doc_f2py_rout_lib_mbd_t_erfc},
  {"damping_fermi",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_damping_fermi,doc_f2py_rout_lib_mbd_damping_fermi},
  {"damping_erf",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_damping_erf,doc_f2py_rout_lib_mbd_damping_erf},
  {"damping_1mexp",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_damping_1mexp,doc_f2py_rout_lib_mbd_damping_1mexp},
  {"damping_overlap",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_damping_overlap,doc_f2py_rout_lib_mbd_damping_overlap},
  {"t_overlap_coulomb",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_t_overlap_coulomb,doc_f2py_rout_lib_mbd_t_overlap_coulomb},
  {"t_fermi_coulomb",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_t_fermi_coulomb,doc_f2py_rout_lib_mbd_t_fermi_coulomb},
  {"t_erf_coulomb",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_t_erf_coulomb,doc_f2py_rout_lib_mbd_t_erf_coulomb},
  {"t_1mexp_coulomb",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_t_1mexp_coulomb,doc_f2py_rout_lib_mbd_t_1mexp_coulomb},
  {"get_damping_parameters",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_damping_parameters,doc_f2py_rout_lib_mbd_get_damping_parameters},
  {"solve_lin_sys",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_solve_lin_sys,doc_f2py_rout_lib_mbd_solve_lin_sys},
  {"supercell_circum",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_supercell_circum,doc_f2py_rout_lib_mbd_supercell_circum},
  {"shift_cell",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_shift_cell,doc_f2py_rout_lib_mbd_shift_cell},
  {"eye",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_eye,doc_f2py_rout_lib_mbd_eye},
  {"terf",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_terf,doc_f2py_rout_lib_mbd_terf},
  {"invert_ge_dble_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_invert_ge_dble_,doc_f2py_rout_lib_mbd_invert_ge_dble_},
  {"invert_ge_cmplx_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_invert_ge_cmplx_,doc_f2py_rout_lib_mbd_invert_ge_cmplx_},
  {"inverted",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_inverted,doc_f2py_rout_lib_mbd_inverted},
  {"diagonalize_sym_dble_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_diagonalize_sym_dble_,doc_f2py_rout_lib_mbd_diagonalize_sym_dble_},
  {"diagonalized_sym_dble_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_diagonalized_sym_dble_,doc_f2py_rout_lib_mbd_diagonalized_sym_dble_},
  {"diagonalize_ge_dble_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_diagonalize_ge_dble_,doc_f2py_rout_lib_mbd_diagonalize_ge_dble_},
  {"diagonalized_ge_dble_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_diagonalized_ge_dble_,doc_f2py_rout_lib_mbd_diagonalized_ge_dble_},
  {"diagonalize_he_cmplx_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_diagonalize_he_cmplx_,doc_f2py_rout_lib_mbd_diagonalize_he_cmplx_},
  {"diagonalize_ge_cmplx_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_diagonalize_ge_cmplx_,doc_f2py_rout_lib_mbd_diagonalize_ge_cmplx_},
  {"cart_prod_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_cart_prod_,doc_f2py_rout_lib_mbd_cart_prod_},
  {"get_diag_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_diag_,doc_f2py_rout_lib_mbd_get_diag_},
  {"get_diag_cmplx_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_get_diag_cmplx_,doc_f2py_rout_lib_mbd_get_diag_cmplx_},
  {"make_diag_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_make_diag_,doc_f2py_rout_lib_mbd_make_diag_},
  {"tostr_int_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_tostr_int_,doc_f2py_rout_lib_mbd_tostr_int_},
  {"tostr_dble_",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_tostr_dble_,doc_f2py_rout_lib_mbd_tostr_dble_},
  {NULL}
};

static void f2py_setup_mbd(char *bohr,char *param_ts_energy_accuracy,char *param_ts_cutoff_radius,char *param_dipole_low_dim_cutoff,char *param_dipole_cutoff,char *param_mayer_scaling,char *param_ewald_real_cutoff_scaling,char *param_ewald_rec_cutoff_scaling,char *param_k_grid_shift,char *param_ewald_on,char *param_zero_negative_eigs,char *param_mbd_nbody_max,char *param_rpa_order_max,char *param_vacuum_axis,char *n_grid_omega,void (*omega_grid)(int*,int*,void(*)(char*,int*),int*),void (*omega_grid_w)(int*,int*,void(*)(char*,int*),int*),char *n_timestamps,char *measure_time,char *timestamps,char *ts_counts,char *ts_cnt,char *ts_rate,char *ts_cnt_max,char *ts_aid,char *my_task,char *n_tasks,char *ts,char *clock_rate,char *get_ts_energy,char *add_dipole_matrix,char *add_ewald_dipole_parts,char *do_scs,char *do_scs_k_point,char *init_grid,char *init_eqi_grid,char *test_frequency_grid,char *destroy_grid,char *run_scs,char *get_mbd_energy,char *get_single_mbd_energy,char *get_single_reciprocal_mbd_ene,char *get_reciprocal_mbd_energy,char *get_supercell_mbd_energy,char *get_single_rpa_energy,char *eval_mbd_nonint_density,char *eval_mbd_int_density,char *get_single_reciprocal_rpa_ene,char *make_g_grid,char *make_k_grid,char *nbody_coeffs,char *contract_polarizability,char *get_omega_grid,char *gauss_legendre,char *alpha_dynamic_ts_all,char *alpha_dynamic_ts,char *alpha_osc,char *combine_c6,char *v_to_r,char *omega_eff,char *get_sigma_selfint,char *get_c6_from_alpha,char *get_total_c6_from_alpha,char *t_bare,char *b_erfc,char *c_erfc,char *t_erfc,char *damping_fermi,char *damping_erf,char *damping_1mexp,char *damping_overlap,char *t_overlap_coulomb,char *t_fermi_coulomb,char *t_erf_coulomb,char *t_1mexp_coulomb,char *get_damping_parameters,char *solve_lin_sys,char *supercell_circum,char *shift_cell,char *eye,char *terf,char *invert_ge_dble_,char *invert_ge_cmplx_,char *inverted,char *diagonalize_sym_dble_,char *diagonalized_sym_dble_,char *diagonalize_ge_dble_,char *diagonalized_ge_dble_,char *diagonalize_he_cmplx_,char *diagonalize_ge_cmplx_,char *cart_prod_,char *get_diag_,char *get_diag_cmplx_,char *make_diag_,char *tostr_int_,char *tostr_dble_) {
  int i_f2py=0;
  f2py_mbd_def[i_f2py++].data = bohr;
  f2py_mbd_def[i_f2py++].data = param_ts_energy_accuracy;
  f2py_mbd_def[i_f2py++].data = param_ts_cutoff_radius;
  f2py_mbd_def[i_f2py++].data = param_dipole_low_dim_cutoff;
  f2py_mbd_def[i_f2py++].data = param_dipole_cutoff;
  f2py_mbd_def[i_f2py++].data = param_mayer_scaling;
  f2py_mbd_def[i_f2py++].data = param_ewald_real_cutoff_scaling;
  f2py_mbd_def[i_f2py++].data = param_ewald_rec_cutoff_scaling;
  f2py_mbd_def[i_f2py++].data = param_k_grid_shift;
  f2py_mbd_def[i_f2py++].data = param_ewald_on;
  f2py_mbd_def[i_f2py++].data = param_zero_negative_eigs;
  f2py_mbd_def[i_f2py++].data = param_mbd_nbody_max;
  f2py_mbd_def[i_f2py++].data = param_rpa_order_max;
  f2py_mbd_def[i_f2py++].data = param_vacuum_axis;
  f2py_mbd_def[i_f2py++].data = n_grid_omega;
  f2py_mbd_def[i_f2py++].func = omega_grid;
  f2py_mbd_def[i_f2py++].func = omega_grid_w;
  f2py_mbd_def[i_f2py++].data = n_timestamps;
  f2py_mbd_def[i_f2py++].data = measure_time;
  f2py_mbd_def[i_f2py++].data = timestamps;
  f2py_mbd_def[i_f2py++].data = ts_counts;
  f2py_mbd_def[i_f2py++].data = ts_cnt;
  f2py_mbd_def[i_f2py++].data = ts_rate;
  f2py_mbd_def[i_f2py++].data = ts_cnt_max;
  f2py_mbd_def[i_f2py++].data = ts_aid;
  f2py_mbd_def[i_f2py++].data = my_task;
  f2py_mbd_def[i_f2py++].data = n_tasks;
  f2py_mbd_def[i_f2py++].data = ts;
  f2py_mbd_def[i_f2py++].data = clock_rate;
  f2py_mbd_def[i_f2py++].data = get_ts_energy;
  f2py_mbd_def[i_f2py++].data = add_dipole_matrix;
  f2py_mbd_def[i_f2py++].data = add_ewald_dipole_parts;
  f2py_mbd_def[i_f2py++].data = do_scs;
  f2py_mbd_def[i_f2py++].data = do_scs_k_point;
  f2py_mbd_def[i_f2py++].data = init_grid;
  f2py_mbd_def[i_f2py++].data = init_eqi_grid;
  f2py_mbd_def[i_f2py++].data = test_frequency_grid;
  f2py_mbd_def[i_f2py++].data = destroy_grid;
  f2py_mbd_def[i_f2py++].data = run_scs;
  f2py_mbd_def[i_f2py++].data = get_mbd_energy;
  f2py_mbd_def[i_f2py++].data = get_single_mbd_energy;
  f2py_mbd_def[i_f2py++].data = get_single_reciprocal_mbd_ene;
  f2py_mbd_def[i_f2py++].data = get_reciprocal_mbd_energy;
  f2py_mbd_def[i_f2py++].data = get_supercell_mbd_energy;
  f2py_mbd_def[i_f2py++].data = get_single_rpa_energy;
  f2py_mbd_def[i_f2py++].data = eval_mbd_nonint_density;
  f2py_mbd_def[i_f2py++].data = eval_mbd_int_density;
  f2py_mbd_def[i_f2py++].data = get_single_reciprocal_rpa_ene;
  f2py_mbd_def[i_f2py++].data = make_g_grid;
  f2py_mbd_def[i_f2py++].data = make_k_grid;
  f2py_mbd_def[i_f2py++].data = nbody_coeffs;
  f2py_mbd_def[i_f2py++].data = contract_polarizability;
  f2py_mbd_def[i_f2py++].data = get_omega_grid;
  f2py_mbd_def[i_f2py++].data = gauss_legendre;
  f2py_mbd_def[i_f2py++].data = alpha_dynamic_ts_all;
  f2py_mbd_def[i_f2py++].data = alpha_dynamic_ts;
  f2py_mbd_def[i_f2py++].data = alpha_osc;
  f2py_mbd_def[i_f2py++].data = combine_c6;
  f2py_mbd_def[i_f2py++].data = v_to_r;
  f2py_mbd_def[i_f2py++].data = omega_eff;
  f2py_mbd_def[i_f2py++].data = get_sigma_selfint;
  f2py_mbd_def[i_f2py++].data = get_c6_from_alpha;
  f2py_mbd_def[i_f2py++].data = get_total_c6_from_alpha;
  f2py_mbd_def[i_f2py++].data = t_bare;
  f2py_mbd_def[i_f2py++].data = b_erfc;
  f2py_mbd_def[i_f2py++].data = c_erfc;
  f2py_mbd_def[i_f2py++].data = t_erfc;
  f2py_mbd_def[i_f2py++].data = damping_fermi;
  f2py_mbd_def[i_f2py++].data = damping_erf;
  f2py_mbd_def[i_f2py++].data = damping_1mexp;
  f2py_mbd_def[i_f2py++].data = damping_overlap;
  f2py_mbd_def[i_f2py++].data = t_overlap_coulomb;
  f2py_mbd_def[i_f2py++].data = t_fermi_coulomb;
  f2py_mbd_def[i_f2py++].data = t_erf_coulomb;
  f2py_mbd_def[i_f2py++].data = t_1mexp_coulomb;
  f2py_mbd_def[i_f2py++].data = get_damping_parameters;
  f2py_mbd_def[i_f2py++].data = solve_lin_sys;
  f2py_mbd_def[i_f2py++].data = supercell_circum;
  f2py_mbd_def[i_f2py++].data = shift_cell;
  f2py_mbd_def[i_f2py++].data = eye;
  f2py_mbd_def[i_f2py++].data = terf;
  f2py_mbd_def[i_f2py++].data = invert_ge_dble_;
  f2py_mbd_def[i_f2py++].data = invert_ge_cmplx_;
  f2py_mbd_def[i_f2py++].data = inverted;
  f2py_mbd_def[i_f2py++].data = diagonalize_sym_dble_;
  f2py_mbd_def[i_f2py++].data = diagonalized_sym_dble_;
  f2py_mbd_def[i_f2py++].data = diagonalize_ge_dble_;
  f2py_mbd_def[i_f2py++].data = diagonalized_ge_dble_;
  f2py_mbd_def[i_f2py++].data = diagonalize_he_cmplx_;
  f2py_mbd_def[i_f2py++].data = diagonalize_ge_cmplx_;
  f2py_mbd_def[i_f2py++].data = cart_prod_;
  f2py_mbd_def[i_f2py++].data = get_diag_;
  f2py_mbd_def[i_f2py++].data = get_diag_cmplx_;
  f2py_mbd_def[i_f2py++].data = make_diag_;
  f2py_mbd_def[i_f2py++].data = tostr_int_;
  f2py_mbd_def[i_f2py++].data = tostr_dble_;
}
extern void F_FUNC(f2pyinitmbd,F2PYINITMBD)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *));
static void f2py_init_mbd(void) {
  F_FUNC(f2pyinitmbd,F2PYINITMBD)(f2py_setup_mbd);
}


static FortranDataDef f2py_mbd_math_def[] = {
  {"n_pts_coulomb",0,{{-1}},NPY_INT},
  {"l_coulomb",0,{{-1}},NPY_DOUBLE},
  {"point_charge",0,{{-1}},NPY_DOUBLE},
  {"calc_coulomb_coupled_gauss",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_math_calc_coulomb_coupled_gauss,doc_f2py_rout_lib_mbd_math_calc_coulomb_coupled_gauss},
  {"get_coulomb_energy_coupled_osc",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_math_get_coulomb_energy_coupled_osc,doc_f2py_rout_lib_mbd_math_get_coulomb_energy_coupled_osc},
  {"get_dipole_energy_coupled_osc",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_math_get_dipole_energy_coupled_osc,doc_f2py_rout_lib_mbd_math_get_dipole_energy_coupled_osc},
  {"get_det",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_math_get_det,doc_f2py_rout_lib_mbd_math_get_det},
  {"swap_ints",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_math_swap_ints,doc_f2py_rout_lib_mbd_math_swap_ints},
  {"get_outer",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_math_get_outer,doc_f2py_rout_lib_mbd_math_get_outer},
  {"print_matrix",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_math_print_matrix,doc_f2py_rout_lib_mbd_math_print_matrix},
  {NULL}
};

static void f2py_setup_mbd_math(char *n_pts_coulomb,char *l_coulomb,char *point_charge,char *calc_coulomb_coupled_gauss,char *get_coulomb_energy_coupled_osc,char *get_dipole_energy_coupled_osc,char *get_det,char *swap_ints,char *get_outer,char *print_matrix) {
  int i_f2py=0;
  f2py_mbd_math_def[i_f2py++].data = n_pts_coulomb;
  f2py_mbd_math_def[i_f2py++].data = l_coulomb;
  f2py_mbd_math_def[i_f2py++].data = point_charge;
  f2py_mbd_math_def[i_f2py++].data = calc_coulomb_coupled_gauss;
  f2py_mbd_math_def[i_f2py++].data = get_coulomb_energy_coupled_osc;
  f2py_mbd_math_def[i_f2py++].data = get_dipole_energy_coupled_osc;
  f2py_mbd_math_def[i_f2py++].data = get_det;
  f2py_mbd_math_def[i_f2py++].data = swap_ints;
  f2py_mbd_math_def[i_f2py++].data = get_outer;
  f2py_mbd_math_def[i_f2py++].data = print_matrix;
}
extern void F_FUNC_US(f2pyinitmbd_math,F2PYINITMBD_MATH)(void (*)(char*,char*,char*,char *,char *,char *,char *,char *,char *,char *));
static void f2py_init_mbd_math(void) {
  F_FUNC_US(f2pyinitmbd_math,F2PYINITMBD_MATH)(f2py_setup_mbd_math);
}


static FortranDataDef f2py_mbd_repulsion_def[] = {
  {"e1_twobody",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_repulsion_e1_twobody,doc_f2py_rout_lib_mbd_repulsion_e1_twobody},
  {"e1_onebody",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_repulsion_e1_onebody,doc_f2py_rout_lib_mbd_repulsion_e1_onebody},
  {"fullcoulomb",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_repulsion_fullcoulomb,doc_f2py_rout_lib_mbd_repulsion_fullcoulomb},
  {"u2",-1,{{-1}},0,NULL,(void *)f2py_rout_lib_mbd_repulsion_u2,doc_f2py_rout_lib_mbd_repulsion_u2},
  {NULL}
};

static void f2py_setup_mbd_repulsion(char *e1_twobody,char *e1_onebody,char *fullcoulomb,char *u2) {
  int i_f2py=0;
  f2py_mbd_repulsion_def[i_f2py++].data = e1_twobody;
  f2py_mbd_repulsion_def[i_f2py++].data = e1_onebody;
  f2py_mbd_repulsion_def[i_f2py++].data = fullcoulomb;
  f2py_mbd_repulsion_def[i_f2py++].data = u2;
}
extern void F_FUNC_US(f2pyinitmbd_repulsion,F2PYINITMBD_REPULSION)(void (*)(char *,char *,char *,char *));
static void f2py_init_mbd_repulsion(void) {
  F_FUNC_US(f2pyinitmbd_repulsion,F2PYINITMBD_REPULSION)(f2py_setup_mbd_repulsion);
}

/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {

/*eof routine_defs*/
  {NULL}
};

static PyMethodDef f2py_module_methods[] = {

  {NULL,NULL}
};

#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef moduledef = {
  PyModuleDef_HEAD_INIT,
  "lib",
  NULL,
  -1,
  f2py_module_methods,
  NULL,
  NULL,
  NULL,
  NULL
};
#endif

#if PY_VERSION_HEX >= 0x03000000
#define RETVAL m
PyMODINIT_FUNC PyInit_lib(void) {
#else
#define RETVAL
PyMODINIT_FUNC initlib(void) {
#endif
  int i;
  PyObject *m,*d, *s;
#if PY_VERSION_HEX >= 0x03000000
  m = lib_module = PyModule_Create(&moduledef);
#else
  m = lib_module = Py_InitModule("lib", f2py_module_methods);
#endif
  Py_TYPE(&PyFortran_Type) = &PyType_Type;
  import_array();
  if (PyErr_Occurred())
    {PyErr_SetString(PyExc_ImportError, "can't initialize module lib (failed to import numpy)"); return RETVAL;}
  d = PyModule_GetDict(m);
  s = PyString_FromString("$Revision: $");
  PyDict_SetItemString(d, "__version__", s);
#if PY_VERSION_HEX >= 0x03000000
  s = PyUnicode_FromString(
#else
  s = PyString_FromString(
#endif
    "This module 'lib' is auto-generated with f2py (version:2).\nFunctions:\n"
"Fortran 90/95 modules:\n""  mbd --- bohr,param_ts_energy_accuracy,param_ts_cutoff_radius,param_dipole_low_dim_cutoff,param_dipole_cutoff,param_mayer_scaling,param_ewald_real_cutoff_scaling,param_ewald_rec_cutoff_scaling,param_k_grid_shift,param_ewald_on,param_zero_negative_eigs,param_mbd_nbody_max,param_rpa_order_max,param_vacuum_axis,n_grid_omega,omega_grid,omega_grid_w,n_timestamps,measure_time,timestamps,ts_counts,ts_cnt,ts_rate,ts_cnt_max,ts_aid,my_task,n_tasks,ts(),clock_rate(),get_ts_energy(),add_dipole_matrix(),add_ewald_dipole_parts(),do_scs(),do_scs_k_point(),init_grid(),init_eqi_grid(),test_frequency_grid(),destroy_grid(),run_scs(),get_mbd_energy(),get_single_mbd_energy(),get_single_reciprocal_mbd_ene(),get_reciprocal_mbd_energy(),get_supercell_mbd_energy(),get_single_rpa_energy(),eval_mbd_nonint_density(),eval_mbd_int_density(),get_single_reciprocal_rpa_ene(),make_g_grid(),make_k_grid(),nbody_coeffs(),contract_polarizability(),get_omega_grid(),gauss_legendre(),alpha_dynamic_ts_all(),alpha_dynamic_ts(),alpha_osc(),combine_c6(),v_to_r(),omega_eff(),get_sigma_selfint(),get_c6_from_alpha(),get_total_c6_from_alpha(),t_bare(),b_erfc(),c_erfc(),t_erfc(),damping_fermi(),damping_erf(),damping_1mexp(),damping_overlap(),t_overlap_coulomb(),t_fermi_coulomb(),t_erf_coulomb(),t_1mexp_coulomb(),get_damping_parameters(),solve_lin_sys(),supercell_circum(),shift_cell(),eye(),terf(),invert_ge_dble_(),invert_ge_cmplx_(),inverted(),diagonalize_sym_dble_(),diagonalized_sym_dble_(),diagonalize_ge_dble_(),diagonalized_ge_dble_(),diagonalize_he_cmplx_(),diagonalize_ge_cmplx_(),cart_prod_(),get_diag_(),get_diag_cmplx_(),make_diag_(),tostr_int_(),tostr_dble_()""  mbd_math --- n_pts_coulomb,l_coulomb,point_charge,calc_coulomb_coupled_gauss(),get_coulomb_energy_coupled_osc(),get_dipole_energy_coupled_osc(),get_det(),swap_ints(),get_outer(),print_matrix()""  mbd_repulsion --- e1_twobody(),e1_onebody(),fullcoulomb(),u2()"".");
  PyDict_SetItemString(d, "__doc__", s);
  lib_error = PyErr_NewException ("lib.error", NULL, NULL);
  Py_DECREF(s);
  for(i=0;f2py_routine_defs[i].name!=NULL;i++)
    PyDict_SetItemString(d, f2py_routine_defs[i].name,PyFortranObject_NewAsAttr(&f2py_routine_defs[i]));
















































































/*eof initf2pywraphooks*/
  PyDict_SetItemString(d, "mbd_repulsion", PyFortranObject_New(f2py_mbd_repulsion_def,f2py_init_mbd_repulsion));
  PyDict_SetItemString(d, "mbd_math", PyFortranObject_New(f2py_mbd_math_def,f2py_init_mbd_math));
  PyDict_SetItemString(d, "mbd", PyFortranObject_New(f2py_mbd_def,f2py_init_mbd));
/*eof initf90modhooks*/

/*eof initcommonhooks*/


#ifdef F2PY_REPORT_ATEXIT
  if (! PyErr_Occurred())
    on_exit(f2py_report_on_exit,(void*)"lib");
#endif

  return RETVAL;
}
#ifdef __cplusplus
}
#endif
